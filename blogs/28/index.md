# C 语言中以文本方式读写文件时换行符转换的注意事项

C 语言的源代码文件中是以 \n 表示换行。

Windows 下换行采用 \r\n 表示，全称回车换行符。

Linux 下换行采用 \n 表示，即换行符。

早期的 MacOS 下换行采用 \r 表示，即回车符。（现代的 MacOS 改用 \n）

PS：其实，Windows 的 \r\n 代表换行才是最正确的，\r 回车表示将打字机的指针移动到当前行的行首，\n 换行表示将打字机的指针下移一行，\r\n 才表示完整意义的新起一行，也就是目前的【换行】。

由于平台对换行的行为不同，当 C 语言在 Windows 下以文本方式读取文件就会出现一个转换，看如下代码：

```c
FILE * f1;
f1 = fopen("utf8.txt", "r");
/*
    "utf8.txt"文件的十六进制结构如下：
    41 42 43 0D 0A 44 44 4B
*/
fseek(f1, 3, SEEK_SET);
printf("%x\n", getc(f1));
printf("%x\n", getc(f1));
fclose(f1);
```

输出结果：

a
44
Press any key to continue

解释：当我们把文件指针通过 fseek 函数移到位置 3 时，文件指针指向了回车符（0x0D），然后我们用 getc 函数读取当前文件指针所指的字节时，C 语言会把 Windows 下表示换行的 0x0D 和 0x0A 两个字节看成 Linux 下表示换行的 0x0A 一个字节，所以，此时 getc 函数返回的是 0x0A 这个值。故，这次的 getc 函数读完后文件指针向后偏移两个字节，导致了下一个的 getc 返回的是 0x44。

同理，当 C 语言在 Windows 下工作时，用 putc 向文件输入 \n 时会被自动转成 \r\n，如下代码：

```c
FILE * f1;
f1 = fopen("new.txt", "w");
putc('\n', f1);
fclose(f1);
```

"new.txt"文件的十六进制结构：

0D 0A

解释：上述代码会在当前目录创建一个新文件"new.txt"，并以文本方式只写模式打开文件流，然后通过 putc 向该文件输入字符 \n，这时 C 语言会自动把 \n 转为 \r\n，原理同上。

**注意的是：C 语言是否自动转换 \n 与 \r\n 取决于编译 C 语言程序时所在的系统，也同理在 Mac OS 下，C 语言会自动发生 \n 与 \r 的转换。**

当然，这种情况是不会发生转换的：

```c
FILE * f1;
f1 = fopen("utf8.txt", "r");
/*
    该文件的十六进制结构如下：
    31 32 33 0A 0D
*/
fseek(f1, 3, SEEK_SET);
printf("%x\n", getc(f1));
printf("%x\n", getc(f1));
fclose(f1);
```

输出结果：

a
d
Press any key to continue

解释：因为只有在 Windows 下编译的 C 程序，并且以文本方式打开一个文件，并且读取的 0x0D 后面紧跟着 0x0A 才会发生转换，也就是说 0x0D 0x0A 两个字节必须作为一个整体出现，显然，上述代码例子颠倒了 \r\n 的顺序。

另外，在 Mac OS 下编译的 C 程序，以文本方式读取一个以 \n 表示换行的文件时，也是不会发生 \r 与 \n 的转换的，只有该文件以 \r 表示换行时才会发生 \r 与 \n 的转换。

> 2018-07-24
