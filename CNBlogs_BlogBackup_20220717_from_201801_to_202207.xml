<!-- <![CDATA[ ...（位于此处的内容是不被解析的纯文本，且允许任意换行） ]]> -->
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:trackback="http://madskills.com/public/xml/rss/module/trackback/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/"><channel><title>博客园-RYZZ</title><link>http://www.cnblogs.com/ryzz/</link><description>你在雨中行走，你从不打伞，你有你自己的天空，它从不下雨。</description><language>zh-cn</language><lastBuildDate>Sun, 17 Jul 2022 12:31:54 GMT</lastBuildDate><pubDate>Sun, 17 Jul 2022 12:31:54 GMT</pubDate><ttl>60</ttl><item><title>一个简单的JS模板引擎的设计与实现</title><link>http://www.cnblogs.com/ryzz/archive/2022/07/17/16486854.html</link><dc:creator>RYZZ</dc:creator><author>RYZZ</author><pubDate>Sun, 17 Jul 2022 06:47:00 GMT</pubDate><guid>http://www.cnblogs.com/ryzz/archive/2022/07/17/16486854.html</guid><description><![CDATA[```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
  </head>
  <body style="background: gray;">
    <div id="app"></div>
    <script>
      'use strict'

      // 学到：
      // 1. 正则表达式的`.`不能匹配JS的行终止符(\n \r \u2028 \u2029)，所以匹配任意字符的正则表达式是`[\s\S]`
      // 2. 量词的惰性化，在量词后面加`?`即可，使得量词从最长匹配变成最短匹配

      var userListView = `
        <ol>
        <%for ( let i = 0; i < users.length; i++ ){%>
          <li>
            <a href="<%=users[i].url%>">
              <%=users[i].name%>
              is
              <%=users[i].age%>
              years old.
            </a>
          </li>
        <% } %>
        </ol>
        <b>above total: <%= users.length %></b>
      `
      var userListData = [
        { name: 'nat', age: 18, url: 'http://localhost:3000/nat' },
        { name: 'jack', age: 22, url: 'http://localhost:3000/jack' },
      ]

      function myTemplate1(str) {
        var head = "var p = []; with(data){ p.push('" // 起一个开头的push
        var body = str
          .replace(/[\r\n]/g, ' ') // 防止由于换行导致语法解析错误
          .replace(/<%=(.+?)%>/g, "');p.push($1);p.push('") // 先替换表达式，它是<%和%>的特殊例子
          // 下面两行顺序无关紧要，因为被替换的字符串本身不存在交集
          .replace(/%>/g, "p.push('")
          .replace(/<%/g, "');")
        var tail = "');} return p.join('');" // 起一个结束的push
        return new Function('data', head + body + tail)
      }

      function myTemplate2(str) {
        // 升级，对特殊字符进行了处理
        // 1. 处理JS的行终止符(\n)，由于要把字符串代码通过new Function包装产生函数，其本质是解析传入的字符串，所以诸如`new Function("var a = 'ab\nc';")`直接报错，而是要`"var a = 'ab\\nc';"`，前者源代码文本就被换行了，导致了语法解析错误，JS一共有4个终止符，\r \n \u2028 \u2029，除了IE遵守这个标准，其他浏览器只把\n当作行终止符，其他都视作零宽空白字符
        // 2. 处理单引号和反斜杠这两个特殊字符
        // 最终：**把真正的 \r \n \u2028 \u2029 \' \\ 变成对应的文本形式，即从1个字符变成2个字符，从而防止这些特殊字符参与JS源代码的语法解析**
        // 有点难理解的地方是 '\\': '\\' 和 '\'': '\''
        // 这是因为单字符的 \' 和双字符的 \' 表现是一样的
        var escapes = {
          '\n': 'n',
          '\r': 'r',
          '\u2028': 'u2028',
          '\u2029': 'u2029',
          '\\': '\\',
          "'": "'",
        }
        var escapeReg = /[\n\r\u2028\u2029\\']/g
        var escapeChar = (match) => '\\' + escapes[match]
        // 换了一种实现方式，不再使用数组，直接使用字符串拼接（效率高了）
        var head = "var p = ''; with(data){ p+='" // 起一个开始的单引号
        var body = str
          .replace(escapeReg, escapeChar) // 是第一版的[\r\n]升级版，第一版的做法是把会导致在new Function时使得JS解析失败的语法直接替换成空格，而这个版本做法保留了这些特殊字符，但是在new Function之前把它们文本化了，这就确保了模板输出的目标字符串和模板本身的格式相同
          // .replace(/<%=(.+?)%>/g, '\'+ $1 +\'') // 和第一版一样也是先求表达式
          // 上面当目标表达式返回的结果是不符合预期的，比如undefined，也会输出它，这是不希望的，加入判断
          .replace(/<%=(.+?)%>/g, "' + ($1 || '') + '")
          .replace(/<%(.+?)%>/g, "'; $1 p+='")
        var tail = "';} return p;" // 起一个结束的单引号
        return new Function('data', head + body + tail)
      }

      function myTemplate3(str) {
        // 最终版本，继续优化了性能，在一个replace完成全部替换
        var [interpolate, evaluate] = [/<%=(.+?)%>/g, /<%(.+?)%>/g] // interpolate插值 和 evaluate语句
        var matcher = new RegExp(
          `${interpolate.source}|${evaluate.source}|$`,
          'g'
        )
        var index = 0,
          p = ''
        var escapes = {
          '\n': 'n',
          '\r': 'r',
          '\u2028': 'u2028',
          '\u2029': 'u2029',
          '\\': '\\',
          "'": "'",
        }
        var escapeReg = /[\n\r\u2028\u2029\\']/g
        var escapeChar = (match) => '\\' + escapes[match]
        str.replace(matcher, function (match, interpolate, evaluate, offset) {
          // 正则对象的lastIndex属性只有在开启g标志且在regexp.exec和regexp.test方法有效，指定下次匹配的开始位置，此属性可读可写，如果方法没找到任何匹配则自动将它设置0，而在这里，用index来模拟lastIndex的作用
          // 另外需要注意，matcher最后的`$`目的是匹配字符串结束位置，从而得到结束位置的offset，当`$`发生匹配时，match是空字符串，因为`$`是零宽断言，确实发生匹配但是没有匹配内容，故返回空字符串

          // 使用slice方法取子字符串的副本，确保str保持不变
          // 将本次匹配到的<%=xxx%>或<%xxx%>之前的文本进行特殊字符文本化
          p += str.slice(index, offset).replace(escapeReg, escapeChar)

          // 记录下次replace匹配的开始位置
          index = offset + match.length

          // 进行替换
          // 这里巧妙利用了正则表达式的 捕获分组 和 或运算
          // `/part1(group1)|part2(group2)|part3/g`这是上面matcher的结构，由于或运算的存在，只要三者之一匹配成功，整个正则表达式匹配成功，就会执行replace的回调函数，由于group1和group2必然要存在（因为它们写在正则表达式里面），那么其中某一个就得是undefined，如果是part3发生的匹配，那么group1和group2都是undefined
          if (interpolate) {
            p += `' + (${interpolate} || \'\') + '`
          } else if (evaluate) {
            p += `'; ${evaluate} p+='`
          }

          // 把匹配到的字符串原封不动地还回去，确保str保持不变
          return match
        })
        // 给p拼上头部和尾部的代码
        p = "var p = ''; with(data){ p+='" + p + "';} return p;"
        // 可以在`new Function`包上try-catch语句，避免创建函数失败
        return new Function('data', p)
      }

      // var userListRender1 = myTemplate1(userListView);
      // var userListRender2 = myTemplate2(userListView);
      var userListRender3 = myTemplate3(userListView)
      // var res1 = userListRender1({users: userListData});
      // var res2 = userListRender2({users: userListData});
      var res3 = userListRender3({ users: userListData })
      // console.log('res1', res1);
      // console.log('res2', res2);
      console.log('res3', res3)
      // document.getElementById('app').innerHTML = res1;
      // document.getElementById('app').innerHTML = res2;
      document.getElementById('app').innerHTML = res3

      // underscore 0.1.1
      function underscore_template(str, data) {
        var fn = new Function(
          'obj',
          'var p=[],print=function(){p.push.apply(p,arguments);};' +
            "with(obj){p.push('" +
            str
              .replace(/[\r\t\n]/g, ' ')
              .split('<%')
              .join('\t')
              .replace(/((^|%>)[^\t]*)'/g, '$1\r')
              .replace(/\t=(.*?)%>/g, "',$1,'")
              .split('\t')
              .join("');")
              .split('%>')
              .join("p.push('")
              .split('\r')
              .join("\\'") +
            "');}return p.join('');"
        )
        return data ? fn(data) : fn
      }
    </script>
  </body>
</html>

```
]]></description></item><item><title>学习Vue2.x源码时总结的学习文档</title><link>http://www.cnblogs.com/ryzz/archive/2022/07/01/16433302.html</link><dc:creator>RYZZ</dc:creator><author>RYZZ</author><pubDate>Fri, 01 Jul 2022 00:36:00 GMT</pubDate><guid>http://www.cnblogs.com/ryzz/archive/2022/07/01/16433302.html</guid><description><![CDATA[为了更好地学习 Vue2.x 的源码，故模仿着 Vue2.x 的源码并引入了一些 React 的思想，写了一个自己的前端框架 Rue，同时在写 Rue 的期间，总结了一些学习文档，将这些文档托管在了 gitee 上并一直保持更新。

地址：https://gitee.com/ryzz/rue#%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3
]]></description></item><item><title>浏览器与服务器长连接技术</title><link>http://www.cnblogs.com/ryzz/archive/2021/04/29/14717582.html</link><dc:creator>RYZZ</dc:creator><author>RYZZ</author><pubDate>Thu, 29 Apr 2021 05:20:00 GMT</pubDate><guid>http://www.cnblogs.com/ryzz/archive/2021/04/29/14717582.html</guid><description><![CDATA[浏览器和服务器保持持久连接的手段。

## 定时器
最简单，使用setTimeout、setInterval或其他计时手段定期向服务器发送请求，此方法优点就是简单，缺点就是不灵活，容易造成大量没有意义的请求，而且，如果网络某段时刻拥塞，那么上一个请求就会覆盖本次请求，导致旧的数据覆盖了新的数据。

## 长轮询
浏览器向服务器发出一个请求，服务器收到请求并将这个请求挂起(pending)，当服务器需要向浏览器发送数据了，就响应挂起的这个请求，浏览器收到响应之后立刻再发送一个请求，服务器再把它挂起，如此反复，即实现了最简单的长轮询机制，它不需要任何新的协议。
适合B/S不频繁的通信，因为即便是很小的数据量，也要重新发送一个完整的http请求。
浏览器端代码：
```js
function validHttpStatus(){
  return arguments[0] > 199 && arguments[0] < 300;
}
async function longPolling(){
  let response = await fetch("http://localhost:3000/getdata");
  if (!validHttpStatus(response.status)) {
    // 发生了错误，打印一下错误
    console.error(`${response.url}: ${response.statusText}`);
    setTimeout(longPolling, 1e3); // 过一会再试
  }else{
    // 打印出服务器返回的数据
    let data = await response.text();
    console.info(data);
    // 立刻再次调用，保持连接一直处于打开状态
    longPolling();
  }
}
longPolling(); // 开始长轮询
```
服务器端代码：
```js
// 使用了Koa
function delay(seconds){
  return new Promise(ok => setTimeout(ok, 1e3*seconds));
}
router.get('/getdata', async(ctx, next) => {
  ctx.set('Access-Control-Allow-Origin', '*');
  ctx.set('Content-Type', 'text/plain; charset=utf-8');
  ctx.set("Cache-Control", "no-store"); // 禁用缓存
  await delay(Math.floor(Math.random()*10) + 1); // 模拟服务器突然向浏览器响应数据
  ctx.body = 'hi ' + (new Date);
  await next();
});
```

## Server Sent Event
规范文档: https://html.spec.whatwg.org/multipage/server-sent-events.html#the-eventsource-interface
浏览器内建的EventSource构造函数能创建一个对应的实例，只有IE全系列不支持。
支持SSE的服务器使用`text/event-stream`格式推送消息。
约束：
1. 只能由服务器向浏览器推送数据，浏览器不能主动向服务器发送数据
2. 推送的数据只能是文本

SSE使用的也是http协议，它可以自动重连，而websocket需要我们手动处理重连，对于单向的且数据量不多的情景可以使用SSE，没必要强行使用websocket。
浏览器端代码：
```js
function start(){
  var eventSource = new EventSource('http://localhost:3000/getdata');
  eventSource.onmessage = function(e){ // 或addEventListener
    console.log('a new msg here:', e.data);
  };
  eventSource.addEventListener('goodbye', function(e){
    // 对于自定义事件，不能使用onxxxx，必须是addEventListener
    console.log('finial message:', e.data);
  });
  setTimeout(() => { // 一小时后自动关闭
    // 一旦一个EventSource实例被关闭，就无法再复用它了，必须再新建一个实例
    eventSource.close();
  }, 1e3*60*60);
}
// start(); // 启动
```
服务器端代码：
```js
var http = require('http');
var count = 0;
http.createServer(function(req, res){
  res.setHeader('Access-Control-Allow-Origin', '*');
  if (req.url.includes('getdata')){
    if (count++ == 2){ // 2次之后不让浏览器继续连接了
      count = 0; // 重置
      res.statusCode = 204; // 规范约定了204是告诉浏览器不要重试了，服务器关闭连接了，204状态码本身表示无内容，No-Content
      res.end();
      return;
    }
    res.statusCode = 200;
    res.setHeader('Content-Type', 'text/event-stream; charset=utf-8');
    let id = setInterval(() => {
      // 每条消息以双LF分隔，每条消息还有event、retry和id字段
      // event: 表示本消息的事件名，浏览器需要对它进行addEventListener
      // retry: 告诉浏览器重试等待事件，单位毫秒，默认3000
      // id：本消息的ID，重试时浏览器会发送最后一个接收到的ID以告诉服务器从哪继续开始重传，就像TCP的ack确认号
      res.write(`data: hi ${new Date}\n\n`);
    }, (Math.floor(Math.random()*2) + 1)*1e3);
    setTimeout(() => {
      clearInterval(id);
      // 本次消息周期完成，然后浏览器将尝试自动重连
      res.end(`event: goodbye\ndata: see next time\n\n`);
    }, 1e3*4);
  }else{
    res.end();
  }
}).listen(3000);
```

## WebSocket
是浏览器和服务器全双工通信的解决方案，通信不基于http（websocket握手还是采用http），而是使用自己的ws协议，以及TSL加密的wss协议。
当浏览器请求建立websocket连接时，发送的http请求有2个重要字段：（不能使用XHR或fetch来模拟websocket的握手，因为JavaScript无法设置这些请求头）
GET /getdata
Connection: Upgrade // 表示浏览器需要改变（升级）协议
Upgrade: websocket // 改变为websocket
如果服务器支持websocket，就判断来源并同意是否升级，如果同意返回如下响应：
101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
握手完成了，之后就是用ws的数据帧开始通信了。
强大的websocket：
1. 它没有同源策略的限制
2. 浏览器对它支持很好，IE10开始也支持了
3. 既可以发送文本也可以发送二进制
4. 2个方法4个事件
  方法：
  - `socket.send(data)`
  - `socket.close([code], [reason])`
  事件：
  - `open`
  - `message`
  - `error`
  - `close`

浏览器端代码：
```js
function start(){
  var id;
  let socket = new WebSocket('ws://localhost:3000/getdata'); // 注意是ws://
  socket.binaryType = 'arraybuffer'; // 默认是'blob'，即把接收到的二进制当作blob，blob是有类型的二进制数据块，作为高层的二进制数据存在，可以直接供<a>、<img>等标签使用，而arraybuffer提供了细颗粒的二进制操作
  socket.onopen = function(e){
    console.log("opened");
    socket.send('hi'); // 发送文本
    // id = setInterval(() => {
    //   socket.send(new Uint8Array([1,2,3,4])); // 发送二进制，可以是ArrayBuffer或Blob
    // }, 2000);
  };
  socket.onmessage = function(e){
    console.log('a msg here:', e.data);
  };
  socket.onclose = function(e){
    console.log(`closed, code=${e.code}, reason=${e.reason}`);
    // clearInterval(id);
    // 如果返回的code是1006，表示对方被异常关闭，比如进程被杀死了，而这个状态码是无法通过代码设置的
  };
}
// start(); // 启动
```
服务器端代码：
```js
const http = require('http');
const ws = require('ws');

const wsinstance = new ws.Server({noServer: true});

http.createServer(function(req, res){
  // 只接受websocket
  if (!req.headers.upgrade || req.headers.upgrade.toLowerCase() != 'websocket') {
    res.end();
    return;
  }
  // Connection: keep-alive, Upgrade
  if (!/upgrade/i.test(req.headers.connection)) {
    res.end();
    return;
  }
  // 进行协议升级
  wsinstance.handleUpgrade(req, req.socket, Buffer.allocUnsafe(0), function(ws){
    ws.on('message', function(data){
      console.log('receive data from browser:', data);
      // ws.send(`now ${new Date}!`); // 发送文本
      ws.send(new Uint8Array([5,6,7,8])); // 发送二进制数据
      setTimeout(() => ws.close(1000, "Bye!"), 5000);
    })
  });
}).listen(3000);
```
]]></description></item><item><title>webpack打包的bundle.js源码分析</title><link>http://www.cnblogs.com/ryzz/archive/2021/03/16/14542861.html</link><dc:creator>RYZZ</dc:creator><author>RYZZ</author><pubDate>Tue, 16 Mar 2021 04:53:00 GMT</pubDate><guid>http://www.cnblogs.com/ryzz/archive/2021/03/16/14542861.html</guid><description><![CDATA[## webpack.config.js

```js
const { resolve } = require("path");
module.exports = {
  mode: "development",
  entry: "./src/index.js",
  output: {
    filename: "bundle.js",
    path: resolve("dist"),
  },
};
```

## 源文件

`index.js`：入口

```js
import * as operation from "./oper.js";
console.log(
  `i am index.js, and i imported a module whose description is: ${operation.desc}.`
);
console.log(`4 + 5 = ${operation.add(4, 5)}`);
console.log(`4 * 5 = ${operation.mul(4, 5)}`);
```

`oper.js`：自定义模块

```js
function add() {
  return [].slice.call(arguments).reduce((acc, val) => acc + val);
}
function mul() {
  return [].slice.call(arguments).reduce((acc, val) => acc * val);
}
var desc = "some math operations";
export { add, mul, desc };
```

## webpack4 的 bundle.js

```js
/******/ (function (modules) {
  // webpackBootstrap
  /******/ // The module cache
  /******/ var installedModules = {};
  /******/
  /******/ // The require function
  /******/ function __webpack_require__(moduleId) {
    /******/ // 此函数执行一个模块（已经被webpack封装成了函数，即modules），返回这个模块的导出
    /******/ // Check if module is in cache
    /******/ if (installedModules[moduleId]) {
      /******/ return installedModules[moduleId].exports;
      /******/
    }
    /******/ // Create a new module (and put it into the cache)
    /******/ var module = (installedModules[moduleId] = {
      /******/ i: moduleId, // 字符串或数字
      /******/ l: false, // l = loaded
      /******/ exports: {},
      /******/
    });
    /******/
    /******/ // Execute the module function
    // webpack把ES6模块风格的JS文件转成CommonJS，故传入module、module.exports和require
    /******/ modules[moduleId].call(
      module.exports,
      module,
      module.exports,
      __webpack_require__
    );
    /******/
    /******/ // Flag the module as loaded
    /******/ module.l = true;
    /******/
    /******/ // Return the exports of the module
    /******/ return module.exports;
    /******/
  }
  /******/
  /******/
  /******/ // expose the modules object (__webpack_modules__)
  // 全部模块的原始函数
  /******/ __webpack_require__.m = modules;
  /******/
  /******/ // expose the module cache
  // 模块缓存
  /******/ __webpack_require__.c = installedModules;
  /******/
  /******/ // define getter function for harmony exports
  // 工具函数，设置一个返回模块导出的name对应的值的getter
  // 比如模块oper.js导出了desc，那么它导出的exports对象存在一个叫做desc的访问器getter，此访问器通过闭包返回原本desc对应的值
  /******/ __webpack_require__.d = function (exports, name, getter) {
    /******/ if (!__webpack_require__.o(exports, name)) {
      /******/ Object.defineProperty(exports, name, {
        enumerable: true,
        get: getter,
      });
      /******/
    }
    /******/
  };
  /******/
  /******/ // define __esModule on exports
  // 给exports对象设置相关属性，表示此对象是ES6模块
  /******/ __webpack_require__.r = function (exports) {
    /******/ if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
      /******/ Object.defineProperty(exports, Symbol.toStringTag, {
        value: "Module",
      });
      /******/
    }
    /******/ Object.defineProperty(exports, "__esModule", { value: true });
    /******/
  };
  /******/
  /******/ // create a fake namespace object
  /******/ // mode & 1: value is a module id, require it
  /******/ // mode & 2: merge all properties of value into the ns
  /******/ // mode & 4: return value when already ns object
  /******/ // mode & 8|1: behave like require
  // 尚不清楚
  /******/ __webpack_require__.t = function (value, mode) {
    /******/ if (mode & 1) value = __webpack_require__(value);
    /******/ if (mode & 8) return value;
    /******/ if (
      mode & 4 &&
      typeof value === "object" &&
      value &&
      value.__esModule
    )
      return value;
    /******/ var ns = Object.create(null);
    /******/ __webpack_require__.r(ns);
    /******/ Object.defineProperty(ns, "default", {
      enumerable: true,
      value: value,
    });
    /******/ if (mode & 2 && typeof value != "string")
      for (var key in value)
        __webpack_require__.d(
          ns,
          key,
          function (key) {
            return value[key];
          }.bind(null, key)
        );
    /******/ return ns;
    /******/
  };
  /******/
  /******/ // getDefaultExport function for compatibility with non-harmony modules
  // harmony module就是ES6模块
  // 如果是ES6的module就取default，不是ES6的module就直接返回此module
  // 当oper.js使用`module.exports = {add, mul, desc};`导出时
  // 当index.js使用`import operation from './oper.js';`导入时
  // oper.js不会被webpack做任何处理，意味着oper.js导出的exports对象不会被__webpack_require__.r函数加工，即表明此exports不是ES6模块
  // 同时将会在index.js观察到__webpack_require__.n被调用了，代码如下
  // /* harmony import */ var _oper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./oper.js */ "./src/oper.js");
  // /* harmony import */ var _oper_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_oper_js__WEBPACK_IMPORTED_MODULE_0__);
  /******/ __webpack_require__.n = function (module) {
    /******/ var getter =
      module && module.__esModule
        ? /******/ function getDefault() {
            return module["default"];
          }
        : /******/ function getModuleExports() {
            return module;
          };
    /******/ __webpack_require__.d(getter, "a", getter); // 这个设置访问器（由于访问器就叫做getter，但是此函数内部也有个getter变量，为避免混淆，本句的访问器和getter不是一个意思）的方法很巧妙，getter函数给自身设置了一个叫做a的访问器，而这个访问器又是getter函数本身，调用这个getter函数会返回闭包当中的module.default或module
    /******/ return getter;
    // 返回的getter是一个函数，函数自身属性`a`就是默认的导出
    /******/
  };
  /******/
  /******/ // Object.prototype.hasOwnProperty.call
  // 工具函数hasOwnProperty
  /******/ __webpack_require__.o = function (object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  };
  /******/
  /******/ // __webpack_public_path__
  // 模块的基本路径
  /******/ __webpack_require__.p = "";
  /******/
  /******/
  /******/ // Load entry module and return exports
  // __webpack_require__.s表示入口模块
  /******/ return __webpack_require__(
    (__webpack_require__.s = "./src/index.js")
  );
  /******/
})(
  /************************************************************************/
  /******/ {
    // webpack会将全部的ES模块语法转成CommonJS模块语法
    // ES6的导出和导入都会被等效地替换成__webpack_require__.d和 __webpack_require__函数
    /***/ "./src/index.js":
      /*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
      /*! no exports provided */
      /***/ function (module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // 严格模式下的eval会生成自己的作用域，避免影响其原本所在的作用域
        // 字符串末尾的`sourceURL`表示源映射，能将此eval的代码映射到一个虚拟的JS文件，可以在浏览器开发者工具的Sources(Chrome)和调试器(FireFox)观察到
        // 比如下面eval的代码会被映射到webpack:///src/index.js这个文件，就可以很方便地在此JS文件中打断点调试
        eval(
          '__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _oper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./oper.js */ "./src/oper.js");\n\r\n\r\nconsole.log(`i am index.js, and i imported a module whose description is: ${_oper_js__WEBPACK_IMPORTED_MODULE_0__["desc"]}.`);\r\n\r\nconsole.log(`4 + 5 = ${_oper_js__WEBPACK_IMPORTED_MODULE_0__["add"](4, 5)}`);\r\nconsole.log(`4 * 5 = ${_oper_js__WEBPACK_IMPORTED_MODULE_0__["mul"](4, 5)}`);\r\n\n\n//# sourceURL=webpack:///./src/index.js?'
        );

        /***/
      },

    /***/ "./src/oper.js":
      /*!*********************!*\
  !*** ./src/oper.js ***!
  \*********************/
      /*! exports provided: add, mul, desc */
      /***/ function (module, __webpack_exports__, __webpack_require__) {
        "use strict";
        eval(
          '__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "desc", function() { return desc; });\nfunction add(){\r\n\treturn [].slice.call(arguments).reduce( (acc, val)=>acc+val );\r\n}\r\n\r\nfunction mul(){\r\n\treturn [].slice.call(arguments).reduce( (acc, val)=>acc*val );\r\n}\r\n\r\nvar desc = \'some math operations\';\r\n\r\n\r\n\n\n//# sourceURL=webpack:///./src/oper.js?'
        );

        /***/
      },

    /******/
  }
);
```

打包后的`index.js`：

```js
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _oper_js__WEBPACK_IMPORTED_MODULE_0__ =
  __webpack_require__(/*! ./oper.js */ "./src/oper.js");
console.log(
  `i am index.js, and i imported a module whose description is: ${_oper_js__WEBPACK_IMPORTED_MODULE_0__["desc"]}.`
);
console.log(`4 + 5 = ${_oper_js__WEBPACK_IMPORTED_MODULE_0__["add"](4, 5)}`);
console.log(`4 * 5 = ${_oper_js__WEBPACK_IMPORTED_MODULE_0__["mul"](4, 5)}`);
//# sourceURL=webpack:///./src/index.js?
```

打包后的`oper.js`：

```js
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(
  __webpack_exports__,
  "add",
  function () {
    return add;
  }
);
/* harmony export (binding) */ __webpack_require__.d(
  __webpack_exports__,
  "mul",
  function () {
    return mul;
  }
);
/* harmony export (binding) */ __webpack_require__.d(
  __webpack_exports__,
  "desc",
  function () {
    return desc;
  }
);
function add() {
  return [].slice.call(arguments).reduce((acc, val) => acc + val);
}
function mul() {
  return [].slice.call(arguments).reduce((acc, val) => acc * val);
}
var desc = "some math operations";
//# sourceURL=webpack:///./src/oper.js?
```

## webpack5 的 bundle.js

```js
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 * webpack处于`mode: development`时默认使用`devtool: eval`
 * 上述是对处于`devtool: eval`模式的一些注意事项
 * 使用任何`eval`的devtool都会有类似的注意事项，比如`devtool: eval-source-map`
 * 打包结果和webpack4很像，只是少了webpack4内置的兼容函数，剩下的函数和变量作用都和webpack4差不多
 */
/******/ (() => {
  // webpackBootstrap
  /******/ "use strict";
  /******/ var __webpack_modules__ = {
    /***/ "./src/index.js":
      /*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        eval(
          '__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _oper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./oper.js */ "./src/oper.js");\n\r\n\r\nconsole.log(`i am index.js, and i imported a module whose description is: ${_oper_js__WEBPACK_IMPORTED_MODULE_0__.desc}.`);\r\n\r\nconsole.log(`4 + 5 = ${_oper_js__WEBPACK_IMPORTED_MODULE_0__.add(4, 5)}`);\r\nconsole.log(`4 * 5 = ${_oper_js__WEBPACK_IMPORTED_MODULE_0__.mul(4, 5)}`);\r\n\n\n//# sourceURL=webpack://webpacktest5/./src/index.js?'
        );

        /***/
      },

    /***/ "./src/oper.js":
      /*!*********************!*\
  !*** ./src/oper.js ***!
  \*********************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        eval(
          '__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "add": () => (/* binding */ add),\n/* harmony export */   "mul": () => (/* binding */ mul),\n/* harmony export */   "desc": () => (/* binding */ desc)\n/* harmony export */ });\nfunction add(){\r\n\treturn [].slice.call(arguments).reduce( (acc, val)=>acc+val );\r\n}\r\n\r\nfunction mul(){\r\n\treturn [].slice.call(arguments).reduce( (acc, val)=>acc*val );\r\n}\r\n\r\nvar desc = \'some math operations\';\r\n\r\n\r\n\n\n//# sourceURL=webpack://webpacktest5/./src/oper.js?'
        );

        /***/
      },

    /******/
  };
  /************************************************************************/
  /******/ // The module cache
  /******/ var __webpack_module_cache__ = {};
  /******/
  /******/ // The require function
  /******/ function __webpack_require__(moduleId) {
    /******/ // Check if module is in cache
    /******/ var cachedModule = __webpack_module_cache__[moduleId];
    /******/ if (cachedModule !== undefined) {
      /******/ return cachedModule.exports;
      /******/
    }
    /******/ // Create a new module (and put it into the cache)
    /******/ var module = (__webpack_module_cache__[moduleId] = {
      /******/ // no module.id needed
      /******/ // no module.loaded needed
      /******/ exports: {},
      /******/
    });
    /******/
    /******/ // Execute the module function
    /******/ __webpack_modules__[moduleId](
      module,
      module.exports,
      __webpack_require__
    );
    /******/
    /******/ // Return the exports of the module
    /******/ return module.exports;
    /******/
  }
  /******/
  /************************************************************************/
  /******/ /* webpack/runtime/define property getters */
  // 使用一个IIFE给__webpack_require__添加一个方法，下同
  /******/ (() => {
    /******/ // define getter functions for harmony exports
    /******/ __webpack_require__.d = (exports, definition) => {
      /******/ for (var key in definition) {
        /******/ if (
          __webpack_require__.o(definition, key) &&
          !__webpack_require__.o(exports, key)
        ) {
          /******/ Object.defineProperty(exports, key, {
            enumerable: true,
            get: definition[key],
          });
          /******/
        }
        /******/
      }
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/hasOwnProperty shorthand */
  /******/ (() => {
    /******/ __webpack_require__.o = (obj, prop) =>
      Object.prototype.hasOwnProperty.call(obj, prop);
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/make namespace object */
  /******/ (() => {
    /******/ // define __esModule on exports
    /******/ __webpack_require__.r = (exports) => {
      /******/ if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
        /******/ Object.defineProperty(exports, Symbol.toStringTag, {
          value: "Module",
        });
        /******/
      }
      /******/ Object.defineProperty(exports, "__esModule", { value: true });
      /******/
    };
    /******/
  })();
  /******/
  /************************************************************************/
  /******/
  /******/ // startup
  /******/ // Load entry module and return exports
  /******/ // This entry module can't be inlined because the eval devtool is used.
  /******/ var __webpack_exports__ = __webpack_require__("./src/index.js");
  /******/
  /******/
})();
```
]]></description></item><item><title>JavaScript的Map、Set、WeakMap和WeakSet</title><link>http://www.cnblogs.com/ryzz/archive/2020/11/02/13914786.html</link><dc:creator>RYZZ</dc:creator><author>RYZZ</author><pubDate>Mon, 02 Nov 2020 07:42:00 GMT</pubDate><guid>http://www.cnblogs.com/ryzz/archive/2020/11/02/13914786.html</guid><description><![CDATA[Object：对象，存储键值对数据，键名必须是字符串或Symbol，标准没有规定对象属性的存储顺序
Map：映射，键名可以是任意数据类型，能记住每组键值对插入的顺序，在`for..of`迭代时能按照插入的顺序以`[key, value]`格式输出
Array：数组，下标在表现上是数字，但实际上是将数字转换成字符进行存储的，不过引擎会对数组的下标查找进行优化
Set：集合，值唯一的数组
WeakMap：弱引用的Map，仅接受对象作为key，如果对象本身没有其他的引用了（不包括WeakMap），那么自动从WeakMap删除
WeakSet：弱引用的Set，仅接受对象作为value，如果对象本身没有其他的引用了（不包括WeakSet），那么自动从WeakSet删除

Map的键和Set的值相等比较依据：（底层比较算法是`SameValueZero`，参见ES6规范的`7.2.10`小节）
`NaN`与`NaN`相等（即便`NaN !== NaN` === true），且`-0`和`+0`严格相等，其他的值根据`===`运算符来判断是否相等。
故：在Map，多个值是`NaN`的键会发生覆盖；在Set，多个`NaN`的值会只保留一个。

Map基本操作：
新建Map数据类型：`new Map()`或`new Map([[key1, val1], [key2, val1]])`或`new Map(anotherMapObject)`或其他能返回`[key, value]`格式的一维数组的可迭代对象
插入：`Map#set(key, val)`，返回Map对象本身，相同的键名的值会覆盖（即更新）
读取：`Map#get(key)`，键名不存在返回`undefined`
删除：`Map#delete(key)`，删除存在的键名返回`true`，删除不存在的键名返回`false`
存在：`Map#has(key)`，判断一个键是否存在
返回长度：`Map#size`，这是一个getter属性
遍历：`Map#forEach((thisVal, thisKey, thisMap) => {}, thisArg)`
清空：`Map#clear()`，无返回值
获取key和value的迭代对象：`Map#entries()`，返回的迭代对象按照插入顺序生产值`[key, value]`
获取仅key的迭代对象：`Map#keys()`，返回的迭代对象按照插入顺序生产值`key`
获取仅value的迭代对象：`Map#values()`，返回的迭代对象按照插入顺序生产值`value`
可从`Array.from(mapObject)`得到Map对象对应的二维数组（等价于`Array.from(mapObject.entries())`），这与使用展开运算符`[...mapObject]`相同。
Map对象可以进行浅拷贝，即`new Map(anotherMapObject)`。
本质上，Map让你将一些额外的信息（值）与一个对象（键）相关联，而不用将这些信息实际存储在对象本身中。

Set基本操作：
新建Set数据类型：`new Set()`或`new Set([val1, val2])`或`new Set('string')`或`new Set(anotherSetObject)`或其他能返回`value`格式的可迭代对象
插入：`Set#add(value)`，插入，如果已经存在相同的值，忽略本次操作
删除：`Set#delete(value)`，移除与给定值相同的值，如果值存在返回true，否则返回false
存在：`Set#has(value)`，判断值是否存在
遍历：`Set#forEach((thisVal, thisKey, thisSet) => {}, thisArg)`
清空：`Set#clear()`，无返回值
返回长度：`Set#size`，这是一个getter属性
获取key和value的迭代对象：`Set#entries()`，返回的迭代对象按照插入顺序生产值`[value, value]`，之所以返回两个相同元素的数组是为了与`Set#entries()`保持一致
获取仅value的迭代对象：`Set#values()`或`Set#keys()`，返回的迭代对象按照插入顺序生产值`value`
Set迭代出来的值的顺序与插入时的一致。
可从`Array.from(setObject)`得到Set对象对应的一维数组（等价于`Array.from(setObject.values())`），这与使用展开运算符`[...setObject]`相同。
Set对象可以进行浅拷贝，即`new Set(anotherSetObject)`。

WeakMap的提出：
Map的实现其实是利用了二维数组，保存一次set时候对应的`[key, value]`，故查找的算法复杂是O(n)。
注意：WeakMap仅有set、get、has和delete方法，没有size属性！
```js
var foo = new Map();
(function(){
	var obj = { aa: 11 };
	foo.set(obj, 'obj.aa.value.11');
}());
console.log(foo.size); // 1
// 由于立即函数的作用域已不复存在，意味着无法再访问obj对象，无法再通过foo.get方法得到键obj对应的值
// 但是可以通过`for..of`遍历出这对键值对
// 由于保存key的数组引用了立即函数内部的obj对象，导致即便obj在外部已经不可访问，但仍旧在内存中保存着（因为存在引用），这就造成了内存泄露
var bar = new WeakMap();
(function(){
	var obj = { bb: 22 };
	bar.set(obj, 'obj.bb.value.22');
}());
console.log(bar); // bar会在下一轮GC之后变成空WeakMap，这就意味着WeakMap的size是不确定的！所以，WeakMap也没有提供size属性和其他任何能得到它长度或全部内容的方法！
// 由于不具备size属性和一切迭代方法，同时由于立即函数的obj无法在函数外被访问，也不能使用get方法判断，你只能信任引擎一定会将没有任何引用的obj对象从WeakMap中删除
// Map对它的键持有强引用（GC不能忽略此引用），而WeakMap对它的键持有弱引用（GC可以忽略此引用）
// 不过，WeakMap的键对它的值(value)持有强引用，即
// 在WeakMap中，如果一对键值对的键不存在任何引用了，这对键值对就会自动从WeakMap中删除；而如果一对键值对的值不存在除WeakMap之外的其他任何引用了，这对键值对并不会从WeakMap中删除
```
WeakMap的polyfill：
```js
// WeakMap的polyfill
var WeakMap = function(){
	this.name = '__wm__' + getUUID();
};
WeakMap.prototype.set = function(key, value){
	Object.defineProperty(key, this.name, { // 重点
		value: [key, value]
	});
	return this;
};
WeakMap.prototype.get = function(key){
	var entry = key[this.name]; // 拿到 set 时候放在目标对象属性的值
	return entry && (entry[0] === key ? entry[1] : undefined);
};
// 可以看出WeakMap不再和Map一样使用二维数组来存储数据（格式：`[[key, value], ...]`），而是直接将值`[key, value]`定义在传入的对象本身的属性`this.name`上，故而WeakMap只接收对象作为key
```

WeakSet只能存储对象，且只是持有对这些对象的弱引用，即如果有对象没有再被引用，那么这个对象就会被GC，也自然而然地从WeakSet中删除，出于此，WeakSet是不可被枚举的，和WeakMap一样也仅有set、get、has和delete方法，也没有size属性！。

**注意：WeakSet或WeakMap都没有size属性和任何迭代方法！<b style="color: red;">这是因为：我们无法确定浏览器什么时候进行GC，一旦浏览器进行了GC，WeakSet或WeakMap的长度有可能减少了！那么刚刚拿到的长度也就没有意义了！</b>**

> 《你不知道的JavaScript（下）》GitHub中文第一版对WeakMap描述：WeakMap（仅）接收对象作为键。这些对象被**弱**持有，这意味着如果对象本身被垃圾回收掉了，那么在WeakMap中的记录也会被移除。**这是观察不到的**，因为一个对象可以被垃圾回收的唯一方法是不再有指向它的引用，一旦不再有指向它的引用，你就没有对象引用可以用来检查它是否存在于这个WeakMap中。
> 同理，WeakSet只是**弱**持有它的值。
]]></description></item><item><title>AJAX传输二进制数据</title><link>http://www.cnblogs.com/ryzz/archive/2020/10/21/13853633.html</link><dc:creator>RYZZ</dc:creator><author>RYZZ</author><pubDate>Wed, 21 Oct 2020 09:24:00 GMT</pubDate><guid>http://www.cnblogs.com/ryzz/archive/2020/10/21/13853633.html</guid><description><![CDATA[## FormData对象
1. 将整个表单元素映射成一个对象，可实现自动拼接表单对象数据成请求参数的格式
2. 可以上传二进制数据

### 利用FormData上传文本数据的表单：
前端网页核心代码：
```html
<form id="myform"> <!-- form属于块元素 -->
	用户名 = <input type="text" name="username" value=""> <br>
	密码 = <input type="password" name="pwd" value=""> <br>
	<input type="button" name="go" value="提交" onclick="doit()">
</form>
<script>
"use strict"
var myform = document.getElementById('myform');
var formdata; // 如果现在执行`formdata = new FormData(myform)`会导致formdata中的表单数据是空
function doit(){
	formdata = new FormData(myform);
	// FormDate API：https://developer.mozilla.org/zh-CN/docs/Web/API/FormData
	var xhr = new XMLHttpRequest();
	if (formdata.get('username') == 'nat'){ // IE11支持FormData构造器但是不支持get、set等一些方法
		formdata.set('usernameOrigin', 'nat');
		formdata.set('username', 'natasha'); // 同名的键会覆盖
		formdata.delete('pwd');
		formdata.append('username', 'natashe'); // 同名的键会保留
	}
	for (let x of formdata){
		console.log(x); // 如果'username'传入的是'nat'那么输出如下：
		// Array [ "username", "natasha" ]
		// Array [ "usernameOrigin", "nat" ]
		// Array [ "username", "natashe" ]
		// 如果服务器不进行特殊设置，那么username只能获取到最后一次的值，即'natashe'（设置略）
	}
	xhr.open('POST', '/postdata');
	xhr.send(formdata); // 会自动将'Content-Type'设置成'multipart/form-data; boundary=---------------------------20808984378436579741074229525'
	// 注意，FormData数据在Node的Express框架中不能直接通过中间件body-parser获取，尝试通过`req.body`获取始终返回空对象，而是通过`cnpm install --save formidable`这个模块获取，但是它不是中间件
	xhr.onload = function(){
		if (xhr.status == 200){
			console.log(xhr.responseText);
		}else{
			console.log('Something error happened: ', xhr);
		}
	}
}
</script>
```
后端Node核心代码：
```js
const formidable = require('formidable');
app.post('/postdata', (req,res)=>{
	var form = new formidable.IncomingForm();
	form.parse(req, (err, fields, files)=>{
		// fields是普通的表单数据（文本）
		// files是上传的文件数据
		console.log(fields);
		res.send('ok');
	});
});
```
### 利用FormData上传二进制数据的本地文件：
前端网页核心代码：
```html
<form id="myform">
	昵称 = <input type="text" name="nickname"> <br>
	文件 = <input type="file" name="doc"> <br>
	<input type="button" name="go" value="提交" onclick="doit()">
</form>
<script>
"use strict"
var myform = document.getElementById('myform');
var formdata;
function doit(){
	formdata = new FormData(myform);
	var xhr = new XMLHttpRequest();
	xhr.open('POST', '/postdata');
	xhr.upload.onprogress = function(e){
		// 这个事件必须在send之前监听有效，在send之后监听不会触发
		console.log(`当前进度：${Math.floor(e.loaded / e.total * 100)}%`);
	}
	xhr.send(formdata);
	xhr.onload = function(){
		if (xhr.status == 200){
			console.log(xhr.responseText);
		}else{
			console.log('Something error happened: ', xhr);
		}
	}
}
</script>
```
后端Node核心代码：
```js
app.post('/postdata', (req,res)=>{
	var form = new formidable.IncomingForm();
	form.uploadDir = './webroot/uploads'; // 上传的文件保存在哪个目录
	form.keepExtensions = true; // 保留上传时的后缀名
	form.parse(req, (err, fields, files)=>{
		// fields是普通的表单数据（文本）
		// files是上传的文件数据
		console.log(fields);
		console.log(files.doc.path); // 'webroot\\uploads\\upload_4242811d6678445365bbc7c55c0a968f.dat'
		res.send('ok');
	});
});
```

## XHR上传和下载二进制数据（TypedArray和Blob）
[接收和发送二进制数据的MDN文档](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data)
### TypedArray
#### 前端传给后端
```js
// 前端
var data = new ArrayBuffer(64);
var dataview = new Uint8Array(data);
for (let i=0; i<data.byteLength-1; i++){
	dataview[i] = 97 + (i % 26); // 将64字节的二进制数据初始化成[a-z]的小写字母
}
dataview[data.byteLength-1] = 0;
function doit(){
	var xhr = new XMLHttpRequest();
	xhr.open('POST', '/postdata');
	// xhr.setRequestHeader('Content-Type', 'application/octet-stream'); // 表示通用二进制流，可不写
	xhr.send(data);
	xhr.onload = function(){
		if (xhr.status == 200){
			console.log(xhr.responseText);
		}else{
			console.log('Something error happened: ', xhr);
		}
	}
}
// 通过抓包，send出去的报文就是ArrayBuffer的二进制数据
// Node原生http服务器收到的POST数据默认是Buffer类型
```
```js
// 后端
app.post('/postdata', (req,res)=>{
	var tmpchunk = [];
	var data;
	req.on('data', (chunk)=>{
		tmpchunk.push(chunk);
	});
	req.on('end', ()=>{
		data = Buffer.concat(tmpchunk);
		console.log(data);
		res.send('ok');
	})
});
```
#### 后端传给前端
```js
// 前端
function doit(){
	var xhr = new XMLHttpRequest();
	xhr.open('GET', '/getdata');
	xhr.responseType = 'arraybuffer';
	xhr.send();
	xhr.onload = function(){
		if (xhr.status == 200){
			console.log(xhr.response); // ArrayBuffer 字节长度：8
		}else{
			console.log('Something error happened: ', xhr);
		}
	}
}
```
```js
// 后端
app.get('/getdata', (req,res)=>{
	res.set('Content-Type','application/octet-stream');
	var data = new ArrayBuffer(8);
	var dataview = new Uint8Array(data);
	dataview[1] = 11;
	dataview[3] = 22;
	dataview[5] = 33;
	dataview[7] = 44;
	data = Buffer.from(data); // 将ArrayBuffer转换成Buffer
	res.send(data); // 如果send的是ArrayBuffer，会被JSON化成'{}'（注意，实际没有单引号，这里只做分隔符），只能传入Buffer才能使send方法正确发送二进制数据，通过抓包得到的响应体的数据是：00 0b 00 16 00 21 00 2c
});
```

### Blob
#### 前端传给后端
```js
var data = new Blob(['haha']);
function doit(){
	var xhr = new XMLHttpRequest();
	xhr.open('POST', '/postdata');
	// xhr.setRequestHeader('Content-Type', 'application/octet-stream'); // 表示通用二进制流，可不写
	xhr.send(data);
	xhr.onload = function(){
		if (xhr.status == 200){
			console.log(xhr.responseText);
		}else{
			console.log('Something error happened: ', xhr);
		}
	}
}
// 原理同ArrayBuffer，send出去的报文就是Blob的二进制数据，报文的请求体：h a h a
```
#### 后端传给前端
```js
// 注意，Node不存在Blob，只需要传递Buffer即可，故此后端代码同【TypedArray的后端传给前端】
// 前端：将xhr.responseType = 'arraybuffer' -> 'blob'，获取到的xhr.response返回`Blob{size: 8, type: "application/json"}`，其中的type会被自动设置成响应头中的'Content-Type'
```

## 旧时代的二进制传输
在xhr.responseType还没有'arraybuffer'、'blob'甚至'json'的时代，AJAX还没有传递二进制功能，但是可以hack出来（目前已经不行了）：
```js
function doit(){
	// 没设置responseType的话（默认值是""），相当于设置了"text"
	// 如果响应报文存在`Content-Type = text/plain; charset=someCharset`，浏览器尝试使用此编码来解析响应数据
	// 如果Content-Type不是text或指定的编码不支持，浏览器尝试使用默认的UTF-8编码来解析响应数据
	var xhr = new XMLHttpRequest();
	xhr.open('GET', 'http://localhost:3000/getdata');
	xhr.overrideMimeType('Content-Type', 'text/plain; charset=x-user-defined'); // 告诉浏览器不要尝试解析数据，直接返回未处理过的字节数据，目前浏览器（测试浏览器：Chrome>=69, FF>=80）即便设置了此方法也无法覆盖对应的响应头字段，已经无效
	xhr.send(null);
	xhr.onload = function(){
		if (xhr.status == 200){
			// console.log(xhr.getAllResponseHeaders()); // 即便上面已经覆盖了，但是取到的还是原始的响应头
			// 也就是下面的代码已经无法使用了，overrideMimeType方法被忽略的最主要原因可能是现代的AJAX已经支持了原生二进制数据传递
			var data = xhr.response; // 值是'\u0000\u0061\u007F\uFFFD\uFFFD\uFFFD'，因为浏览器尝试将收到的数据当做UTF-8编码的文本来解析，而解析失败的字符被填充'\uFFFD'
			// 128 = 1000,0000 而UTF-8编码表没有10起始的字符，故转换失败被填充0xFFFD
			// 同理，254 = 1111,1110 和 255 = 1111,1111 都不符合UTF-8编码，都转0XFFFD
			var len = data.length;
			var received = new ArrayBuffer(len);
			var receivedview = new Uint8Array(received);
			for (let i=0; i<len; i++){
				receivedview[i] = data.charCodeAt(i);
			}
			console.log(receivedview); // 输出Uint8Array(6)[0, 97, 127, 253, 253, 253]
			// '\uFFFD'.charCodeAt(0) = 65533
			// 将65533存入Uint8Array时，将发生转换，转换的结果便是253
		}else{
			console.log('Something error happened: ', xhr);
		}
	}
}
```
```js
// 后端
app.get('/getdata', (req,res)=>{
	var data = Buffer.allocUnsafe(6);
	data[0] = 0; data[1] = 97; data[2] = 127; data[3] = 128; data[4] = 254; data[5] = 255;
	res.setHeader('Content-Type', 'application/octet-stream');
	res.send(data);
});
```]]></description></item><item><title>JavaScript实现timeoutify、asyncify和promiseify</title><link>http://www.cnblogs.com/ryzz/archive/2020/07/08/13264798.html</link><dc:creator>RYZZ</dc:creator><author>RYZZ</author><pubDate>Wed, 08 Jul 2020 00:26:00 GMT</pubDate><guid>http://www.cnblogs.com/ryzz/archive/2020/07/08/13264798.html</guid><description><![CDATA[<p>三个在JavaScript异步编程中常用的ployfill工具：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">function</span><span style="color: #000000;"> timeoutify(f,t){
</span><span style="color: #008080;"> 2</span>     <span style="color: #008000;">//</span><span style="color: #008000;">作用：对异步函数做超时检测，当异步函数在指定的时间内完成时才让它调用传入的回调</span>
<span style="color: #008080;"> 3</span>     let id=setTimeout(()=&gt;<span style="color: #000000;">{
</span><span style="color: #008080;"> 4</span>         id=<span style="color: #000000;">undefined;
</span><span style="color: #008080;"> 5</span> <span style="color: #000000;">    },t);
</span><span style="color: #008080;"> 6</span>     <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
</span><span style="color: #008080;"> 7</span>         <span style="color: #0000ff;">if</span><span style="color: #000000;"> (id){
</span><span style="color: #008080;"> 8</span>             <span style="color: #008000;">//</span><span style="color: #008000;">id还存在说明没有超时</span>
<span style="color: #008080;"> 9</span> <span style="color: #000000;">            clearTimeout(id);
</span><span style="color: #008080;">10</span>             f.apply(<span style="color: #0000ff;">this</span><span style="color: #000000;">,arguments);
</span><span style="color: #008080;">11</span>         }<span style="color: #0000ff;">else</span><span style="color: #000000;">{
</span><span style="color: #008080;">12</span>             <span style="color: #008000;">//</span><span style="color: #008000;">id是undefined说明超时了</span>
<span style="color: #008080;">13</span> <span style="color: #000000;">            f(Error(`Refuse to execute the callback beacuse of Timeout.`));
</span><span style="color: #008080;">14</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">15</span> <span style="color: #000000;">    };
</span><span style="color: #008080;">16</span> <span style="color: #000000;">}
</span><span style="color: #008080;">17</span> 
<span style="color: #008080;">18</span> <span style="color: #0000ff;">function</span><span style="color: #000000;"> asyncify(f){
</span><span style="color: #008080;">19</span>     <span style="color: #008000;">//</span><span style="color: #008000;">作用：避免出现Zalgo竞态条件，使异步函数对回调的调用始终是异步调用</span>
<span style="color: #008080;">20</span> <span style="color: #000000;">    let id,origin_f;
</span><span style="color: #008080;">21</span>     id=setTimeout(()=&gt;{ <span style="color: #008000;">//</span><span style="color: #008000;">使用hack=setTimeout(0)检测回调是否被异步调用</span>
<span style="color: #008080;">22</span>         id=<span style="color: #000000;">undefined;
</span><span style="color: #008080;">23</span>         <span style="color: #0000ff;">if</span> (f){ <span style="color: #008000;">//</span><span style="color: #008000;">能进入这个if语句，说明回调被同步调用</span>
<span style="color: #008080;">24</span>             f(); <span style="color: #008000;">//</span><span style="color: #008000;">使用hack-setTimeout(0)对这个回调强制进行异步调用</span>
<span style="color: #008080;">25</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">26</span>     },0<span style="color: #000000;">);
</span><span style="color: #008080;">27</span>     origin_f=<span style="color: #000000;">f;
</span><span style="color: #008080;">28</span>     f=<span style="color: #0000ff;">null</span><span style="color: #000000;">;
</span><span style="color: #008080;">29</span>     <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">function</span><span style="color: #000000;"> _result(){
</span><span style="color: #008080;">30</span>         <span style="color: #008000;">//</span><span style="color: #008000;">原理：当调用asyncify时，立刻进行setTimeout(0)倒计时，只有是同步调用，才会导致触发_result时id存在值</span>
<span style="color: #008080;">31</span>         <span style="color: #0000ff;">if</span><span style="color: #000000;"> (id){
</span><span style="color: #008080;">32</span>             <span style="color: #008000;">//</span><span style="color: #008000;">id还存在说明出现了Zalgo，即这个回调被同步调用了，要避免这种情况</span>
<span style="color: #008080;">33</span>             f=origin_f.bind.apply(origin_f,[<span style="color: #0000ff;">this</span>].concat([].slice.call(arguments))); <span style="color: #008000;">//</span><span style="color: #008000;">arguments作为科里化参数</span>
<span style="color: #008080;">34</span>         }<span style="color: #0000ff;">else</span><span style="color: #000000;">{
</span><span style="color: #008080;">35</span>             <span style="color: #008000;">//</span><span style="color: #008000;">已经是异步了，正常执行</span>
<span style="color: #008080;">36</span>             origin_f.apply(<span style="color: #0000ff;">this</span><span style="color: #000000;">,arguments);
</span><span style="color: #008080;">37</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">38</span> <span style="color: #000000;">    };
</span><span style="color: #008080;">39</span> <span style="color: #000000;">}
</span><span style="color: #008080;">40</span> 
<span style="color: #008080;">41</span> <span style="color: #0000ff;">function</span><span style="color: #000000;"> promiseify(f){
</span><span style="color: #008080;">42</span>     <span style="color: #008000;">//</span><span style="color: #008000;">作用：将一个传统的异步函数promise化</span>
<span style="color: #008080;">43</span>     <span style="color: #008000;">/*</span>
<span style="color: #008080;">44</span> <span style="color: #008000;">    传入的异步函数要求：
</span><span style="color: #008080;">45</span> <span style="color: #008000;">    1.最后一个参数是回调函数
</span><span style="color: #008080;">46</span> <span style="color: #008000;">    2.这个回调函数使用error-first风格
</span><span style="color: #008080;">47</span> <span style="color: #008000;">    promiseify返回一个新函数，新函数的参数列表移除了原函数参数列表的回调函数，其他参数相同
</span><span style="color: #008080;">48</span>     <span style="color: #008000;">*/</span>
<span style="color: #008080;">49</span>     <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
</span><span style="color: #008080;">50</span>         <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> Promise((ok,fail)=&gt;<span style="color: #000000;">{
</span><span style="color: #008080;">51</span>             let args=<span style="color: #000000;">[].slice.call(arguments);
</span><span style="color: #008080;">52</span>             args.push(<span style="color: #0000ff;">function</span>(err,data){ <span style="color: #008000;">//</span><span style="color: #008000;">传入用于断定promise决议结果的函数作为原函数的回调函数</span>
<span style="color: #008080;">53</span>                 <span style="color: #0000ff;">if</span><span style="color: #000000;">(err)
</span><span style="color: #008080;">54</span>                     fail(err); <span style="color: #008000;">//</span><span style="color: #008000;">ok和fail函数本身不返回值（即返回undefined）</span>
<span style="color: #008080;">55</span>                 <span style="color: #0000ff;">else</span>
<span style="color: #008080;">56</span> <span style="color: #000000;">                    ok(data);
</span><span style="color: #008080;">57</span>                 
<span style="color: #008080;">58</span> <span style="color: #000000;">            });
</span><span style="color: #008080;">59</span>             f.apply(<span style="color: #0000ff;">this</span><span style="color: #000000;">,args);
</span><span style="color: #008080;">60</span> <span style="color: #000000;">        });
</span><span style="color: #008080;">61</span> <span style="color: #000000;">    };
</span><span style="color: #008080;">62</span> }</pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>关于encodeURIComponent编码非UTF-8字符时出现的怪异情况</title><link>http://www.cnblogs.com/ryzz/archive/2020/03/31/12606447.html</link><dc:creator>RYZZ</dc:creator><author>RYZZ</author><pubDate>Tue, 31 Mar 2020 09:04:00 GMT</pubDate><guid>http://www.cnblogs.com/ryzz/archive/2020/03/31/12606447.html</guid><description><![CDATA[<p>现在有个test.html文件，这个文件的编码是UTF-8，其中&ldquo;你好&rdquo;的UTF-8编码是：E4 BD A0 E5 A5 BD，文件代码如下：</p>
<div class="cnblogs_Highlighter">
<pre class="brush:html;gutter:true;">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;script&gt;
	console.log(encodeURIComponent("你好")); //%E4%BD%A0%E5%A5%BD
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
	&lt;p&gt;hello&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
</div>
<p>可以看见，enencodeURIComponent就是将&ldquo;你好&rdquo;以UTF-8编码输出（这也正是encodeURIComponent方法的定义：将非URI字符都以UTF-8编码的格式输出为字符串），现在来看一个怪异的情况，还是上面的test.html（所以文件的编码依旧是UTF-8），只不过这次手动把charset改为了GBK编码，用来误导encodeURIComponent方法，代码如下：</p>
<div class="cnblogs_Highlighter">
<pre class="brush:html;gutter:true;">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset="GBK"&gt;
&lt;script&gt;
	console.log(encodeURIComponent("你好")); //%E6%B5%A3%E7%8A%B2%E3%82%BD
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
	&lt;p&gt;hello&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
</div>
<p>什么，输出的是什么鬼！不着急，我们慢慢分析：<br />
encodeURIComponent认为需要encode的字符的编码是charset指定的编码，这里就是GBK，而encodeURIComponent需要的是UTF-8编码的字符，这样它才会进行encode，所以必须发生编码之间的转换，具体如下，<br />&ldquo;你好&rdquo;的UTF-8：E4 BD A0  E5 A5 BD<br />所以&ldquo;你好&rdquo;实际上是以上面的6字节存储在文件test.html里面（因为文件的实际编码是UTF-8）<br />但是charset指定的GBK是2字节编码（除128个ASCII外，都是2字节编码），所以它把E4 BD认为是1个GBK字符，尝试把它转为UTF-8，其中E4 BD在GBK中对应的是&ldquo;浣&rdquo;字，而这个字在UTF-8则是E6 B5 A3<br />由此问题解决！</p>
<p>结论：如果网页文件的文件编码是UTF-8，而charset不小心指定成了其他的编码，那么会发生编码转换，第一次是将原本以UTF-8编码保存的字符当作charset指定的字符来读取，然后再把它转为UTF-8编码。</p>
<p>再来看一个更加离奇的情况，现在有个test2.html文件，它的文件编码是GBK，代码如下：</p>
<div class="cnblogs_Highlighter">
<pre class="brush:html;gutter:true;">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;script&gt;
	console.log(encodeURIComponent("你")); //%EF%BF%BD%EF%BF%BD
	console.log(encodeURIComponent("你你")); //%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD
	console.log(encodeURIComponent("你你你")); //%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
	&lt;p&gt;hello&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
</div>
<p>&ldquo;你&rdquo;的GBK编码是C4E3，UTF-8的EFBFDB表示这些字节信息无法转为UTF-8对应的字符，现在我们来分析这个异常情况出现的本质原因：</p>
<p>C4的二进制是1100 0100，查看UTF-8编码格式转换表（百度百科的UTF-8词条内就有这个表格），确实存在以110开头的格式，以110开头的字节会和它的下个字节组合为一个字符，而下个E3的二进制是11100 011，而UTF-8第二个字节开始都是10开始，显然这时不匹配了，也就是说C4E3这个编码是非法的UTF-8编码，那么就会返回EFBFDB，由此问题解决。</p>
<p>&nbsp;对于文件本身是GBK编码（或者其他非UTF-8编码），且charset指定的编码不是文件实际的编码，那么这个方法会出现很多意料之外的行为，再比如，如下代码：</p>
<div class="cnblogs_Highlighter">
<pre class="brush:html;gutter:true;">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;script&gt;
	console.log(encodeURIComponent("小")); //%D0%A1
	console.log(encodeURIComponent("小小")); //%D0%A1%D0%A1
	console.log(encodeURIComponent("小小小")); //%D0%A1%D0%A1%D0%A1
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
	&lt;p&gt;hello&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
</div>
<p>&ldquo;小&rdquo;的GBK编码是D0A1，同理，D0的二进制是1101 0000，也存在以110开头的UTF-8编码，下个A1的二进制是1010 0001，和上个&ldquo;你&rdquo;字不同，这个确实是符合UTF-8第二字节均以10开头的标准，那么这个字符是可以转为UTF-8的，由此可以正常输出。</p>
<p>最后再来看一个案例，文件依旧是GBK编码，代码如下：</p>
<div class="cnblogs_Highlighter">
<pre class="brush:html;gutter:true;">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;script&gt;
	console.log(encodeURIComponent("高")); //%EF%BF%BD%EF%BF%BD
	console.log(encodeURIComponent("高高")); //%EF%BF%BD%DF%B8%EF%BF%BD
	console.log(encodeURIComponent("高高高")); //%EF%BF%BD%DF%B8%DF%B8%EF%BF%BD
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
	&lt;p&gt;hello&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
</div>
<p>&ldquo;高&rdquo;的GBK编码是B8DF，而B8的二进制是1011 1000，呀，这个字节对于不了任何UTF-8起始字节，随即返回EFBFBD编码，示意这个字符无法对应（转换）为UTF-8编码，继续看下个DF的二进制，它是1101 1111，110可以对应，而UTF-8中起始字节是110会和它的下个字节组合为一个字符，对于只有一个&ldquo;高&rdquo;来说，没有下个字符了，单个的起始字符是不对应任何的UTF-8编码，随即也输出EFBFBD，这就是console.log第一行输出的结果，来看两个&ldquo;高&rdquo;，刚才讲到DF没有下个字符了，所以出错，现在有了第二个字符，是B8，那么就能组合了，因为B0的二进制以10开头是符合的，剩下的字节同理啦。</p>
<p>总结：通常来说，网页都采用UTF-8编码，即文件编码和charset指定的编码要相同，enencodeURIComponent才能封装和解析成功。</p>
<p>其实，只要文件编码和给出的charset编码相同，enencodeURIComponent就能正常工作，输出为UTF-8字符序列。</p>]]></description></item><item><title>gVim设置默认主题和字体（图文详细版）</title><link>http://www.cnblogs.com/ryzz/archive/2020/03/23/12554617.html</link><dc:creator>RYZZ</dc:creator><author>RYZZ</author><pubDate>Mon, 23 Mar 2020 12:01:00 GMT</pubDate><guid>http://www.cnblogs.com/ryzz/archive/2020/03/23/12554617.html</guid><description><![CDATA[<p>对于平时主力生产环境是Windows的学生党来说，可以通过gVim（Vim-gnome，是Vim的跨平台图形化版本）来学习Vim是很不错的一个选择，因为Vim有很多记忆性的命令，如果一段时间不使用Vim，一旦再次回到Linux操作Vim，就会很陌生。</p>
<p>默认的gVim配色是亮白色，字号也较小，如下，</p>
<p><img src="https://img2020.cnblogs.com/blog/1326234/202003/1326234-20200323184111008-726668332.png" alt="" width="328" height="214" /></p>
<p>在设置主题之前，我们需要先知道有哪些主题，有两种方式查看，</p>
<p>第一种：通过gVim菜单的【编辑】-&gt;【配色方案】查看，如果你直接选择，那么这个主题只对当前的gVim实例生效，重启gVim之后依旧是亮白色的主题，这个和直接在末行模式输入":colorscheme themeName"相同，如果只是输入":colorscheme"则显示当前的主题/配色方案。</p>
<p>第二种：去gVim安装目录，进入【Vim】-&gt;【vim80】-&gt;【colors】，其中【vim80】的80表示当前gVim的版本，这里可以看出我的版本是8.0，在【colors】目录下又很多.vim类型的文件，这些都是gVim的主题文件。</p>
<p><img src="https://img2020.cnblogs.com/blog/1326234/202003/1326234-20200323184650147-1112966996.png" alt="" width="454" height="163" /></p>
<p>我们根据上面任意一种方法选择一个自己喜欢的主题，然后打开gVim的配置文件（在Linux下，Vim的用户配置文件是~/.vimrc，而在Windows下，gVim的配置文件是其安装目录下的_vimrc），如下图，</p>
<p><img src="https://img2020.cnblogs.com/blog/1326234/202003/1326234-20200323190031058-446837430.png" alt="" width="467" height="124" /></p>
<p>我们使用记事本或其他编辑器（如Notepad++）打开这个文件，在下图中的位置添加指令，</p>
<p><img src="https://img2020.cnblogs.com/blog/1326234/202003/1326234-20200323190900639-296165314.png" alt="" width="432" height="192" /></p>
<p>在上图中，我选择了"evening"这款夜间主题，然后保存这个文件，重启gVim，可以看见默认的主题已经改变，如下图，</p>
<p><img src="https://img2020.cnblogs.com/blog/1326234/202003/1326234-20200323191149254-542373240.png" alt="" width="383" height="169" /></p>
<p>这时在末行模式输入":colorscheme"，显示"evening"，说明当前主题是夜间主题，现在我们再来设置默认字体和字号，类似的，我们可以先查看一下现在有哪些字体，也有两种方法，</p>
<p>1.gVim中的菜单栏中的【编辑】-&gt;【选择字体】，可以看到当前系统已经安装的字体，也可以设置字号和字样（常规、粗体、斜体、粗斜体），同时也能看到当前默认的字体（下图中蓝色选择的"Fixedsys"就是当前默认字体，另外一种查看当前字体的方法是在末行模式输入"set guifont"），如果在这里设置字体，依旧只对当前这个gVim实例生效，不是永久的。</p>
<p><img src="https://img2020.cnblogs.com/blog/1326234/202003/1326234-20200323192132945-2125213825.png" alt="" width="388" height="183" /></p>
<p>2.去Windows的控制面板中搜索"字体"，查看系统已经安装的全部字体。</p>
<p>现在开始设置我们默认的字体和字号，由于不同版本或者不同平台的Vim对字体设置的选项存在些许差异（在网络上，我已经看到了很多不同设置字体的命令），所以，我们需要找到一个对当前gVim能识别的格式，所以我们再次回到【编辑】-&gt;【选择字体】，然后我们选择适合自己的字体和字号，然后确定，回到gVim窗口，在末行模式输入"set guifont"查看当前的字体配置，如下图，</p>
<p><img src="https://img2020.cnblogs.com/blog/1326234/202003/1326234-20200323193808978-631626573.png" alt="" width="757" height="41" /></p>
<p>可以看出我刚刚选择的字体名是Consolas，字号是15，字体编码是ANSI（由于我的Windows是简体中文，所以这里ANSI也就是GBK），最后一个字段的"qDRAFT"不清楚具体含义，然后我们把这些信息复制到gVim的默认配置文件_vimrc中，如下图，</p>
<p><img src="https://img2020.cnblogs.com/blog/1326234/202003/1326234-20200323194226867-1681693141.png" alt="" width="458" height="159" /></p>
<p>重启gVim后，就完成配置默认的字体和字号啦，如下图，</p>
<p><img src="https://img2020.cnblogs.com/blog/1326234/202003/1326234-20200323194306403-1567103139.png" alt="" width="403" height="185" /></p>
<p>&nbsp;</p>
<p>补充：</p>
<p>可以直接通过gVim菜单栏中的选项打开配置文件_vimrc，单击【编辑】-&gt;【启动设定】，就会在当前gVim窗口自动打开配置文件_vimrc，然后就可以愉快的修改配置信息了。</p>
<p>&nbsp;</p>
<p>其他的一些常用选项：（同样写在"_vimrc"中，这些选项会不定期更新）</p>
<table border="0" align="left">
<tbody>
<tr>
<td>选项名称：</td>
<td>选项指令：</td>
</tr>
<tr>
<td>显示行号，gVim默认关闭</td>
<td>set number</td>
</tr>
<tr>
<td>禁止备份文件，gVim会对修改的文件做备份，即在文件名后加波浪线，如test.html~，gVim默认开启</td>
<td>set&nbsp;nobackup</td>
</tr>
<tr>
<td>禁止产生交换文件(*.swp)，Vim的交换文件用于当Vim被非正常关闭时，用于恢复原先的文件数据（不建议禁止），gVim默认开启</td>
<td>set noswapfile</td>
</tr>
<tr>
<td>禁止产生撤销操作文件，un~后缀的文件用于保存文件的操作，方便下次Vim打开时能够进行撤销(undo)，gVim默认开启</td>
<td>set noundofile</td>
</tr>
<tr>
<td>禁止匹配项高亮</td>
<td>set nohlsearch</td>
</tr>
<tr>
<td>开启匹配项高亮</td>
<td>set hlsearch</td>
</tr>
<tr>
<td>设置自动缩进</td>
<td>set autoindent</td>
</tr>
</tbody>
</table>]]></description></item><item><title>对C99新增的_Bool类型的理解</title><link>http://www.cnblogs.com/ryzz/archive/2020/02/18/12325813.html</link><dc:creator>RYZZ</dc:creator><author>RYZZ</author><pubDate>Tue, 18 Feb 2020 05:12:00 GMT</pubDate><guid>http://www.cnblogs.com/ryzz/archive/2020/02/18/12325813.html</guid><description><![CDATA[<p>传统（指C90）C标准中是没有布尔类型的，对于C来说，非0即是真，而0即是假，这里0不仅包括整型家族的0，还包括浮点家族的0.0，有如下代码，</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">if</span> (<span style="color: #800080;">0.0</span><span style="color: #000000;">){
</span><span style="color: #008080;">2</span>         puts(<span style="color: #800000;">"</span><span style="color: #800000;">true</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">3</span> }<span style="color: #0000ff;">else</span><span style="color: #000000;">{
</span><span style="color: #008080;">4</span>         puts(<span style="color: #800000;">"</span><span style="color: #800000;">false</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">5</span> }</pre>
</div>
<p>输出的结果是：false</p>
<p>在C中，<strong><span style="color: #ff0000;">一直使用int类型表示真假值（布尔值）</span></strong><span style="color: #ff0000;"><span style="color: #000000;">，所以，任何条件表达式的结果要么是1（真），要么是0（假），</span></span>在C99标准中，引入了新的类型_Bool，即布尔类型，布尔类型的变量只能存储1或0的整型值，把任何假值（整型和浮点的零值）赋值给_Bool，该变量会被设为0，否则被设为1，为此，C99还提供了stdbool.h头文件，该文件让bool成为_Bool的别名，同时宏定义了true和false，分别是1和0的字面量，这让写出的代码能与C++兼容，因为C++把true和false视作关键字，下面对_Bool类型的一些测试代码，</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> #include &lt;stdio.h&gt;
<span style="color: #008080;"> 2</span> #include &lt;stdbool.h&gt;
<span style="color: #008080;"> 3</span> 
<span style="color: #008080;"> 4</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
</span><span style="color: #008080;"> 5</span>     _Bool flag=<span style="color: #0000ff;">true</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 6</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">sizeof flag = %d\n</span><span style="color: #800000;">"</span>,<span style="color: #0000ff;">sizeof</span><span style="color: #000000;"> flag);
</span><span style="color: #008080;"> 7</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">type of flag is %s\n</span><span style="color: #800000;">"</span>,_Generic(flag,<span style="color: #0000ff;">int</span>:<span style="color: #800000;">"</span><span style="color: #800000;">int</span><span style="color: #800000;">"</span>,_Bool:<span style="color: #800000;">"</span><span style="color: #800000;">_Bool</span><span style="color: #800000;">"</span>,<span style="color: #0000ff;">default</span>:<span style="color: #800000;">"</span><span style="color: #800000;">default</span><span style="color: #800000;">"</span><span style="color: #000000;">));
</span><span style="color: #008080;"> 8</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">the conditional expression of C language is %s\n</span><span style="color: #800000;">"</span>,_Generic(<span style="color: #800080;">2</span>&gt;<span style="color: #800080;">3</span>,<span style="color: #0000ff;">int</span>:<span style="color: #800000;">"</span><span style="color: #800000;">int</span><span style="color: #800000;">"</span>,_Bool:<span style="color: #800000;">"</span><span style="color: #800000;">_Bool</span><span style="color: #800000;">"</span>,<span style="color: #0000ff;">default</span>:<span style="color: #800000;">"</span><span style="color: #800000;">default</span><span style="color: #800000;">"</span><span style="color: #000000;">));
</span><span style="color: #008080;"> 9</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">the conditional expression of C language is %s\n</span><span style="color: #800000;">"</span>,_Generic(flag==<span style="color: #0000ff;">false</span>,<span style="color: #0000ff;">int</span>:<span style="color: #800000;">"</span><span style="color: #800000;">int</span><span style="color: #800000;">"</span>,_Bool:<span style="color: #800000;">"</span><span style="color: #800000;">_Bool</span><span style="color: #800000;">"</span>,<span style="color: #0000ff;">default</span>:<span style="color: #800000;">"</span><span style="color: #800000;">default</span><span style="color: #800000;">"</span><span style="color: #000000;">));
</span><span style="color: #008080;">10</span>     <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">11</span> }</pre>
</div>
<p>输出结果：</p>
<p>sizeof flag = 1<br />type of flag is _Bool<br />the conditional expression of C language is int<br />the conditional expression of C language is int</p>
<p><em>需要注意：以上代码使用了C11的泛型表达式_Generic（简单地说，它接受若干参数，第一个参数必须是一个符合C语言的表达式，然后会根据提供的这个表达式的类型去匹配后面给出的类型，最后，整个_Generic表达式的值就是匹配成功项冒号后面的值），所以需要对编译器开启-std=c11标记。</em></p>
<p>分析输出的3行结果的含义：</p>
<p>1.这说明了_Bool类型占用1字节，对于布尔类型，理论上只需要占1bit的空间就足够了，但是大多数的编译器在实际实现上都采用1字节，因为在现在的计算机内存性能下没必要减少那7bit的空间</p>
<p>2.很明显，flag的类型就是_Bool</p>
<p>3.<strong>这点就很重要了！上面也提及过，在C语言中，一直只用int类型作为条件表达式的值，条件是真则表达式值就是1，条件是假则表达式值就是0</strong></p>
<p>4.验证了上面的第3点，即便是_Bool类型的变量在做逻辑运算时，返回的结果还是int类型</p>
<p>所以，_Bool并没有改变C的规则，对于所有的条件表达式仍然以1表示真，以0表示假，它的加入，只是使得让编写人员有一种更直观的类型去保存那些期望是布尔值的变量。</p>
<p>您应该这样使用_Bool类型：对_Bool类型的赋值应该用条件表达式的值或返回类型是_Bool类型的函数。</p>
<p>个人观点，新的_Bool可以理解为只能保存0或1的unsigned char类型，。</p>
<p>&nbsp;</p>
<p>（上文是本人对C99标准新类型_Bool的理解，错误或不严谨之处恳请指出。）</p>]]></description></item><item><title>遍历以邻接矩阵存储的有向图</title><link>http://www.cnblogs.com/ryzz/archive/2020/02/13/12302924.html</link><dc:creator>RYZZ</dc:creator><author>RYZZ</author><pubDate>Thu, 13 Feb 2020 03:41:00 GMT</pubDate><guid>http://www.cnblogs.com/ryzz/archive/2020/02/13/12302924.html</guid><description><![CDATA[<p>==主题：遍历以邻接矩阵存储的有向图==</p>
<p>给出如下的图：<br />  A<br /> / \<br />B---C<br /> \ /<br />  D （这个图的边集={&lt;A,B&gt;,&lt;A,C&gt;,&lt;B,C&gt;,&lt;B,D&gt;,&lt;C,B&gt;,&lt;C,D&gt;,&lt;D,C&gt;}，可以看出这是一张稠密图）<br />将这张有向图转为邻接矩阵（出边）如下：<br />  A B C D<br />A 0 9 2 X<br />B X 0 6 3<br />C X 7 0 1<br />D X X 1 0（表中的X表示正无穷）<br />有向图的邻接矩阵每行存储的是该行所代表的顶点直连的顶点有哪些，其中0表示顶点自身，X表示没有直连，其他数字表示这条直连边的权重，<br />假设起点是A点，终点是D点，回答下列问题：</p>
<p>1.从起点出发，遍历所有的顶点，得到所有的路径，并按遍历顺序打印出这些路径以及对应的开销（路径中每条边权重的和）：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> #include &lt;stdio.h&gt;
<span style="color: #008080;"> 2</span> <span style="color: #0000ff;">#define</span> X 9999 <span style="color: #008000;">//</span><span style="color: #008000;">假设X表示无穷</span>
<span style="color: #008080;"> 3</span> 
<span style="color: #008080;"> 4</span> <span style="color: #0000ff;">int</span> book[<span style="color: #800080;">4</span><span style="color: #000000;">];
</span><span style="color: #008080;"> 5</span> <span style="color: #0000ff;">char</span> vertex[<span style="color: #800080;">4</span>] = {<span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">B</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">C</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">D</span><span style="color: #800000;">'</span><span style="color: #000000;">};
</span><span style="color: #008080;"> 6</span> <span style="color: #0000ff;">int</span> edge[<span style="color: #800080;">4</span>][<span style="color: #800080;">4</span>] =<span style="color: #000000;"> {
</span><span style="color: #008080;"> 7</span>     {<span style="color: #800080;">0</span>, <span style="color: #800080;">9</span>, <span style="color: #800080;">2</span><span style="color: #000000;">, X},
</span><span style="color: #008080;"> 8</span>     {X, <span style="color: #800080;">0</span>, <span style="color: #800080;">6</span>, <span style="color: #800080;">3</span><span style="color: #000000;">},
</span><span style="color: #008080;"> 9</span>     {X, <span style="color: #800080;">7</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">1</span><span style="color: #000000;">},
</span><span style="color: #008080;">10</span>     {X, X, <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">}};
</span><span style="color: #008080;">11</span> <span style="color: #0000ff;">char</span> record[<span style="color: #800080;">4</span>];  <span style="color: #008000;">//</span><span style="color: #008000;">用于记录走过的顶点，已走过列表</span>
<span style="color: #008080;">12</span> <span style="color: #0000ff;">int</span> record_num;  <span style="color: #008000;">//</span><span style="color: #008000;">记录已走过列表的长度</span>
<span style="color: #008080;">13</span> <span style="color: #0000ff;">int</span> firstGoback; <span style="color: #008000;">//</span><span style="color: #008000;">记录继上次递归后是否发生了第一次回溯，0表示没有，1表示发生
</span><span style="color: #008080;">14</span> <span style="color: #008000;">//</span><span style="color: #008000;">某次递归发生了第一次回溯，说明DFS找到了一条路径</span>
<span style="color: #008080;">15</span> <span style="color: #0000ff;">int</span> path_num;    <span style="color: #008000;">//</span><span style="color: #008000;">保存找到的路径个数</span>
<span style="color: #008080;">16</span> <span style="color: #0000ff;">int</span> totalWeight; <span style="color: #008000;">//</span><span style="color: #008000;">保存每条路经的总开销</span>
<span style="color: #008080;">17</span> 
<span style="color: #008080;">18</span> <span style="color: #0000ff;">void</span> dfs(<span style="color: #0000ff;">int</span> now, <span style="color: #0000ff;">int</span><span style="color: #000000;"> step)
</span><span style="color: #008080;">19</span> <span style="color: #000000;">{
</span><span style="color: #008080;">20</span>   <span style="color: #0000ff;">int</span><span style="color: #000000;"> i, j;
</span><span style="color: #008080;">21</span>   <span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">4</span>; i++<span style="color: #000000;">)
</span><span style="color: #008080;">22</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">23</span>     <span style="color: #0000ff;">if</span> (edge[now][i] != X &amp;&amp; edge[now][i] != <span style="color: #800080;">0</span> &amp;&amp; book[i] != <span style="color: #800080;">1</span><span style="color: #000000;">)
</span><span style="color: #008080;">24</span>     { <span style="color: #008000;">//</span><span style="color: #008000;">存在直连的顶点，且这个顶点不是自身，且这个顶点还没走过
</span><span style="color: #008080;">25</span>       <span style="color: #008000;">//</span><span style="color: #008000;">即将从当前顶点vertex[now]访问下一个顶点vertex[i]</span>
<span style="color: #008080;">26</span>       book[i] = <span style="color: #800080;">1</span>;                  <span style="color: #008000;">//</span><span style="color: #008000;">标记这个顶点，因为下一步就要去这个顶点</span>
<span style="color: #008080;">27</span>       record[step + <span style="color: #800080;">1</span>] = vertex[i]; <span style="color: #008000;">//</span><span style="color: #008000;">把这个顶点记录到已走过列表</span>
<span style="color: #008080;">28</span>       record_num++;                 <span style="color: #008000;">//</span><span style="color: #008000;">对已走过列表长度+1</span>
<span style="color: #008080;">29</span>       totalWeight += edge[now][i];  <span style="color: #008000;">//</span><span style="color: #008000;">这条路径的总开销增加，增加的大小是当前顶点到下个顶点的边的权重</span>
<span style="color: #008080;">30</span>       firstGoback = <span style="color: #800080;">0</span>;              <span style="color: #008000;">//</span><span style="color: #008000;">要进入递归，置0</span>
<span style="color: #008080;">31</span>       dfs(i, step + <span style="color: #800080;">1</span>);             <span style="color: #008000;">//</span><span style="color: #008000;">对这个顶点继续DFS</span>
<span style="color: #008080;">32</span>       <span style="color: #0000ff;">if</span> (firstGoback == <span style="color: #800080;">0</span><span style="color: #000000;">)
</span><span style="color: #008080;">33</span> <span style="color: #000000;">      {
</span><span style="color: #008080;">34</span>         <span style="color: #008000;">//</span><span style="color: #008000;">等于0说明之前一直是递归，而现在发生了回溯，意味着这次回溯是继上次递归的第一次回溯
</span><span style="color: #008080;">35</span>         <span style="color: #008000;">//</span><span style="color: #008000;">打印上次递归找到的所有顶点，然后把firstGoback置1，让之后的回溯不是第一次回溯
</span><span style="color: #008080;">36</span>         <span style="color: #008000;">//</span><span style="color: #008000;">直到某次又发生递归，意味着又发现了新顶点，也意味着又发现了一条路径，再把firstGoback置0
</span><span style="color: #008080;">37</span>         <span style="color: #008000;">//</span><span style="color: #008000;">如此反复</span>
<span style="color: #008080;">38</span>         printf(<span style="color: #800000;">"</span><span style="color: #800000;">Path %d: </span><span style="color: #800000;">"</span>, ++<span style="color: #000000;">path_num);
</span><span style="color: #008080;">39</span>         <span style="color: #0000ff;">for</span> (j = <span style="color: #800080;">0</span>; j &lt; record_num; j++<span style="color: #000000;">)
</span><span style="color: #008080;">40</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">41</span>           printf(<span style="color: #800000;">"</span><span style="color: #800000;">%c </span><span style="color: #800000;">"</span><span style="color: #000000;">, record[j]);
</span><span style="color: #008080;">42</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">43</span>         printf(<span style="color: #800000;">"</span><span style="color: #800000;">, and the total cost is %d</span><span style="color: #800000;">"</span><span style="color: #000000;">, totalWeight);
</span><span style="color: #008080;">44</span>         printf(<span style="color: #800000;">"</span><span style="color: #800000;">\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">45</span>         firstGoback = <span style="color: #800080;">1</span>; <span style="color: #008000;">//</span><span style="color: #008000;">置1是为了当发生连续回溯时，使第二次及之后的回溯认为自己不是第一次回溯</span>
<span style="color: #008080;">46</span> <span style="color: #000000;">      }
</span><span style="color: #008080;">47</span>       book[i] = <span style="color: #800080;">0</span>;                 <span style="color: #008000;">//</span><span style="color: #008000;">取消标记</span>
<span style="color: #008080;">48</span>       record_num--;                <span style="color: #008000;">//</span><span style="color: #008000;">已走过顶点被取消标记，说明这个顶点现在没走过了，那么已走过列表长度也要-1</span>
<span style="color: #008080;">49</span>       totalWeight -= edge[now][i]; <span style="color: #008000;">//</span><span style="color: #008000;">已走过顶点被取消标记，说明这个点已经被移出路径，那么路径的总开销也要减去被移除的边的权重</span>
<span style="color: #008080;">50</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">51</span> <span style="color: #000000;">  }
</span><span style="color: #008080;">52</span> <span style="color: #000000;">}
</span><span style="color: #008080;">53</span> 
<span style="color: #008080;">54</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
</span><span style="color: #008080;">55</span> <span style="color: #000000;">{
</span><span style="color: #008080;">56</span>   book[<span style="color: #800080;">0</span>] = <span style="color: #800080;">1</span>;     <span style="color: #008000;">//</span><span style="color: #008000;">起点是A，所以A已经走过，将它标记</span>
<span style="color: #008080;">57</span>   record[<span style="color: #800080;">0</span>] = <span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span>; <span style="color: #008000;">//</span><span style="color: #008000;">起点其走过，把它加入已走过列表</span>
<span style="color: #008080;">58</span>   record_num = <span style="color: #800080;">1</span>;  <span style="color: #008000;">//</span><span style="color: #008000;">已走过列表+1</span>
<span style="color: #008080;">59</span>   dfs(<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>);       <span style="color: #008000;">//</span><span style="color: #008000;">从起点开始遍历</span>
<span style="color: #008080;">60</span> 
<span style="color: #008080;">61</span>   <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">62</span> }</pre>
</div>
<p>输出：<br />Path 1: A B C D , and the total cost is 16<br />Path 2: A B D C , and the total cost is 13<br />Path 3: A C B D , and the total cost is 12<br />Path 4: A C D , and the total cost is 3</p>
<p>Process returned 0 (0x0)   execution time : 0.590 s<br />Press any key to continue.</p>
<p>PS：如果单纯是为了遍历，则不需要输出每次遍历得到的路径，删去那些用于打印路径相关的代码，核心代码是很精简的。</p>
<p>2.从起点出发，要求下一步达到的顶点是C，然后遍历剩下的顶点，打印出所有的路径：<br />只需修改main函数如下：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> book[<span style="color: #800080;">0</span>] = <span style="color: #800080;">1</span>;     <span style="color: #008000;">//</span><span style="color: #008000;">起点是A，所以A已经走过，将它标记</span>
<span style="color: #008080;">2</span> record[<span style="color: #800080;">0</span>] = <span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span>; <span style="color: #008000;">//</span><span style="color: #008000;">起点其走过，把它加入已走过列表</span>
<span style="color: #008080;">3</span> book[<span style="color: #800080;">2</span>] = <span style="color: #800080;">1</span>;     <span style="color: #008000;">//</span><span style="color: #008000;">相同</span>
<span style="color: #008080;">4</span> record[<span style="color: #800080;">1</span>] = <span style="color: #800000;">'</span><span style="color: #800000;">C</span><span style="color: #800000;">'</span>; <span style="color: #008000;">//</span><span style="color: #008000;">相同</span>
<span style="color: #008080;">5</span> record_num = <span style="color: #800080;">2</span>;  <span style="color: #008000;">//</span><span style="color: #008000;">已走过列表+2</span>
<span style="color: #008080;">6</span> totalWeight = <span style="color: #800080;">2</span>; <span style="color: #008000;">//</span><span style="color: #008000;">边&lt;A,C&gt;的权重是2</span>
<span style="color: #008080;">7</span> dfs(<span style="color: #800080;">2</span>, <span style="color: #800080;">1</span>);       <span style="color: #008000;">//</span><span style="color: #008000;">从起点开始遍历，step等于1是因为A点到C点，规定，每次从一个顶点到另一个顶点，step增1，位于起点时，step等于0</span></pre>
</div>
<p>输出：<br />Path 1: A C B D , and the total cost is 12<br />Path 2: A C D , and the total cost is 3</p>
<p>Process returned 0 (0x0)   execution time : 0.359 s<br />Press any key to continue.</p>
<p>3.从起点出发，要求下一步达到的顶点是C，然后遍历剩下的顶点（只遍历一次），打印出遍历的路径：<br />要实现只遍历一次，只需要当回溯一旦发生，就让它一直回溯到开始，然后结束函数，如下，</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> #include &lt;stdio.h&gt;
<span style="color: #008080;"> 2</span> <span style="color: #0000ff;">#define</span> X 9999 <span style="color: #008000;">//</span><span style="color: #008000;">假设X表示无穷</span>
<span style="color: #008080;"> 3</span> 
<span style="color: #008080;"> 4</span> <span style="color: #0000ff;">int</span> book[<span style="color: #800080;">4</span><span style="color: #000000;">];
</span><span style="color: #008080;"> 5</span> <span style="color: #0000ff;">char</span> vertex[<span style="color: #800080;">4</span>] = {<span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">B</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">C</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">D</span><span style="color: #800000;">'</span><span style="color: #000000;">};
</span><span style="color: #008080;"> 6</span> <span style="color: #0000ff;">int</span> edge[<span style="color: #800080;">4</span>][<span style="color: #800080;">4</span>] =<span style="color: #000000;"> {
</span><span style="color: #008080;"> 7</span>     {<span style="color: #800080;">0</span>, <span style="color: #800080;">9</span>, <span style="color: #800080;">2</span><span style="color: #000000;">, X},
</span><span style="color: #008080;"> 8</span>     {X, <span style="color: #800080;">0</span>, <span style="color: #800080;">6</span>, <span style="color: #800080;">3</span><span style="color: #000000;">},
</span><span style="color: #008080;"> 9</span>     {X, <span style="color: #800080;">7</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">1</span><span style="color: #000000;">},
</span><span style="color: #008080;">10</span>     {X, X, <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">}};
</span><span style="color: #008080;">11</span> <span style="color: #0000ff;">char</span> record[<span style="color: #800080;">4</span>];  <span style="color: #008000;">//</span><span style="color: #008000;">用于记录走过的顶点，已走过列表</span>
<span style="color: #008080;">12</span> <span style="color: #0000ff;">int</span> record_num;  <span style="color: #008000;">//</span><span style="color: #008000;">记录已走过列表的长度</span>
<span style="color: #008080;">13</span> <span style="color: #0000ff;">int</span> goback;      <span style="color: #008000;">//</span><span style="color: #008000;">标识是否已经发生了回溯，0表示没有，1表示发生</span>
<span style="color: #008080;">14</span> <span style="color: #0000ff;">int</span> path_num;    <span style="color: #008000;">//</span><span style="color: #008000;">保存找到的路径个数</span>
<span style="color: #008080;">15</span> <span style="color: #0000ff;">int</span> totalWeight; <span style="color: #008000;">//</span><span style="color: #008000;">保存每条路经的总开销</span>
<span style="color: #008080;">16</span> 
<span style="color: #008080;">17</span> <span style="color: #0000ff;">void</span> dfs(<span style="color: #0000ff;">int</span> now, <span style="color: #0000ff;">int</span><span style="color: #000000;"> step)
</span><span style="color: #008080;">18</span> <span style="color: #000000;">{
</span><span style="color: #008080;">19</span>   <span style="color: #0000ff;">int</span><span style="color: #000000;"> i, j;
</span><span style="color: #008080;">20</span>   <span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">4</span>; i++<span style="color: #000000;">)
</span><span style="color: #008080;">21</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">22</span>     <span style="color: #0000ff;">if</span> (edge[now][i] != X &amp;&amp; edge[now][i] != <span style="color: #800080;">0</span> &amp;&amp; book[i] != <span style="color: #800080;">1</span> &amp;&amp; goback != <span style="color: #800080;">1</span><span style="color: #000000;">)
</span><span style="color: #008080;">23</span>     { <span style="color: #008000;">//</span><span style="color: #008000;">存在直连的顶点，且这个顶点不是自身，且这个顶点还没走过，且还没发生过回溯
</span><span style="color: #008080;">24</span>       <span style="color: #008000;">//</span><span style="color: #008000;">即将从当前顶点vertex[now]访问下一个顶点vertex[i]</span>
<span style="color: #008080;">25</span>       book[i] = <span style="color: #800080;">1</span>;                  <span style="color: #008000;">//</span><span style="color: #008000;">标记这个顶点，因为下一步就要去这个顶点</span>
<span style="color: #008080;">26</span>       record[step + <span style="color: #800080;">1</span>] = vertex[i]; <span style="color: #008000;">//</span><span style="color: #008000;">把这个顶点记录到已走过列表</span>
<span style="color: #008080;">27</span>       record_num++;                 <span style="color: #008000;">//</span><span style="color: #008000;">对已走过列表长度+1</span>
<span style="color: #008080;">28</span>       totalWeight += edge[now][i];  <span style="color: #008000;">//</span><span style="color: #008000;">这条路径的总开销增加，增加的大小是当前顶点到下个顶点的边的权重</span>
<span style="color: #008080;">29</span>       goback = <span style="color: #800080;">0</span>;                   <span style="color: #008000;">//</span><span style="color: #008000;">要进入递归，置0</span>
<span style="color: #008080;">30</span>       dfs(i, step + <span style="color: #800080;">1</span>);             <span style="color: #008000;">//</span><span style="color: #008000;">对这个顶点继续DFS</span>
<span style="color: #008080;">31</span>       <span style="color: #0000ff;">if</span> (goback == <span style="color: #800080;">0</span><span style="color: #000000;">)
</span><span style="color: #008080;">32</span>       {             <span style="color: #008000;">//</span><span style="color: #008000;">发生了回溯，要判断是不是首次回溯，如果goback等于0，说明这次是首次回溯</span>
<span style="color: #008080;">33</span>         goback = <span style="color: #800080;">1</span>; <span style="color: #008000;">//</span><span style="color: #008000;">发生了首次回溯，就让这个回溯一直进行下去，直到回到递归的首次调用</span>
<span style="color: #008080;">34</span>         printf(<span style="color: #800000;">"</span><span style="color: #800000;">Path %d: </span><span style="color: #800000;">"</span>, ++<span style="color: #000000;">path_num);
</span><span style="color: #008080;">35</span>         <span style="color: #0000ff;">for</span> (j = <span style="color: #800080;">0</span>; j &lt; record_num; j++<span style="color: #000000;">)
</span><span style="color: #008080;">36</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">37</span>           printf(<span style="color: #800000;">"</span><span style="color: #800000;">%c </span><span style="color: #800000;">"</span><span style="color: #000000;">, record[j]);
</span><span style="color: #008080;">38</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">39</span>         printf(<span style="color: #800000;">"</span><span style="color: #800000;">, and the total cost is %d</span><span style="color: #800000;">"</span><span style="color: #000000;">, totalWeight);
</span><span style="color: #008080;">40</span>         printf(<span style="color: #800000;">"</span><span style="color: #800000;">\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">41</span> <span style="color: #000000;">      }
</span><span style="color: #008080;">42</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">43</span> <span style="color: #000000;">  }
</span><span style="color: #008080;">44</span> <span style="color: #000000;">}
</span><span style="color: #008080;">45</span> 
<span style="color: #008080;">46</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
</span><span style="color: #008080;">47</span> <span style="color: #000000;">{
</span><span style="color: #008080;">48</span>   book[<span style="color: #800080;">0</span>] = <span style="color: #800080;">1</span>;     <span style="color: #008000;">//</span><span style="color: #008000;">起点是A，所以A已经走过，将它标记</span>
<span style="color: #008080;">49</span>   record[<span style="color: #800080;">0</span>] = <span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span>; <span style="color: #008000;">//</span><span style="color: #008000;">起点其走过，把它加入已走过列表</span>
<span style="color: #008080;">50</span>   book[<span style="color: #800080;">2</span>] = <span style="color: #800080;">1</span>;     <span style="color: #008000;">//</span><span style="color: #008000;">相同</span>
<span style="color: #008080;">51</span>   record[<span style="color: #800080;">1</span>] = <span style="color: #800000;">'</span><span style="color: #800000;">C</span><span style="color: #800000;">'</span>; <span style="color: #008000;">//</span><span style="color: #008000;">相同</span>
<span style="color: #008080;">52</span>   record_num = <span style="color: #800080;">2</span>;  <span style="color: #008000;">//</span><span style="color: #008000;">已走过列表+2</span>
<span style="color: #008080;">53</span>   totalWeight = <span style="color: #800080;">2</span>; <span style="color: #008000;">//</span><span style="color: #008000;">边&lt;A,C&gt;的权重是2</span>
<span style="color: #008080;">54</span>   dfs(<span style="color: #800080;">2</span>, <span style="color: #800080;">1</span>);       <span style="color: #008000;">//</span><span style="color: #008000;">从起点开始遍历</span>
<span style="color: #008080;">55</span> 
<span style="color: #008080;">56</span>   <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">57</span> }</pre>
</div>
<p>输出：<br />Path 1: A C B D , and the total cost is 12</p>
<p>Process returned 0 (0x0)   execution time : 2.262 s<br />Press any key to continue.</p>
<p>4.打印从起点到终点的所有路径，并找出最短路径：<br />这道题比(1)要简单很多，虽然都是打印出所有路径，但是这道题的&ldquo;什么时候该打印已遍历的路径&rdquo;这个条件很显而易见的，就是当递归处于终点时（vertext[now]等于'D'时），就代表一次寻路完成，把这个路径打印出来即可，而(1)打印一条路径的条件是&ldquo;发生了继上次递归后的首次回溯&rdquo;，这需要一个变量来记录是否发生了首次回溯，本题的代码如下：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> #include &lt;stdio.h&gt;
<span style="color: #008080;"> 2</span> <span style="color: #0000ff;">#define</span> X 9999 <span style="color: #008000;">//</span><span style="color: #008000;">假设X表示无穷</span>
<span style="color: #008080;"> 3</span> 
<span style="color: #008080;"> 4</span> <span style="color: #0000ff;">int</span> book[<span style="color: #800080;">4</span><span style="color: #000000;">];
</span><span style="color: #008080;"> 5</span> <span style="color: #0000ff;">char</span> vertex[<span style="color: #800080;">4</span>] = {<span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">B</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">C</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">D</span><span style="color: #800000;">'</span><span style="color: #000000;">};
</span><span style="color: #008080;"> 6</span> <span style="color: #0000ff;">int</span> edge[<span style="color: #800080;">4</span>][<span style="color: #800080;">4</span>] =<span style="color: #000000;"> {
</span><span style="color: #008080;"> 7</span>     {<span style="color: #800080;">0</span>, <span style="color: #800080;">9</span>, <span style="color: #800080;">2</span><span style="color: #000000;">, X},
</span><span style="color: #008080;"> 8</span>     {X, <span style="color: #800080;">0</span>, <span style="color: #800080;">6</span>, <span style="color: #800080;">3</span><span style="color: #000000;">},
</span><span style="color: #008080;"> 9</span>     {X, <span style="color: #800080;">7</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">1</span><span style="color: #000000;">},
</span><span style="color: #008080;">10</span>     {X, X, <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">}};
</span><span style="color: #008080;">11</span> <span style="color: #0000ff;">char</span> record[<span style="color: #800080;">4</span>];         <span style="color: #008000;">//</span><span style="color: #008000;">用于记录走过的顶点，已走过列表</span>
<span style="color: #008080;">12</span> <span style="color: #0000ff;">int</span> record_num;         <span style="color: #008000;">//</span><span style="color: #008000;">记录已走过列表的长度</span>
<span style="color: #008080;">13</span> <span style="color: #0000ff;">int</span> path_num;           <span style="color: #008000;">//</span><span style="color: #008000;">保存找到的路径个数</span>
<span style="color: #008080;">14</span> <span style="color: #0000ff;">int</span> totalWeight;        <span style="color: #008000;">//</span><span style="color: #008000;">保存每条路经的总开销</span>
<span style="color: #008080;">15</span> <span style="color: #0000ff;">int</span> minTotalWeight = X; <span style="color: #008000;">//</span><span style="color: #008000;">保存路径的最小开销</span>
<span style="color: #008080;">16</span> 
<span style="color: #008080;">17</span> <span style="color: #0000ff;">void</span> dfs(<span style="color: #0000ff;">int</span> now, <span style="color: #0000ff;">int</span><span style="color: #000000;"> step)
</span><span style="color: #008080;">18</span> <span style="color: #000000;">{
</span><span style="color: #008080;">19</span>   <span style="color: #0000ff;">int</span><span style="color: #000000;"> i;
</span><span style="color: #008080;">20</span>   <span style="color: #0000ff;">if</span> (vertex[now] == <span style="color: #800000;">'</span><span style="color: #800000;">D</span><span style="color: #800000;">'</span><span style="color: #000000;">)
</span><span style="color: #008080;">21</span>   { <span style="color: #008000;">//</span><span style="color: #008000;">到了终点</span>
<span style="color: #008080;">22</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">Path %d: </span><span style="color: #800000;">"</span>, ++<span style="color: #000000;">path_num);
</span><span style="color: #008080;">23</span>     <span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>; i &lt; record_num; i++<span style="color: #000000;">)
</span><span style="color: #008080;">24</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">25</span>       printf(<span style="color: #800000;">"</span><span style="color: #800000;">%c </span><span style="color: #800000;">"</span><span style="color: #000000;">, record[i]);
</span><span style="color: #008080;">26</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">27</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">, in this case, the total cost is %d</span><span style="color: #800000;">"</span><span style="color: #000000;">, totalWeight);
</span><span style="color: #008080;">28</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">29</span>     <span style="color: #0000ff;">if</span> (minTotalWeight &gt;<span style="color: #000000;"> totalWeight)
</span><span style="color: #008080;">30</span>       minTotalWeight = totalWeight; <span style="color: #008000;">//</span><span style="color: #008000;">更新路径的最少开销</span>
<span style="color: #008080;">31</span>     <span style="color: #0000ff;">return</span><span style="color: #000000;">;
</span><span style="color: #008080;">32</span> <span style="color: #000000;">  }
</span><span style="color: #008080;">33</span>   <span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">4</span>; i++<span style="color: #000000;">)
</span><span style="color: #008080;">34</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">35</span>     <span style="color: #0000ff;">if</span> (edge[now][i] != X &amp;&amp; edge[now][i] != <span style="color: #800080;">0</span> &amp;&amp; book[i] != <span style="color: #800080;">1</span><span style="color: #000000;">)
</span><span style="color: #008080;">36</span>     { <span style="color: #008000;">//</span><span style="color: #008000;">存在直连的顶点，且这个顶点不是自身，且这个顶点还没走过
</span><span style="color: #008080;">37</span>       <span style="color: #008000;">//</span><span style="color: #008000;">即将从当前顶点vertex[now]访问下一个顶点vertex[i]</span>
<span style="color: #008080;">38</span>       book[i] = <span style="color: #800080;">1</span>;                  <span style="color: #008000;">//</span><span style="color: #008000;">标记这个顶点，因为下一步就要去这个顶点</span>
<span style="color: #008080;">39</span>       record[step + <span style="color: #800080;">1</span>] = vertex[i]; <span style="color: #008000;">//</span><span style="color: #008000;">把这个顶点记录到已走过列表</span>
<span style="color: #008080;">40</span>       record_num++;                 <span style="color: #008000;">//</span><span style="color: #008000;">对已走过列表长度+1</span>
<span style="color: #008080;">41</span>       totalWeight += edge[now][i];  <span style="color: #008000;">//</span><span style="color: #008000;">这条路径的总开销增加，增加的大小是当前顶点到下个顶点的边的权重</span>
<span style="color: #008080;">42</span>       dfs(i, step + <span style="color: #800080;">1</span>);             <span style="color: #008000;">//</span><span style="color: #008000;">对这个顶点继续DFS</span>
<span style="color: #008080;">43</span>       book[i] = <span style="color: #800080;">0</span>;                  <span style="color: #008000;">//</span><span style="color: #008000;">取消标记</span>
<span style="color: #008080;">44</span>       record_num--;                 <span style="color: #008000;">//</span><span style="color: #008000;">从已走过列表删除这个顶点</span>
<span style="color: #008080;">45</span>       totalWeight -= edge[now][i];  <span style="color: #008000;">//</span><span style="color: #008000;">从总开销中减去这条边的权重</span>
<span style="color: #008080;">46</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">47</span> <span style="color: #000000;">  }
</span><span style="color: #008080;">48</span> <span style="color: #000000;">}
</span><span style="color: #008080;">49</span> 
<span style="color: #008080;">50</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
</span><span style="color: #008080;">51</span> <span style="color: #000000;">{
</span><span style="color: #008080;">52</span>   book[<span style="color: #800080;">0</span>] = <span style="color: #800080;">1</span>;     <span style="color: #008000;">//</span><span style="color: #008000;">起点是A，所以A已经走过，将它标记</span>
<span style="color: #008080;">53</span>   record[<span style="color: #800080;">0</span>] = <span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span>; <span style="color: #008000;">//</span><span style="color: #008000;">起点其走过，把它加入已走过列表</span>
<span style="color: #008080;">54</span>   record_num = <span style="color: #800080;">1</span>;  <span style="color: #008000;">//</span><span style="color: #008000;">已走过列表+1</span>
<span style="color: #008080;">55</span>   dfs(<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>);       <span style="color: #008000;">//</span><span style="color: #008000;">从起点开始遍历</span>
<span style="color: #008080;">56</span>   printf(<span style="color: #800000;">"</span><span style="color: #800000;">So, the min cost path is %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">, minTotalWeight);
</span><span style="color: #008080;">57</span> 
<span style="color: #008080;">58</span>   <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">59</span> }</pre>
</div>
<p>输出：<br />Path 1: A B C D , in this case, the total cost is 16<br />Path 2: A B D , in this case, the total cost is 12<br />Path 3: A C B D , in this case, the total cost is 12<br />Path 4: A C D , in this case, the total cost is 3<br />So, the min cost path is 3</p>
<p>Process returned 0 (0x0)   execution time : 0.256 s<br />Press any key to continue.</p>
<p>PS：如果单纯的只是想知道起点到终点的最小开销是多少，而不用知道具体的路径，那么代码可以这样写：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> #include &lt;stdio.h&gt;
<span style="color: #008080;"> 2</span> <span style="color: #0000ff;">#define</span> X 9999 <span style="color: #008000;">//</span><span style="color: #008000;">假设X表示无穷</span>
<span style="color: #008080;"> 3</span> 
<span style="color: #008080;"> 4</span> <span style="color: #0000ff;">int</span> book[<span style="color: #800080;">4</span><span style="color: #000000;">];
</span><span style="color: #008080;"> 5</span> <span style="color: #0000ff;">char</span> vertex[<span style="color: #800080;">4</span>] = {<span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">B</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">C</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">D</span><span style="color: #800000;">'</span><span style="color: #000000;">};
</span><span style="color: #008080;"> 6</span> <span style="color: #0000ff;">int</span> edge[<span style="color: #800080;">4</span>][<span style="color: #800080;">4</span>] =<span style="color: #000000;"> {
</span><span style="color: #008080;"> 7</span>     {<span style="color: #800080;">0</span>, <span style="color: #800080;">9</span>, <span style="color: #800080;">2</span><span style="color: #000000;">, X},
</span><span style="color: #008080;"> 8</span>     {X, <span style="color: #800080;">0</span>, <span style="color: #800080;">6</span>, <span style="color: #800080;">3</span><span style="color: #000000;">},
</span><span style="color: #008080;"> 9</span>     {X, <span style="color: #800080;">7</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">1</span><span style="color: #000000;">},
</span><span style="color: #008080;">10</span>     {X, X, <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">}};
</span><span style="color: #008080;">11</span> <span style="color: #0000ff;">int</span> minTotalWeight = X; <span style="color: #008000;">//</span><span style="color: #008000;">保存路径的最小开销</span>
<span style="color: #008080;">12</span> 
<span style="color: #008080;">13</span> <span style="color: #0000ff;">void</span> dfs(<span style="color: #0000ff;">int</span> now, <span style="color: #0000ff;">int</span><span style="color: #000000;"> step)
</span><span style="color: #008080;">14</span> <span style="color: #000000;">{
</span><span style="color: #008080;">15</span>   <span style="color: #0000ff;">int</span><span style="color: #000000;"> i;
</span><span style="color: #008080;">16</span>   <span style="color: #0000ff;">if</span> (step &gt;<span style="color: #000000;"> minTotalWeight)
</span><span style="color: #008080;">17</span>     <span style="color: #0000ff;">return</span>; <span style="color: #008000;">//</span><span style="color: #008000;">如果当前走过的路径的开销已经大于上次记录的到终点的最小路径开销，那么就没必要继续在这个点递归了</span>
<span style="color: #008080;">18</span>   <span style="color: #0000ff;">if</span> (vertex[now] == <span style="color: #800000;">'</span><span style="color: #800000;">D</span><span style="color: #800000;">'</span><span style="color: #000000;">)
</span><span style="color: #008080;">19</span>   { <span style="color: #008000;">//</span><span style="color: #008000;">到了终点</span>
<span style="color: #008080;">20</span>     <span style="color: #0000ff;">if</span> (minTotalWeight &gt;<span style="color: #000000;"> step)
</span><span style="color: #008080;">21</span>       minTotalWeight = step; <span style="color: #008000;">//</span><span style="color: #008000;">更新路径的最少开销</span>
<span style="color: #008080;">22</span>     <span style="color: #0000ff;">return</span><span style="color: #000000;">;
</span><span style="color: #008080;">23</span> <span style="color: #000000;">  }
</span><span style="color: #008080;">24</span>   <span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">4</span>; i++<span style="color: #000000;">)
</span><span style="color: #008080;">25</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">26</span>     <span style="color: #0000ff;">if</span> (edge[now][i] != X &amp;&amp; edge[now][i] != <span style="color: #800080;">0</span> &amp;&amp; book[i] != <span style="color: #800080;">1</span><span style="color: #000000;">)
</span><span style="color: #008080;">27</span>     { <span style="color: #008000;">//</span><span style="color: #008000;">存在直连的顶点，且这个顶点不是自身，且这个顶点还没走过
</span><span style="color: #008080;">28</span>       <span style="color: #008000;">//</span><span style="color: #008000;">即将从当前顶点vertex[now]访问下一个顶点vertex[i]</span>
<span style="color: #008080;">29</span>       book[i] = <span style="color: #800080;">1</span>;                 <span style="color: #008000;">//</span><span style="color: #008000;">标记这个顶点，因为下一步就要去这个顶点</span>
<span style="color: #008080;">30</span>       dfs(i, step + edge[now][i]); <span style="color: #008000;">//</span><span style="color: #008000;">对这个顶点继续DFS</span>
<span style="color: #008080;">31</span>       <span style="color: #008000;">/*</span>
<span style="color: #008080;">32</span> <span style="color: #008000;">      在以往的代码实现中，dfs函数的step代表的含义是已经走过的顶点个数，
</span><span style="color: #008080;">33</span> <span style="color: #008000;">      之所以step的含义是这样，
</span><span style="color: #008080;">34</span> <span style="color: #008000;">      其一是让每次递归知道自己目前处于途中的第几个顶点，规定起点的step是0，
</span><span style="color: #008080;">35</span> <span style="color: #008000;">      其二是给记录已走过顶点的数组(record)做索引，
</span><span style="color: #008080;">36</span> <span style="color: #008000;">      而在这里，不再需要打印出起点到终点的路径，每次递归也不需要知道自己处于途中的第几个顶点，
</span><span style="color: #008080;">37</span> <span style="color: #008000;">      这样，step就可以修改它的含义，赋予新的含义：当前已走过顶点的总开销，
</span><span style="color: #008080;">38</span> <span style="color: #008000;">      相当于代替了原先的totalWeight变量，
</span><span style="color: #008080;">39</span> <span style="color: #008000;">      这时，建议将step换个名字，比如换成distance或totalCost或totalWeight等等
</span><span style="color: #008080;">40</span>       <span style="color: #008000;">*/</span>
<span style="color: #008080;">41</span>       book[i] = <span style="color: #800080;">0</span>; <span style="color: #008000;">//</span><span style="color: #008000;">取消标记</span>
<span style="color: #008080;">42</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">43</span> <span style="color: #000000;">  }
</span><span style="color: #008080;">44</span> <span style="color: #000000;">}
</span><span style="color: #008080;">45</span> 
<span style="color: #008080;">46</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
</span><span style="color: #008080;">47</span> <span style="color: #000000;">{
</span><span style="color: #008080;">48</span>   book[<span style="color: #800080;">0</span>] = <span style="color: #800080;">1</span>; <span style="color: #008000;">//</span><span style="color: #008000;">起点是A，所以A已经走过，将它标记</span>
<span style="color: #008080;">49</span>   dfs(<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>);   <span style="color: #008000;">//</span><span style="color: #008000;">从起点开始遍历</span>
<span style="color: #008080;">50</span>   printf(<span style="color: #800000;">"</span><span style="color: #800000;">Finally the min cost of point A to D is %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">, minTotalWeight);
</span><span style="color: #008080;">51</span> 
<span style="color: #008080;">52</span>   <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">53</span> }</pre>
</div>
<p>输出：<br />Finally the min cost of point A to D is 3</p>
<p>Process returned 0 (0x0)   execution time : 0.690 s<br />Press any key to continue.</p>
<p>5.由于故障，顶点C不能被访问，但不能从邻接矩阵中删除该点，打印出所有从起点到终点的路径，并给出最短路径：<br />只需在(4)的基础上修改dfs函数中的for循环内的if语句，多加个"vertex[i]!=='C'"条件即可，如下，</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">if</span> (edge[now][i] != X &amp;&amp; edge[now][i] != <span style="color: #800080;">0</span> &amp;&amp; book[i] != <span style="color: #800080;">1</span> &amp;&amp; vertex[i] != <span style="color: #800000;">'</span><span style="color: #800000;">C</span><span style="color: #800000;">'</span><span style="color: #000000;">)
</span><span style="color: #008080;">2</span> { <span style="color: #008000;">//</span><span style="color: #008000;">如果当前顶点是C，则不进入条件体
</span><span style="color: #008080;">3</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> ...</span>
<span style="color: #008080;">4</span> }</pre>
</div>
<p>输出：<br />Path 1: A B D , in this case, the total cost is 12<br />So, the min cost path is 12</p>
<p>Process returned 0 (0x0)   execution time : 0.315 s<br />Press any key to continue.</p>
<p>==主题结束==</p>]]></description></item><item><title>遍历以邻接矩阵存储的无向图</title><link>http://www.cnblogs.com/ryzz/archive/2020/02/12/12300206.html</link><dc:creator>RYZZ</dc:creator><author>RYZZ</author><pubDate>Wed, 12 Feb 2020 10:26:00 GMT</pubDate><guid>http://www.cnblogs.com/ryzz/archive/2020/02/12/12300206.html</guid><description><![CDATA[<p>==主题：遍历以邻接矩阵存储的无向图==</p>
<p>给出如下的图：<br />&nbsp; &nbsp; A<br />&nbsp; &nbsp;/| |\<br />B-|-|-C<br />&nbsp; \| | |<br />&nbsp; &nbsp;\ | |<br />&nbsp; &nbsp; |\|/<br />&nbsp; &nbsp;D-E  （这张图就是除了B和D、C和D，其余顶点两两相连的五角星）<br />将这张无向连通图转为邻接矩阵如下：<br />  A B C D E<br />A 0 1 1 1 1<br />B 1 0 1 0 1<br />C 1 1 0 0 1<br />D 1 0 0 0 1<br />E 1 1 1 1 0<br />无向图的邻接矩阵每行存储的是该行所代表的顶点直连的顶点有哪些，<br />假设起点是A点，终点是E点，回答下列问题：</p>
<p>1.从起点出发，遍历所有的顶点，得到所有的路径，并按遍历顺序打印出这些路径：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> #include &lt;stdio.h&gt;
<span style="color: #008080;"> 2</span> 
<span style="color: #008080;"> 3</span> <span style="color: #0000ff;">int</span> book[<span style="color: #800080;">5</span><span style="color: #000000;">];
</span><span style="color: #008080;"> 4</span> <span style="color: #0000ff;">char</span> vertex[<span style="color: #800080;">5</span>] = {<span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">B</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">C</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">D</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">E</span><span style="color: #800000;">'</span><span style="color: #000000;">};
</span><span style="color: #008080;"> 5</span> <span style="color: #0000ff;">int</span> edge[<span style="color: #800080;">5</span>][<span style="color: #800080;">5</span>] =<span style="color: #000000;"> {
</span><span style="color: #008080;"> 6</span>     {<span style="color: #800080;">0</span>, <span style="color: #800080;">1</span>, <span style="color: #800080;">1</span>, <span style="color: #800080;">1</span>, <span style="color: #800080;">1</span><span style="color: #000000;">},
</span><span style="color: #008080;"> 7</span>     {<span style="color: #800080;">1</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">1</span><span style="color: #000000;">},
</span><span style="color: #008080;"> 8</span>     {<span style="color: #800080;">1</span>, <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">1</span><span style="color: #000000;">},
</span><span style="color: #008080;"> 9</span>     {<span style="color: #800080;">1</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">1</span><span style="color: #000000;">},
</span><span style="color: #008080;">10</span>     {<span style="color: #800080;">1</span>, <span style="color: #800080;">1</span>, <span style="color: #800080;">1</span>, <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">}};
</span><span style="color: #008080;">11</span> <span style="color: #0000ff;">char</span> record[<span style="color: #800080;">5</span>];  <span style="color: #008000;">//</span><span style="color: #008000;">用于记录走过的顶点，已走过列表</span>
<span style="color: #008080;">12</span> <span style="color: #0000ff;">int</span> record_num;  <span style="color: #008000;">//</span><span style="color: #008000;">记录已走过列表的长度</span>
<span style="color: #008080;">13</span> <span style="color: #0000ff;">int</span> firstGoback; <span style="color: #008000;">//</span><span style="color: #008000;">记录继上次递归后是否发生了第一次回溯，0表示没有，1表示发生
</span><span style="color: #008080;">14</span> <span style="color: #008000;">//</span><span style="color: #008000;">某次递归发生了第一次回溯，说明DFS找到了一条路径</span>
<span style="color: #008080;">15</span> <span style="color: #0000ff;">int</span> path_num; <span style="color: #008000;">//</span><span style="color: #008000;">保存找到的路径个数</span>
<span style="color: #008080;">16</span> 
<span style="color: #008080;">17</span> <span style="color: #0000ff;">void</span> dfs(<span style="color: #0000ff;">int</span> now, <span style="color: #0000ff;">int</span><span style="color: #000000;"> step)
</span><span style="color: #008080;">18</span> <span style="color: #000000;">{
</span><span style="color: #008080;">19</span>   <span style="color: #0000ff;">int</span><span style="color: #000000;"> i, j;
</span><span style="color: #008080;">20</span>   <span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">5</span>; i++<span style="color: #000000;">)
</span><span style="color: #008080;">21</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">22</span>     <span style="color: #0000ff;">if</span> (edge[now][i] == <span style="color: #800080;">1</span> &amp;&amp; book[i] != <span style="color: #800080;">1</span><span style="color: #000000;">)
</span><span style="color: #008080;">23</span>     {                               <span style="color: #008000;">//</span><span style="color: #008000;">存在直连的顶点，且这个顶点还没走过</span>
<span style="color: #008080;">24</span>       book[i] = <span style="color: #800080;">1</span>;                  <span style="color: #008000;">//</span><span style="color: #008000;">标记这个顶点，因为下一步就要去这个顶点</span>
<span style="color: #008080;">25</span>       record[step + <span style="color: #800080;">1</span>] = vertex[i]; <span style="color: #008000;">//</span><span style="color: #008000;">把这个顶点记录到已走过列表</span>
<span style="color: #008080;">26</span>       record_num++;                 <span style="color: #008000;">//</span><span style="color: #008000;">对已走过列表长度+1</span>
<span style="color: #008080;">27</span>       firstGoback = <span style="color: #800080;">0</span>;              <span style="color: #008000;">//</span><span style="color: #008000;">要进入递归，置0</span>
<span style="color: #008080;">28</span>       dfs(i, step + <span style="color: #800080;">1</span>);             <span style="color: #008000;">//</span><span style="color: #008000;">对这个顶点继续DFS</span>
<span style="color: #008080;">29</span>       <span style="color: #0000ff;">if</span> (firstGoback == <span style="color: #800080;">0</span><span style="color: #000000;">)
</span><span style="color: #008080;">30</span> <span style="color: #000000;">      {
</span><span style="color: #008080;">31</span>         <span style="color: #008000;">//</span><span style="color: #008000;">等于0说明之前一直是递归，而现在发生了回溯，意味着这次回溯是继上次递归的第一次回溯
</span><span style="color: #008080;">32</span>         <span style="color: #008000;">//</span><span style="color: #008000;">打印上次递归找到的所有顶点，然后把firstGoback置1，让之后的回溯不是第一次回溯
</span><span style="color: #008080;">33</span>         <span style="color: #008000;">//</span><span style="color: #008000;">直到某次又发生递归，意味着又发现了新顶点，也意味着又发现了一条路径，再把firstGoback置0
</span><span style="color: #008080;">34</span>         <span style="color: #008000;">//</span><span style="color: #008000;">如此反复</span>
<span style="color: #008080;">35</span>         printf(<span style="color: #800000;">"</span><span style="color: #800000;">Path %d: </span><span style="color: #800000;">"</span>, ++<span style="color: #000000;">path_num);
</span><span style="color: #008080;">36</span>         <span style="color: #0000ff;">for</span> (j = <span style="color: #800080;">0</span>; j &lt; record_num; j++<span style="color: #000000;">)
</span><span style="color: #008080;">37</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">38</span>           printf(<span style="color: #800000;">"</span><span style="color: #800000;">%c </span><span style="color: #800000;">"</span><span style="color: #000000;">, record[j]);
</span><span style="color: #008080;">39</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">40</span>         printf(<span style="color: #800000;">"</span><span style="color: #800000;">\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">41</span>         firstGoback = <span style="color: #800080;">1</span>; <span style="color: #008000;">//</span><span style="color: #008000;">置1是为了当发生连续回溯时，使第二次及之后的回溯认为自己不是第一次回溯</span>
<span style="color: #008080;">42</span> <span style="color: #000000;">      }
</span><span style="color: #008080;">43</span>       book[i] = <span style="color: #800080;">0</span>;  <span style="color: #008000;">//</span><span style="color: #008000;">取消标记</span>
<span style="color: #008080;">44</span>       record_num--; <span style="color: #008000;">//</span><span style="color: #008000;">已走过顶点被取消标记，说明这个顶点现在没走过了，那么已走过列表长度也要-1</span>
<span style="color: #008080;">45</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">46</span> <span style="color: #000000;">  }
</span><span style="color: #008080;">47</span> <span style="color: #000000;">}
</span><span style="color: #008080;">48</span> 
<span style="color: #008080;">49</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
</span><span style="color: #008080;">50</span> <span style="color: #000000;">{
</span><span style="color: #008080;">51</span>   book[<span style="color: #800080;">0</span>] = <span style="color: #800080;">1</span>;     <span style="color: #008000;">//</span><span style="color: #008000;">起点是A，所以A已经走过，将它标记</span>
<span style="color: #008080;">52</span>   record[<span style="color: #800080;">0</span>] = <span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span>; <span style="color: #008000;">//</span><span style="color: #008000;">起点其走过，把它加入已走过列表</span>
<span style="color: #008080;">53</span>   record_num = <span style="color: #800080;">1</span>;  <span style="color: #008000;">//</span><span style="color: #008000;">已走过列表+1</span>
<span style="color: #008080;">54</span>   dfs(<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>);       <span style="color: #008000;">//</span><span style="color: #008000;">从起点开始遍历</span>
<span style="color: #008080;">55</span> 
<span style="color: #008080;">56</span>   <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">57</span> }</pre>
</div>
<p>输出：<br />Path 1: A B C E D<br />Path 2: A B E C<br />Path 3: A B E D<br />Path 4: A C B E D<br />Path 5: A C E B<br />Path 6: A C E D<br />Path 7: A D E B C<br />Path 8: A D E C B<br />Path 9: A E B C<br />Path 10: A E C B<br />Path 11: A E D</p>
<p>Process returned 0 (0x0)   execution time : 0.252 s<br />Press any key to continue.</p>
<p>PS：如果单纯是为了遍历，则不需要输出每次遍历得到的路径，删去那些用于打印路径相关的代码，核心代码是很精简的。</p>
<p>2.从起点出发，要求下一步达到的顶点是C，然后遍历剩下的顶点，打印出所有的路径：<br />只需修改main函数如下：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> book[<span style="color: #800080;">0</span>] = <span style="color: #800080;">1</span>;     <span style="color: #008000;">//</span><span style="color: #008000;">起点是A，所以A已经走过，将它标记</span>
<span style="color: #008080;">2</span> record[<span style="color: #800080;">0</span>] = <span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span>; <span style="color: #008000;">//</span><span style="color: #008000;">起点已走过，把它加入已走过列表</span>
<span style="color: #008080;">3</span> book[<span style="color: #800080;">2</span>] = <span style="color: #800080;">1</span>;     <span style="color: #008000;">//</span><span style="color: #008000;">由于规定了下一步是C，所以把C也标记已走过，C在book数组中是下标2</span>
<span style="color: #008080;">4</span> record[<span style="color: #800080;">1</span>] = <span style="color: #800000;">'</span><span style="color: #800000;">C</span><span style="color: #800000;">'</span>; <span style="color: #008000;">//</span><span style="color: #008000;">相同</span>
<span style="color: #008080;">5</span> record_num = <span style="color: #800080;">2</span>;  <span style="color: #008000;">//</span><span style="color: #008000;">已走过列表+2</span>
<span style="color: #008080;">6</span> dfs(<span style="color: #800080;">2</span>, <span style="color: #800080;">1</span>);       <span style="color: #008000;">//</span><span style="color: #008000;">从C点开始遍历</span></pre>
</div>
<p>输出：<br />Path 1: A C B E D<br />Path 2: A C E B<br />Path 3: A C E D</p>
<p>Process returned 0 (0x0)   execution time : 0.898 s<br />Press any key to continue.</p>
<p>3.从起点出发，要求下一步达到的顶点是C，然后遍历剩下的顶点（只遍历一次），打印出遍历的路径：<br />要实现只遍历一次，只需要当回溯一旦发生，就让它一直回溯到开始，然后结束函数，如下，</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> #include &lt;stdio.h&gt;
<span style="color: #008080;"> 2</span> 
<span style="color: #008080;"> 3</span> <span style="color: #0000ff;">int</span> book[<span style="color: #800080;">5</span><span style="color: #000000;">];
</span><span style="color: #008080;"> 4</span> <span style="color: #0000ff;">char</span> vertex[<span style="color: #800080;">5</span>] = {<span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">B</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">C</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">D</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">E</span><span style="color: #800000;">'</span><span style="color: #000000;">};
</span><span style="color: #008080;"> 5</span> <span style="color: #0000ff;">int</span> edge[<span style="color: #800080;">5</span>][<span style="color: #800080;">5</span>] =<span style="color: #000000;"> {
</span><span style="color: #008080;"> 6</span>     {<span style="color: #800080;">0</span>, <span style="color: #800080;">1</span>, <span style="color: #800080;">1</span>, <span style="color: #800080;">1</span>, <span style="color: #800080;">1</span><span style="color: #000000;">},
</span><span style="color: #008080;"> 7</span>     {<span style="color: #800080;">1</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">1</span><span style="color: #000000;">},
</span><span style="color: #008080;"> 8</span>     {<span style="color: #800080;">1</span>, <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">1</span><span style="color: #000000;">},
</span><span style="color: #008080;"> 9</span>     {<span style="color: #800080;">1</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">1</span><span style="color: #000000;">},
</span><span style="color: #008080;">10</span>     {<span style="color: #800080;">1</span>, <span style="color: #800080;">1</span>, <span style="color: #800080;">1</span>, <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">}};
</span><span style="color: #008080;">11</span> <span style="color: #0000ff;">char</span> record[<span style="color: #800080;">5</span>]; <span style="color: #008000;">//</span><span style="color: #008000;">用于记录走过的顶点，已走过列表</span>
<span style="color: #008080;">12</span> <span style="color: #0000ff;">int</span> record_num; <span style="color: #008000;">//</span><span style="color: #008000;">记录已走过列表的长度</span>
<span style="color: #008080;">13</span> <span style="color: #0000ff;">int</span> goback;     <span style="color: #008000;">//</span><span style="color: #008000;">标识是否已经发生了回溯，0表示没有，1表示发生</span>
<span style="color: #008080;">14</span> 
<span style="color: #008080;">15</span> <span style="color: #0000ff;">void</span> dfs(<span style="color: #0000ff;">int</span> now, <span style="color: #0000ff;">int</span><span style="color: #000000;"> step)
</span><span style="color: #008080;">16</span> <span style="color: #000000;">{
</span><span style="color: #008080;">17</span>   <span style="color: #0000ff;">int</span><span style="color: #000000;"> i, j;
</span><span style="color: #008080;">18</span>   <span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">5</span>; i++<span style="color: #000000;">)
</span><span style="color: #008080;">19</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">20</span>     <span style="color: #0000ff;">if</span> (edge[now][i] == <span style="color: #800080;">1</span> &amp;&amp; book[i] != <span style="color: #800080;">1</span> &amp;&amp; goback != <span style="color: #800080;">1</span><span style="color: #000000;">)
</span><span style="color: #008080;">21</span>     {                               <span style="color: #008000;">//</span><span style="color: #008000;">存在直连的顶点，且这个顶点还没走过，且还没发生过回溯</span>
<span style="color: #008080;">22</span>       book[i] = <span style="color: #800080;">1</span>;                  <span style="color: #008000;">//</span><span style="color: #008000;">标记这个顶点，因为下一步就要去这个顶点</span>
<span style="color: #008080;">23</span>       record[step + <span style="color: #800080;">1</span>] = vertex[i]; <span style="color: #008000;">//</span><span style="color: #008000;">把这个顶点记录到已走过列表</span>
<span style="color: #008080;">24</span>       record_num++;                 <span style="color: #008000;">//</span><span style="color: #008000;">对已走过列表长度+1</span>
<span style="color: #008080;">25</span>       goback = <span style="color: #800080;">0</span>;                   <span style="color: #008000;">//</span><span style="color: #008000;">要进入递归，置0</span>
<span style="color: #008080;">26</span>       dfs(i, step + <span style="color: #800080;">1</span>);             <span style="color: #008000;">//</span><span style="color: #008000;">对这个顶点继续DFS</span>
<span style="color: #008080;">27</span>       <span style="color: #0000ff;">if</span> (goback == <span style="color: #800080;">0</span><span style="color: #000000;">)
</span><span style="color: #008080;">28</span>       {             <span style="color: #008000;">//</span><span style="color: #008000;">发生了回溯，要判断是不是首次回溯，如果goback等于0，说明这次是首次回溯</span>
<span style="color: #008080;">29</span>         goback = <span style="color: #800080;">1</span>; <span style="color: #008000;">//</span><span style="color: #008000;">发生了首次回溯，就让这个回溯一直进行下去，直到回到递归的首次调用</span>
<span style="color: #008080;">30</span>         <span style="color: #0000ff;">for</span> (j = <span style="color: #800080;">0</span>; j &lt; record_num; j++<span style="color: #000000;">)
</span><span style="color: #008080;">31</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">32</span>           printf(<span style="color: #800000;">"</span><span style="color: #800000;">%c </span><span style="color: #800000;">"</span><span style="color: #000000;">, record[j]);
</span><span style="color: #008080;">33</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">34</span>         printf(<span style="color: #800000;">"</span><span style="color: #800000;">\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">35</span> <span style="color: #000000;">      }
</span><span style="color: #008080;">36</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">37</span> <span style="color: #000000;">  }
</span><span style="color: #008080;">38</span> <span style="color: #000000;">}
</span><span style="color: #008080;">39</span> 
<span style="color: #008080;">40</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
</span><span style="color: #008080;">41</span> <span style="color: #000000;">{
</span><span style="color: #008080;">42</span>   book[<span style="color: #800080;">0</span>] = <span style="color: #800080;">1</span><span style="color: #000000;">;
</span><span style="color: #008080;">43</span>   record[<span style="color: #800080;">0</span>] = <span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span><span style="color: #000000;">;
</span><span style="color: #008080;">44</span>   book[<span style="color: #800080;">2</span>] = <span style="color: #800080;">1</span><span style="color: #000000;">;
</span><span style="color: #008080;">45</span>   record[<span style="color: #800080;">1</span>] = <span style="color: #800000;">'</span><span style="color: #800000;">C</span><span style="color: #800000;">'</span><span style="color: #000000;">;
</span><span style="color: #008080;">46</span>   record_num = <span style="color: #800080;">2</span><span style="color: #000000;">;
</span><span style="color: #008080;">47</span>   dfs(<span style="color: #800080;">2</span>, <span style="color: #800080;">1</span>); <span style="color: #008000;">//</span><span style="color: #008000;">从C点开始遍历</span>
<span style="color: #008080;">48</span> 
<span style="color: #008080;">49</span>   <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">50</span> }</pre>
</div>
<p>输出：<br />A C B E D</p>
<p>Process returned 0 (0x0)   execution time : 0.231 s<br />Press any key to continue.</p>
<p>4.打印从起点到终点的所有路径，并找出最短路径：<br />这道题比(1)要简单很多，虽然都是打印出所有路径，但是这道题的&ldquo;什么时候该打印已遍历的路径&rdquo;这个条件很显而易见的，就是当递归处于终点时（vertext[now]等于'C'时），就代表一次寻路完成，把这个路径打印出来即可，而(1)打印一条路径的条件是&ldquo;发生了继上次递归后的首次回溯&rdquo;，这需要一个变量来记录是否发生了首次回溯，本题的代码如下：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> #include &lt;stdio.h&gt;
<span style="color: #008080;"> 2</span> 
<span style="color: #008080;"> 3</span> <span style="color: #0000ff;">int</span> book[<span style="color: #800080;">5</span><span style="color: #000000;">];
</span><span style="color: #008080;"> 4</span> <span style="color: #0000ff;">char</span> vertex[<span style="color: #800080;">5</span>] = {<span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">B</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">C</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">D</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">E</span><span style="color: #800000;">'</span><span style="color: #000000;">};
</span><span style="color: #008080;"> 5</span> <span style="color: #0000ff;">int</span> edge[<span style="color: #800080;">5</span>][<span style="color: #800080;">5</span>] =<span style="color: #000000;"> {
</span><span style="color: #008080;"> 6</span>     {<span style="color: #800080;">0</span>, <span style="color: #800080;">1</span>, <span style="color: #800080;">1</span>, <span style="color: #800080;">1</span>, <span style="color: #800080;">1</span><span style="color: #000000;">},
</span><span style="color: #008080;"> 7</span>     {<span style="color: #800080;">1</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">1</span><span style="color: #000000;">},
</span><span style="color: #008080;"> 8</span>     {<span style="color: #800080;">1</span>, <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">1</span><span style="color: #000000;">},
</span><span style="color: #008080;"> 9</span>     {<span style="color: #800080;">1</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">1</span><span style="color: #000000;">},
</span><span style="color: #008080;">10</span>     {<span style="color: #800080;">1</span>, <span style="color: #800080;">1</span>, <span style="color: #800080;">1</span>, <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">}};
</span><span style="color: #008080;">11</span> <span style="color: #0000ff;">char</span> record[<span style="color: #800080;">5</span>];     <span style="color: #008000;">//</span><span style="color: #008000;">用于记录走过的顶点，已走过列表</span>
<span style="color: #008080;">12</span> <span style="color: #0000ff;">int</span> record_num;     <span style="color: #008000;">//</span><span style="color: #008000;">记录已走过列表的长度</span>
<span style="color: #008080;">13</span> <span style="color: #0000ff;">int</span> path_num;       <span style="color: #008000;">//</span><span style="color: #008000;">保存找到的路径个数</span>
<span style="color: #008080;">14</span> <span style="color: #0000ff;">int</span> minStep = <span style="color: #800080;">9999</span>; <span style="color: #008000;">//</span><span style="color: #008000;">保存最短路径的步数</span>
<span style="color: #008080;">15</span> 
<span style="color: #008080;">16</span> <span style="color: #0000ff;">void</span> dfs(<span style="color: #0000ff;">int</span> now, <span style="color: #0000ff;">int</span><span style="color: #000000;"> step)
</span><span style="color: #008080;">17</span> <span style="color: #000000;">{
</span><span style="color: #008080;">18</span>   <span style="color: #0000ff;">int</span><span style="color: #000000;"> i;
</span><span style="color: #008080;">19</span>   <span style="color: #0000ff;">if</span> (vertex[now] == <span style="color: #800000;">'</span><span style="color: #800000;">E</span><span style="color: #800000;">'</span><span style="color: #000000;">)
</span><span style="color: #008080;">20</span>   { <span style="color: #008000;">//</span><span style="color: #008000;">到终点</span>
<span style="color: #008080;">21</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">Path %d: </span><span style="color: #800000;">"</span>, ++<span style="color: #000000;">path_num);
</span><span style="color: #008080;">22</span>     <span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>; i &lt; record_num; i++<span style="color: #000000;">)
</span><span style="color: #008080;">23</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">24</span>       printf(<span style="color: #800000;">"</span><span style="color: #800000;">%c </span><span style="color: #800000;">"</span><span style="color: #000000;">, record[i]);
</span><span style="color: #008080;">25</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">26</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">, in this case, the step is %d</span><span style="color: #800000;">"</span><span style="color: #000000;">, step);
</span><span style="color: #008080;">27</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">28</span>     <span style="color: #0000ff;">if</span> (minStep &gt;<span style="color: #000000;"> step)
</span><span style="color: #008080;">29</span>       minStep = step; <span style="color: #008000;">//</span><span style="color: #008000;">更新最少步数</span>
<span style="color: #008080;">30</span>     <span style="color: #0000ff;">return</span><span style="color: #000000;">;
</span><span style="color: #008080;">31</span> <span style="color: #000000;">  }
</span><span style="color: #008080;">32</span>   <span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">5</span>; i++<span style="color: #000000;">)
</span><span style="color: #008080;">33</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">34</span>     <span style="color: #0000ff;">if</span> (edge[now][i] == <span style="color: #800080;">1</span> &amp;&amp; book[i] != <span style="color: #800080;">1</span><span style="color: #000000;">)
</span><span style="color: #008080;">35</span>     {                               <span style="color: #008000;">//</span><span style="color: #008000;">存在直连的顶点，且这个顶点还没走过</span>
<span style="color: #008080;">36</span>       book[i] = <span style="color: #800080;">1</span>;                  <span style="color: #008000;">//</span><span style="color: #008000;">标记这个顶点，因为下一步就要去这个顶点</span>
<span style="color: #008080;">37</span>       record[step + <span style="color: #800080;">1</span>] = vertex[i]; <span style="color: #008000;">//</span><span style="color: #008000;">把这个顶点记录到已走过列表</span>
<span style="color: #008080;">38</span>       record_num++;                 <span style="color: #008000;">//</span><span style="color: #008000;">对已走过列表长度+1</span>
<span style="color: #008080;">39</span>       dfs(i, step + <span style="color: #800080;">1</span>);             <span style="color: #008000;">//</span><span style="color: #008000;">对这个顶点继续DFS</span>
<span style="color: #008080;">40</span>       book[i] = <span style="color: #800080;">0</span>;                  <span style="color: #008000;">//</span><span style="color: #008000;">取消标记</span>
<span style="color: #008080;">41</span>       record_num--;                 <span style="color: #008000;">//</span><span style="color: #008000;">已走过顶点被取消标记，说明这个顶点现在没走过了，那么已走过列表长度也要-1</span>
<span style="color: #008080;">42</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">43</span> <span style="color: #000000;">  }
</span><span style="color: #008080;">44</span> <span style="color: #000000;">}
</span><span style="color: #008080;">45</span> 
<span style="color: #008080;">46</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
</span><span style="color: #008080;">47</span> <span style="color: #000000;">{
</span><span style="color: #008080;">48</span>   book[<span style="color: #800080;">0</span>] = <span style="color: #800080;">1</span>;     <span style="color: #008000;">//</span><span style="color: #008000;">起点是A，所以A已经走过，将它标记</span>
<span style="color: #008080;">49</span>   record[<span style="color: #800080;">0</span>] = <span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span>; <span style="color: #008000;">//</span><span style="color: #008000;">起点其走过，把它加入已走过列表</span>
<span style="color: #008080;">50</span>   record_num = <span style="color: #800080;">1</span>;  <span style="color: #008000;">//</span><span style="color: #008000;">已走过列表+1</span>
<span style="color: #008080;">51</span>   dfs(<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>);       <span style="color: #008000;">//</span><span style="color: #008000;">从起点开始遍历</span>
<span style="color: #008080;">52</span>   printf(<span style="color: #800000;">"</span><span style="color: #800000;">The min step is %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">, minStep);
</span><span style="color: #008080;">53</span> 
<span style="color: #008080;">54</span>   <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">55</span> }</pre>
</div>
<p>输出：<br />Path 1: A B C E , in this case, the step is 3<br />Path 2: A B E , in this case, the step is 2<br />Path 3: A C B E , in this case, the step is 3<br />Path 4: A C E , in this case, the step is 2<br />Path 5: A D E , in this case, the step is 2<br />Path 6: A E , in this case, the step is 1<br />The min step is 1</p>
<p>Process returned 0 (0x0)   execution time : 0.356 s<br />Press any key to continue.</p>
<p>5.由于故障，顶点C不能被访问，但不能从邻接矩阵中删除该点，打印出所有从起点到终点的路径，并给出最短路径：<br />只需在(4)的基础上修改dfs函数中的for循环内的if语句，多加个"vertex[i]!=='C'"条件即可，如下，</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">if</span> (edge[now][i] == <span style="color: #800080;">1</span> &amp;&amp; book[i] != <span style="color: #800080;">1</span> &amp;&amp; vertex[i] != <span style="color: #800000;">'</span><span style="color: #800000;">C</span><span style="color: #800000;">'</span><span style="color: #000000;">)
</span><span style="color: #008080;">2</span> { <span style="color: #008000;">//</span><span style="color: #008000;">存在直连的顶点，且这个顶点还没走过，且不是C点，因为C点坏了，不能被访问到
</span><span style="color: #008080;">3</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> ...</span>
<span style="color: #008080;">4</span> }</pre>
</div>
<p>输出：<br />Path 1: A B E , in this case, the step is 2<br />Path 2: A D E , in this case, the step is 2<br />Path 3: A E , in this case, the step is 1<br />The min step is 1</p>
<p>Process returned 0 (0x0)   execution time : 0.574 s<br />Press any key to continue.</p>
<p>==主题结束==</p>]]></description></item><item><title>遍历以二维数组存储的图</title><link>http://www.cnblogs.com/ryzz/archive/2020/02/10/12292755.html</link><dc:creator>RYZZ</dc:creator><author>RYZZ</author><pubDate>Mon, 10 Feb 2020 13:03:00 GMT</pubDate><guid>http://www.cnblogs.com/ryzz/archive/2020/02/10/12292755.html</guid><description><![CDATA[<p>==主题：遍历以二维数组存储的图==</p>
<p>给出如下的图：<br />0 0<br />0 0<br />0 0<br />这是一个3行2列的图，用二维数组map[2][3]存储，规定：数组的第1个下标表示行，第2个下标表示列，<br />假设起点是map[0][0]点，即左上角，终点是map[2][1]点，即右下角，回答下列问题：</p>
<p>1.从起点出发，遍历整个图，但只遍历一次，按每个点被遍历的顺序，依次打印出这些点：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> #include &lt;stdio.h&gt;
<span style="color: #008080;"> 2</span> 
<span style="color: #008080;"> 3</span> <span style="color: #008000;">/*</span>
<span style="color: #008080;"> 4</span> <span style="color: #008000;">变量说明：
</span><span style="color: #008080;"> 5</span> <span style="color: #008000;">C语言中，具有文件作用域的变量都是静态存储类别，编译器会自动给它们赋默认值，int类型的默认值是0
</span><span style="color: #008080;"> 6</span> <span style="color: #008000;">map：存储图
</span><span style="color: #008080;"> 7</span> <span style="color: #008000;">book：标记图中的哪个点已经走过，1表示已经走过，0表示还未走过
</span><span style="color: #008080;"> 8</span> <span style="color: #008000;">recordY：保存已经走过的点的Y坐标（所在行）
</span><span style="color: #008080;"> 9</span> <span style="color: #008000;">recordX：保存已经走过的点的X坐标（所在列）
</span><span style="color: #008080;">10</span> <span style="color: #008000;">next：方向数组，用于指定下一步去往的点的坐标，方向的顺序是：上、右、下、左
</span><span style="color: #008080;">11</span> <span style="color: #008000;">*/</span>
<span style="color: #008080;">12</span> <span style="color: #0000ff;">int</span> map[<span style="color: #800080;">3</span>][<span style="color: #800080;">2</span><span style="color: #000000;">];
</span><span style="color: #008080;">13</span> <span style="color: #0000ff;">int</span> book[<span style="color: #800080;">3</span>][<span style="color: #800080;">2</span><span style="color: #000000;">];
</span><span style="color: #008080;">14</span> <span style="color: #0000ff;">int</span> recordY[<span style="color: #800080;">6</span><span style="color: #000000;">];
</span><span style="color: #008080;">15</span> <span style="color: #0000ff;">int</span> recordX[<span style="color: #800080;">6</span><span style="color: #000000;">];
</span><span style="color: #008080;">16</span> <span style="color: #0000ff;">int</span> next[<span style="color: #800080;">4</span>][<span style="color: #800080;">2</span>] = {{-<span style="color: #800080;">1</span>, <span style="color: #800080;">0</span>}, {<span style="color: #800080;">0</span>, <span style="color: #800080;">1</span>}, {<span style="color: #800080;">1</span>, <span style="color: #800080;">0</span>}, {<span style="color: #800080;">0</span>, -<span style="color: #800080;">1</span><span style="color: #000000;">}};
</span><span style="color: #008080;">17</span> 
<span style="color: #008080;">18</span> <span style="color: #0000ff;">void</span> dfs(<span style="color: #0000ff;">int</span> y, <span style="color: #0000ff;">int</span> x, <span style="color: #0000ff;">int</span><span style="color: #000000;"> step)
</span><span style="color: #008080;">19</span> <span style="color: #000000;">{
</span><span style="color: #008080;">20</span>   <span style="color: #0000ff;">int</span><span style="color: #000000;"> i, tx, ty;
</span><span style="color: #008080;">21</span>   <span style="color: #0000ff;">if</span> (step == <span style="color: #800080;">5</span><span style="color: #000000;">)
</span><span style="color: #008080;">22</span>   { <span style="color: #008000;">//</span><span style="color: #008000;">遍历结束，因为整个图一共6个点，起点的step是0，所以遍历的最后一个点的step是5</span>
<span style="color: #008080;">23</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">Traverse complete\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">24</span>     <span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>; i &lt;= step; i++<span style="color: #000000;">)
</span><span style="color: #008080;">25</span>     { <span style="color: #008000;">//</span><span style="color: #008000;">打印出保存在recordY和recordX中的点的坐标</span>
<span style="color: #008080;">26</span>       printf(<span style="color: #800000;">"</span><span style="color: #800000;">step: %d, at y=%d and x=%d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">, i, recordY[i], recordX[i]);
</span><span style="color: #008080;">27</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">28</span>     <span style="color: #0000ff;">return</span><span style="color: #000000;">;
</span><span style="color: #008080;">29</span> <span style="color: #000000;">  }
</span><span style="color: #008080;">30</span>   <span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">4</span>; i++<span style="color: #000000;">)
</span><span style="color: #008080;">31</span>   {                      <span style="color: #008000;">//</span><span style="color: #008000;">还没遍历完，继续枚举各个方向并进行下次递归</span>
<span style="color: #008080;">32</span>     ty = y + next[i][<span style="color: #800080;">0</span>]; <span style="color: #008000;">//</span><span style="color: #008000;">下个点所在的行</span>
<span style="color: #008080;">33</span>     tx = x + next[i][<span style="color: #800080;">1</span>]; <span style="color: #008000;">//</span><span style="color: #008000;">下个点所在的列</span>
<span style="color: #008080;">34</span>     <span style="color: #0000ff;">if</span> (tx &gt; -<span style="color: #800080;">1</span> &amp;&amp; tx &lt; <span style="color: #800080;">2</span> &amp;&amp; ty &gt; -<span style="color: #800080;">1</span> &amp;&amp; ty &lt; <span style="color: #800080;">3</span> &amp;&amp; book[ty][tx] != <span style="color: #800080;">1</span><span style="color: #000000;">)
</span><span style="color: #008080;">35</span>     {                         <span style="color: #008000;">//</span><span style="color: #008000;">这个点必须在图内，且没有被标记</span>
<span style="color: #008080;">36</span>       book[ty][tx] = <span style="color: #800080;">1</span>;       <span style="color: #008000;">//</span><span style="color: #008000;">标记这个点</span>
<span style="color: #008080;">37</span>       recordY[step + <span style="color: #800080;">1</span>] = ty; <span style="color: #008000;">//</span><span style="color: #008000;">保存这个点所在的行</span>
<span style="color: #008080;">38</span>       recordX[step + <span style="color: #800080;">1</span>] = tx; <span style="color: #008000;">//</span><span style="color: #008000;">保存这个点所在的列</span>
<span style="color: #008080;">39</span>       dfs(ty, tx, step + <span style="color: #800080;">1</span>);  <span style="color: #008000;">//</span><span style="color: #008000;">对这个点继续DFS</span>
<span style="color: #008080;">40</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">41</span> <span style="color: #000000;">  }
</span><span style="color: #008080;">42</span> <span style="color: #000000;">}
</span><span style="color: #008080;">43</span> 
<span style="color: #008080;">44</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
</span><span style="color: #008080;">45</span> <span style="color: #000000;">{
</span><span style="color: #008080;">46</span>   book[<span style="color: #800080;">0</span>][<span style="color: #800080;">0</span>] = <span style="color: #800080;">1</span>; <span style="color: #008000;">//</span><span style="color: #008000;">从起点出发，所以起点已经走过了，把它标记为1</span>
<span style="color: #008080;">47</span>   recordY[<span style="color: #800080;">0</span>] = <span style="color: #800080;">0</span>; <span style="color: #008000;">//</span><span style="color: #008000;">先把起点所在的行保存下来</span>
<span style="color: #008080;">48</span>   recordX[<span style="color: #800080;">0</span>] = <span style="color: #800080;">0</span>; <span style="color: #008000;">//</span><span style="color: #008000;">并把起点所在的列保存下来</span>
<span style="color: #008080;">49</span>   dfs(<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>);   <span style="color: #008000;">//</span><span style="color: #008000;">从第0行，第0列，即起点，开始遍历图，当前步数是0</span>
<span style="color: #008080;">50</span> 
<span style="color: #008080;">51</span>   <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">52</span> }</pre>
</div>
<p>输出：<br />Traverse complete<br />step: 0, at y=0 and x=0<br />step: 1, at y=0 and x=1<br />step: 2, at y=1 and x=1<br />step: 3, at y=2 and x=1<br />step: 4, at y=2 and x=0<br />step: 5, at y=1 and x=0</p>
<p>Process returned 0 (0x0)   execution time : 0.623 s<br />Press any key to continue.</p>
<p>2.从起点出发，遍历整个图，要求得到全部的遍历结果，每种遍历结果都要打印出来：<br />只需加一行代码在(1)中的&nbsp;<span class="cnblogs_code">dfs(ty, tx, step + <span style="color: #800080;">1</span>); <span style="color: #008000;">//</span><span style="color: #008000;">对这个点继续DFS</span></span>&nbsp;的后面：<br />&nbsp;<span class="cnblogs_code">book[ty][tx] = <span style="color: #800080;">0</span>; <span style="color: #008000;">//</span><span style="color: #008000;">取消对这个点的标记，以便其他遍历能访问这个点</span></span>&nbsp;<br />输出：<br />Traverse complete<br />step: 0, at y=0 and x=0<br />step: 1, at y=0 and x=1<br />step: 2, at y=1 and x=1<br />step: 3, at y=2 and x=1<br />step: 4, at y=2 and x=0<br />step: 5, at y=1 and x=0<br />Traverse complete<br />step: 0, at y=0 and x=0<br />step: 1, at y=0 and x=1<br />step: 2, at y=1 and x=1<br />step: 3, at y=1 and x=0<br />step: 4, at y=2 and x=0<br />step: 5, at y=2 and x=1<br />Traverse complete<br />step: 0, at y=0 and x=0<br />step: 1, at y=1 and x=0<br />step: 2, at y=2 and x=0<br />step: 3, at y=2 and x=1<br />step: 4, at y=1 and x=1<br />step: 5, at y=0 and x=1</p>
<p>Process returned 0 (0x0)   execution time : 0.327 s<br />Press any key to continue.</p>
<p>PS：发现，最终的遍历结果只有3种，而不是预想的4种，少了下面这种，<br />从起点出发，先去y=1,x=0点，再去y=1,x=1点，再去y=0,x=1点，这时，对y=0,x=1点进行所有方向的枚举都是失败的，往上走超出了边界，往右走也超出了边界，往下走的点已经被标记，往左走的点也已经被标记，这时，枚举方向的for循环结束，整个函数也随之结束，递归返回，又回到了y=1,x=1点，此时的step值是2，再去y=2,x=1点，再去y=2,x=0点，而这个点已经是访问的最后一个点了，可是此时的step值是4，不满足等于5的条件，进不去if语句，然后进入了for循环，但是没有一次循环能符合内部的if条件，最后for循环结束，整个函数也结束，递归开始返回，最终导致这次遍历的结果没有被打印，<br />这也是在所有4种遍历结果中，唯一一个在中途就发生递归返回的特例，其余的3种都是在访问最后一个点时才发生递归返回，这直接导致step值少1，必然输出不了这次的遍历结果，其实，这次遍历结果的路径不是一条简单路径，因为y=1,x=1点重复了，路径是：(0,0)-&gt;(1,0)-&gt;(1,1)-&gt;(0,1)-&gt;(1,1)-&gt;(2,1)-&gt;(2,0)，点(1,1)重复出现了，<br />最后，要解决这个问题，需要改进这个程序。</p>
<p>3.规定，只能从起点的右侧出发（即起点的下一步必是(y=0,x=1)），只遍历一次，打印遍历结果：<br />只需修改(1)的main函数如下：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
</span><span style="color: #008080;"> 2</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 3</span>   book[<span style="color: #800080;">0</span>][<span style="color: #800080;">0</span>] = <span style="color: #800080;">1</span>; <span style="color: #008000;">//</span><span style="color: #008000;">从起点出发，所以起点已经走过了，把它标记为1</span>
<span style="color: #008080;"> 4</span>   recordY[<span style="color: #800080;">0</span>] = <span style="color: #800080;">0</span>; <span style="color: #008000;">//</span><span style="color: #008000;">先把起点所在的行保存下来</span>
<span style="color: #008080;"> 5</span>   recordX[<span style="color: #800080;">0</span>] = <span style="color: #800080;">0</span>; <span style="color: #008000;">//</span><span style="color: #008000;">并把起点所在的列保存下来</span>
<span style="color: #008080;"> 6</span>   book[<span style="color: #800080;">0</span>][<span style="color: #800080;">1</span>] = <span style="color: #800080;">1</span>; <span style="color: #008000;">//</span><span style="color: #008000;">规定了只能从起点的右侧出发，那么下个点一定是y=0,x=1</span>
<span style="color: #008080;"> 7</span>   recordY[<span style="color: #800080;">0</span>] = <span style="color: #800080;">0</span>; <span style="color: #008000;">//</span><span style="color: #008000;">第1步的Y坐标</span>
<span style="color: #008080;"> 8</span>   recordX[<span style="color: #800080;">1</span>] = <span style="color: #800080;">1</span>; <span style="color: #008000;">//</span><span style="color: #008000;">第1步的X坐标</span>
<span style="color: #008080;"> 9</span>   dfs(<span style="color: #800080;">0</span>, <span style="color: #800080;">1</span>, <span style="color: #800080;">1</span>);   <span style="color: #008000;">//</span><span style="color: #008000;">从第0行，第0列，开始遍历图，当前步数是1</span>
<span style="color: #008080;">10</span> 
<span style="color: #008080;">11</span>   <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">12</span> }</pre>
</div>
<p>输出：<br />Traverse complete<br />step: 0, at y=0 and x=0<br />step: 1, at y=0 and x=1<br />step: 2, at y=1 and x=1<br />step: 3, at y=2 and x=1<br />step: 4, at y=2 and x=0<br />step: 5, at y=1 and x=0</p>
<p>Process returned 0 (0x0)   execution time : 0.967 s<br />Press any key to continue.</p>
<p>4.规定，只能从起点的右侧出发，打印所有的遍历结果：<br />只需在(3)的基础上，类似于(2)，每次遍历之后取消标记那个点</p>
<p>5.规定，只能从起点的下方出发，只遍历一次，打印遍历结果：<br />等同于(3)，只需要这样修改main函数：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> book[<span style="color: #800080;">0</span>][<span style="color: #800080;">0</span>] = <span style="color: #800080;">1</span>; <span style="color: #008000;">//</span><span style="color: #008000;">从起点出发，所以起点已经走过了，把它标记为1</span>
<span style="color: #008080;">2</span> recordY[<span style="color: #800080;">0</span>] = <span style="color: #800080;">0</span>; <span style="color: #008000;">//</span><span style="color: #008000;">先把起点所在的行保存下来</span>
<span style="color: #008080;">3</span> recordX[<span style="color: #800080;">0</span>] = <span style="color: #800080;">0</span>; <span style="color: #008000;">//</span><span style="color: #008000;">并把起点所在的列保存下来</span>
<span style="color: #008080;">4</span> book[<span style="color: #800080;">0</span>][<span style="color: #800080;">1</span>] = <span style="color: #800080;">1</span>; <span style="color: #008000;">//</span><span style="color: #008000;">规定了只能从起点的下方出发，那么下个点一定是y=1,x=0</span>
<span style="color: #008080;">5</span> recordY[<span style="color: #800080;">1</span>] = <span style="color: #800080;">0</span>; <span style="color: #008000;">//</span><span style="color: #008000;">第1步的Y坐标</span>
<span style="color: #008080;">6</span> recordX[<span style="color: #800080;">0</span>] = <span style="color: #800080;">1</span>; <span style="color: #008000;">//</span><span style="color: #008000;">第1步的X坐标</span>
<span style="color: #008080;">7</span> dfs(<span style="color: #800080;">1</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">1</span>);   <span style="color: #008000;">//</span><span style="color: #008000;">从第0行，第0列，开始遍历图，当前步数是1</span></pre>
</div>
<p>6.规定，只能从起点的下方出发，打印所有的遍历结果：<br />等同于(4)，每次遍历之后取消标记那个点</p>
<p>7.打印出从起点出发到终点的所有路径，并给出最短的步数：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> #include &lt;stdio.h&gt;
<span style="color: #008080;"> 2</span> 
<span style="color: #008080;"> 3</span> <span style="color: #0000ff;">int</span> map[<span style="color: #800080;">3</span>][<span style="color: #800080;">2</span><span style="color: #000000;">];
</span><span style="color: #008080;"> 4</span> <span style="color: #0000ff;">int</span> book[<span style="color: #800080;">3</span>][<span style="color: #800080;">2</span><span style="color: #000000;">];
</span><span style="color: #008080;"> 5</span> <span style="color: #0000ff;">int</span> recordY[<span style="color: #800080;">6</span><span style="color: #000000;">];
</span><span style="color: #008080;"> 6</span> <span style="color: #0000ff;">int</span> recordX[<span style="color: #800080;">6</span><span style="color: #000000;">];
</span><span style="color: #008080;"> 7</span> <span style="color: #0000ff;">int</span> next[<span style="color: #800080;">4</span>][<span style="color: #800080;">2</span>] = {{-<span style="color: #800080;">1</span>, <span style="color: #800080;">0</span>}, {<span style="color: #800080;">0</span>, <span style="color: #800080;">1</span>}, {<span style="color: #800080;">1</span>, <span style="color: #800080;">0</span>}, {<span style="color: #800080;">0</span>, -<span style="color: #800080;">1</span><span style="color: #000000;">}};
</span><span style="color: #008080;"> 8</span> <span style="color: #0000ff;">int</span> minStep = <span style="color: #800080;">9999</span>; <span style="color: #008000;">//</span><span style="color: #008000;">保存每次遍历结果的最小步数</span>
<span style="color: #008080;"> 9</span> 
<span style="color: #008080;">10</span> <span style="color: #0000ff;">void</span> dfs(<span style="color: #0000ff;">int</span> y, <span style="color: #0000ff;">int</span> x, <span style="color: #0000ff;">int</span><span style="color: #000000;"> step)
</span><span style="color: #008080;">11</span> <span style="color: #000000;">{
</span><span style="color: #008080;">12</span>   <span style="color: #0000ff;">int</span><span style="color: #000000;"> i, tx, ty;
</span><span style="color: #008080;">13</span>   <span style="color: #0000ff;">if</span> (y == <span style="color: #800080;">2</span> &amp;&amp; x == <span style="color: #800080;">1</span><span style="color: #000000;">)
</span><span style="color: #008080;">14</span>   { <span style="color: #008000;">//</span><span style="color: #008000;">到达终点</span>
<span style="color: #008080;">15</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">Traverse complete\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">16</span>     <span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>; i &lt;= step; i++<span style="color: #000000;">)
</span><span style="color: #008080;">17</span>     { <span style="color: #008000;">//</span><span style="color: #008000;">打印出保存在recordY和recordX中的点的坐标</span>
<span style="color: #008080;">18</span>       printf(<span style="color: #800000;">"</span><span style="color: #800000;">step: %d, at y=%d and x=%d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">, i, recordY[i], recordX[i]);
</span><span style="color: #008080;">19</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">20</span>     <span style="color: #0000ff;">if</span> (minStep &gt;<span style="color: #000000;"> step)
</span><span style="color: #008080;">21</span>       minStep = step; <span style="color: #008000;">//</span><span style="color: #008000;">发现步数更少的遍历方式，更新最小步数</span>
<span style="color: #008080;">22</span>     <span style="color: #0000ff;">return</span><span style="color: #000000;">;
</span><span style="color: #008080;">23</span> <span style="color: #000000;">  }
</span><span style="color: #008080;">24</span>   <span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">4</span>; i++<span style="color: #000000;">)
</span><span style="color: #008080;">25</span>   {                      <span style="color: #008000;">//</span><span style="color: #008000;">还没遍历完，继续枚举各个方向并进行下次递归</span>
<span style="color: #008080;">26</span>     ty = y + next[i][<span style="color: #800080;">0</span>]; <span style="color: #008000;">//</span><span style="color: #008000;">下个点所在的行</span>
<span style="color: #008080;">27</span>     tx = x + next[i][<span style="color: #800080;">1</span>]; <span style="color: #008000;">//</span><span style="color: #008000;">下个点所在的列</span>
<span style="color: #008080;">28</span>     <span style="color: #0000ff;">if</span> (tx &gt; -<span style="color: #800080;">1</span> &amp;&amp; tx &lt; <span style="color: #800080;">2</span> &amp;&amp; ty &gt; -<span style="color: #800080;">1</span> &amp;&amp; ty &lt; <span style="color: #800080;">3</span> &amp;&amp; book[ty][tx] != <span style="color: #800080;">1</span><span style="color: #000000;">)
</span><span style="color: #008080;">29</span>     {                         <span style="color: #008000;">//</span><span style="color: #008000;">这个点必须在图内，且没有被标记</span>
<span style="color: #008080;">30</span>       book[ty][tx] = <span style="color: #800080;">1</span>;       <span style="color: #008000;">//</span><span style="color: #008000;">标记这个点</span>
<span style="color: #008080;">31</span>       recordY[step + <span style="color: #800080;">1</span>] = ty; <span style="color: #008000;">//</span><span style="color: #008000;">保存这个点所在的行</span>
<span style="color: #008080;">32</span>       recordX[step + <span style="color: #800080;">1</span>] = tx; <span style="color: #008000;">//</span><span style="color: #008000;">保存这个点所在的列</span>
<span style="color: #008080;">33</span>       dfs(ty, tx, step + <span style="color: #800080;">1</span>);  <span style="color: #008000;">//</span><span style="color: #008000;">对这个点继续DFS</span>
<span style="color: #008080;">34</span>       book[ty][tx] = <span style="color: #800080;">0</span>;       <span style="color: #008000;">//</span><span style="color: #008000;">取消标记这个点</span>
<span style="color: #008080;">35</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">36</span> <span style="color: #000000;">  }
</span><span style="color: #008080;">37</span> <span style="color: #000000;">}
</span><span style="color: #008080;">38</span> 
<span style="color: #008080;">39</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
</span><span style="color: #008080;">40</span> <span style="color: #000000;">{
</span><span style="color: #008080;">41</span>   book[<span style="color: #800080;">0</span>][<span style="color: #800080;">0</span>] = <span style="color: #800080;">1</span>; <span style="color: #008000;">//</span><span style="color: #008000;">从起点出发，所以起点已经走过了，把它标记为1</span>
<span style="color: #008080;">42</span>   recordY[<span style="color: #800080;">0</span>] = <span style="color: #800080;">0</span>; <span style="color: #008000;">//</span><span style="color: #008000;">先把起点所在的行保存下来</span>
<span style="color: #008080;">43</span>   recordX[<span style="color: #800080;">0</span>] = <span style="color: #800080;">0</span>; <span style="color: #008000;">//</span><span style="color: #008000;">并把起点所在的列保存下来</span>
<span style="color: #008080;">44</span>   dfs(<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>);   <span style="color: #008000;">//</span><span style="color: #008000;">从第0行，第0列，开始遍历图，当前步数是1</span>
<span style="color: #008080;">45</span>   printf(<span style="color: #800000;">"</span><span style="color: #800000;">The minimum step is %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">, minStep);
</span><span style="color: #008080;">46</span> 
<span style="color: #008080;">47</span>   <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">48</span> }</pre>
</div>
<p>输出：Traverse complete<br />step: 0, at y=0 and x=0<br />step: 1, at y=0 and x=1<br />step: 2, at y=1 and x=1<br />step: 3, at y=2 and x=1<br />Traverse complete<br />step: 0, at y=0 and x=0<br />step: 1, at y=0 and x=1<br />step: 2, at y=1 and x=1<br />step: 3, at y=1 and x=0<br />step: 4, at y=2 and x=0<br />step: 5, at y=2 and x=1<br />Traverse complete<br />step: 0, at y=0 and x=0<br />step: 1, at y=1 and x=0<br />step: 2, at y=1 and x=1<br />step: 3, at y=2 and x=1<br />Traverse complete<br />step: 0, at y=0 and x=0<br />step: 1, at y=1 and x=0<br />step: 2, at y=2 and x=0<br />step: 3, at y=2 and x=1<br />The minimum step is 3</p>
<p>Process returned 0 (0x0)   execution time : 0.399 s<br />Press any key to continue.</p>
<p>8.由于故障，点(y=1,x=1)不能被访问，求出现在从起点到终点的所有路径：<br />只需修改(7)的main函数和dfs函数，具体如下，<br />修改main函数：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> map[<span style="color: #800080;">1</span>][<span style="color: #800080;">1</span>] = -<span style="color: #800080;">1</span>; <span style="color: #008000;">//</span><span style="color: #008000;">值为-1表示这个点不能被访问</span>
<span style="color: #008080;">2</span> book[<span style="color: #800080;">0</span>][<span style="color: #800080;">0</span>] = <span style="color: #800080;">1</span>; <span style="color: #008000;">//</span><span style="color: #008000;">从起点出发，所以起点已经走过了，把它标记为1</span>
<span style="color: #008080;">3</span> recordY[<span style="color: #800080;">0</span>] = <span style="color: #800080;">0</span>; <span style="color: #008000;">//</span><span style="color: #008000;">先把起点所在的行保存下来</span>
<span style="color: #008080;">4</span> recordX[<span style="color: #800080;">0</span>] = <span style="color: #800080;">0</span>; <span style="color: #008000;">//</span><span style="color: #008000;">并把起点所在的列保存下来</span>
<span style="color: #008080;">5</span> dfs(<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>);   <span style="color: #008000;">//</span><span style="color: #008000;">从第0行，第0列，开始遍历图，当前步数是1</span>
<span style="color: #008080;">6</span> printf(<span style="color: #800000;">"</span><span style="color: #800000;">The minimum step is %d\n</span><span style="color: #800000;">"</span>, minStep);</pre>
</div>
<p>修改dfs函数：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">if</span> (tx &gt; -<span style="color: #800080;">1</span> &amp;&amp; tx &lt; <span style="color: #800080;">2</span> &amp;&amp; ty &gt; -<span style="color: #800080;">1</span> &amp;&amp; ty &lt; <span style="color: #800080;">3</span> &amp;&amp; book[ty][tx] != <span style="color: #800080;">1</span> &amp;&amp; map[ty][tx] != -<span style="color: #800080;">1</span><span style="color: #000000;">)
</span><span style="color: #008080;">2</span> { <span style="color: #008000;">//</span><span style="color: #008000;">这个点必须在图内，且没有被标记，还要是能能访问的点
</span><span style="color: #008080;">3</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> ...</span>
<span style="color: #008080;">4</span> }</pre>
</div>
<p>输出：<br />Traverse complete<br />step: 0, at y=0 and x=0<br />step: 1, at y=1 and x=0<br />step: 2, at y=2 and x=0<br />step: 3, at y=2 and x=1<br />The minimum step is 3</p>
<p>Process returned 0 (0x0)   execution time : 0.572 s<br />Press any key to continue.</p>
<p>PS：可以看出，map数组其实只在第8问中使用到了。</p>
<p>==主题结束==</p>]]></description></item><item><title>C语言实现整数转字符串</title><link>http://www.cnblogs.com/ryzz/archive/2020/02/07/12275236.html</link><dc:creator>RYZZ</dc:creator><author>RYZZ</author><pubDate>Fri, 07 Feb 2020 15:57:00 GMT</pubDate><guid>http://www.cnblogs.com/ryzz/archive/2020/02/07/12275236.html</guid><description><![CDATA[<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> #include &lt;stdio.h&gt;
<span style="color: #008080;"> 2</span> 
<span style="color: #008080;"> 3</span> <span style="color: #0000ff;">void</span> intToString(<span style="color: #0000ff;">int</span> N,<span style="color: #0000ff;">char</span><span style="color: #000000;"> arr[]){
</span><span style="color: #008080;"> 4</span>     <span style="color: #008000;">//</span><span style="color: #008000;">仅支持有符号4字节的int类型，范围-2147483648 - 2147483647</span>
<span style="color: #008080;"> 5</span>     <span style="color: #0000ff;">int</span><span style="color: #000000;"> i,j,flag;
</span><span style="color: #008080;"> 6</span>     <span style="color: #0000ff;">char</span> stack[<span style="color: #800080;">10</span>]; <span style="color: #008000;">//</span><span style="color: #008000;">栈，int的最值最多10位</span>
<span style="color: #008080;"> 7</span>     i=<span style="color: #800080;">0</span>; <span style="color: #008000;">//</span><span style="color: #008000;">计数器</span>
<span style="color: #008080;"> 8</span>     <span style="color: #0000ff;">if</span> (N&lt;<span style="color: #800080;">0</span><span style="color: #000000;">){
</span><span style="color: #008080;"> 9</span>         flag=<span style="color: #800080;">0</span>; <span style="color: #008000;">//</span><span style="color: #008000;">N是负数</span>
<span style="color: #008080;">10</span>         N=-<span style="color: #000000;">N;
</span><span style="color: #008080;">11</span>         <span style="color: #008000;">//</span><span style="color: #008000;">把N转为正数，注意，如果N是-2147483648，那么N=-N的结果还是-2147483648
</span><span style="color: #008080;">12</span>         <span style="color: #008000;">//</span><span style="color: #008000;">因为-N表达式将-2147483648转为2147483648，而2147483648对于4字节int来说是溢出的，这个溢出的数又变成了-2147483648
</span><span style="color: #008080;">13</span>         <span style="color: #008000;">//</span><span style="color: #008000;">这时，程序会计算异常
</span><span style="color: #008080;">14</span>         <span style="color: #008000;">//</span><span style="color: #008000;">解决方法，可以在函数开始时加个if语句，将这个值排除或当作特例</span>
<span style="color: #008080;">15</span>     }<span style="color: #0000ff;">else</span><span style="color: #000000;">{
</span><span style="color: #008080;">16</span>         flag=<span style="color: #800080;">1</span>; <span style="color: #008000;">//</span><span style="color: #008000;">N是正数</span>
<span style="color: #008080;">17</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">18</span>     <span style="color: #0000ff;">while</span> (N/<span style="color: #800080;">10</span>!=<span style="color: #800080;">0</span>){<span style="color: #008000;">//</span><span style="color: #008000;">说明N还不是一位数，继续拆</span>
<span style="color: #008080;">19</span>         stack[i]=(<span style="color: #0000ff;">char</span>)(<span style="color: #800080;">48</span>+N%<span style="color: #800080;">10</span>); <span style="color: #008000;">//</span><span style="color: #008000;">字符的1 - 数字的1 = 48，N%10获取N的个位数，并把转换后的字符入栈</span>
<span style="color: #008080;">20</span>         N=N/<span style="color: #800080;">10</span><span style="color: #000000;">;
</span><span style="color: #008080;">21</span>         i++<span style="color: #000000;">;
</span><span style="color: #008080;">22</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">23</span>     stack[i]=(<span style="color: #0000ff;">char</span>)(<span style="color: #800080;">48</span>+N); <span style="color: #008000;">//</span><span style="color: #008000;">当循环结束，N必定是一个一位数</span>
<span style="color: #008080;">24</span>     <span style="color: #0000ff;">if</span> (flag==<span style="color: #800080;">0</span>){<span style="color: #008000;">//</span><span style="color: #008000;">如果N是负数，需要在字符串最前面加负号</span>
<span style="color: #008080;">25</span>         arr[<span style="color: #800080;">0</span>]=<span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span><span style="color: #000000;">;
</span><span style="color: #008080;">26</span>         <span style="color: #0000ff;">for</span> (j=i;j&gt;-<span style="color: #800080;">1</span>;j--){<span style="color: #008000;">//</span><span style="color: #008000;">将栈中的字符出栈，j=i+1是因为数组arr的0元素已经保存负号了</span>
<span style="color: #008080;">27</span>             arr[i-j+<span style="color: #800080;">1</span>]=<span style="color: #000000;">stack[j];
</span><span style="color: #008080;">28</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">29</span>         arr[i+<span style="color: #800080;">2</span>]=<span style="color: #800000;">'</span><span style="color: #800000;">\0</span><span style="color: #800000;">'</span>; <span style="color: #008000;">//</span><span style="color: #008000;">添加字符串结束标志</span>
<span style="color: #008080;">30</span>     }<span style="color: #0000ff;">else</span><span style="color: #000000;">{
</span><span style="color: #008080;">31</span>         <span style="color: #0000ff;">for</span> (j=i;j&gt;-<span style="color: #800080;">1</span>;j--){<span style="color: #008000;">//</span><span style="color: #008000;">将栈中的字符出栈</span>
<span style="color: #008080;">32</span>             arr[i-j]=<span style="color: #000000;">stack[j];
</span><span style="color: #008080;">33</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">34</span>         arr[i+<span style="color: #800080;">1</span>]=<span style="color: #800000;">'</span><span style="color: #800000;">\0</span><span style="color: #800000;">'</span><span style="color: #000000;">;
</span><span style="color: #008080;">35</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">36</span> <span style="color: #000000;">}
</span><span style="color: #008080;">37</span> 
<span style="color: #008080;">38</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
</span><span style="color: #008080;">39</span>     <span style="color: #0000ff;">char</span> myarr[<span style="color: #800080;">15</span><span style="color: #000000;">];
</span><span style="color: #008080;">40</span>     <span style="color: #008000;">/*</span><span style="color: #008000;"> 测试 </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">41</span>     intToString(<span style="color: #800080;">15</span><span style="color: #000000;">,myarr);
</span><span style="color: #008080;">42</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">%s\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,myarr);
</span><span style="color: #008080;">43</span>     intToString(-<span style="color: #800080;">90</span><span style="color: #000000;">,myarr);
</span><span style="color: #008080;">44</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">%s\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,myarr);
</span><span style="color: #008080;">45</span>     intToString(<span style="color: #800080;">2147483647</span><span style="color: #000000;">,myarr);
</span><span style="color: #008080;">46</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">%s\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,myarr);
</span><span style="color: #008080;">47</span>     intToString(-<span style="color: #800080;">2147483647</span><span style="color: #000000;">,myarr);
</span><span style="color: #008080;">48</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">%s\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,myarr);
</span><span style="color: #008080;">49</span>     intToString(<span style="color: #800080;">0</span><span style="color: #000000;">,myarr);
</span><span style="color: #008080;">50</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">%s\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,myarr);
</span><span style="color: #008080;">51</span>     <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">52</span> }</pre>
</div>
<p>运行截图：</p>
<p><img src="https://img2018.cnblogs.com/i-beta/1326234/202002/1326234-20200207235602584-667923396.png" alt="" width="448" height="182" /></p>
<p>&nbsp;</p>]]></description></item><item><title>C语言scanf读取中文时一些注意事项</title><link>http://www.cnblogs.com/ryzz/archive/2020/02/06/.html</link><dc:creator>RYZZ</dc:creator><author>RYZZ</author><pubDate>Thu, 06 Feb 2020 11:23:00 GMT</pubDate><guid>http://www.cnblogs.com/ryzz/archive/2020/02/06/.html</guid><description><![CDATA[<p>下面程序所运行的命令行界面的编码是GBK<span style="font-family: 宋体;">（代码页：</span><span style="font-family: Calibri;">936 </span><span style="font-family: 宋体;">简体中文 </span><span style="font-family: Calibri;">GBK</span><span style="font-family: 宋体;">）</span></p>
<p>&nbsp;</p>
<p>char s[10];</p>
<p>scanf("%s",s);&nbsp;//<span style="font-family: 宋体;">输入&ldquo;你好啊&rdquo;，然后回车</span></p>
<p>printf("%s",s);&nbsp;//<span style="font-family: 宋体;">能正确输出&ldquo;你好啊&rdquo;</span></p>
<p><span style="font-family: 宋体;">使用调试工具查看</span>s<span style="font-family: 宋体;">所在的内存空间：</span></p>
<p>c4 e3 ba c3 b0 a1 00 00&nbsp;00 00</p>
<p><span style="font-family: 宋体;">百度查询可知</span>&ldquo;你好啊&rdquo;的<span style="font-family: Calibri;">GBK</span><span style="font-family: 宋体;">的编码是：</span></p>
<p><span style="font-family: 宋体;">你：</span>C4E3</p>
<p><span style="font-family: 宋体;">好：</span>BAC3</p>
<p><span style="font-family: 宋体;">啊：</span>B0A1</p>
<p><span style="font-family: 宋体;">发现和数组</span>s<span style="font-family: 宋体;">的前</span><span style="font-family: Calibri;">6</span><span style="font-family: 宋体;">个字节存储的值一样，由此可知，程序所运行的命令提示符支持哪种编码，那么</span><span style="font-family: Calibri;">C</span><span style="font-family: 宋体;">可以正确存储和输出这种编码的字符。</span></p>
<p>&nbsp;</p>
<p>char ch;</p>
<p>scanf("%c",&amp;ch); //<span style="font-family: 宋体;">输入&ldquo;你&rdquo;，然后回车</span></p>
<p><span style="font-family: 宋体;">使用调试器查看变量</span>ch<span style="font-family: 宋体;">所在的内存空间：</span><span style="font-family: Calibri;">c4</span></p>
<p>scanf<span style="font-family: 宋体;">的</span><span style="font-family: Calibri;">%c</span><span style="font-family: 宋体;">表示读取一个字符，更确切的说是读取输入缓冲区的一个字节。</span></p>
<p>&nbsp;</p>
<p>int ch;</p>
<p>scanf("%c",&amp;ch);&nbsp;//<span style="font-family: 宋体;">输入&ldquo;你&rdquo;，然后回车</span></p>
<p><span style="font-family: 宋体;">使用调试器查看变量</span>ch<span style="font-family: 宋体;">所在的内存空间：</span><span style="font-family: Calibri;">c4 00 00 00</span></p>
<p><span style="font-family: 宋体;">虽然</span>int<span style="font-family: 宋体;">占</span><span style="font-family: Calibri;">4</span><span style="font-family: 宋体;">个字节，但是</span><span style="font-family: Calibri;">scanf</span><span style="font-family: 宋体;">的</span><span style="font-family: Calibri;">%c</span><span style="font-family: 宋体;">只读取一个字符（字节），所以把读取的</span><span style="font-family: Calibri;">0xc4</span><span style="font-family: 宋体;">赋值给整型变量</span><span style="font-family: Calibri;">ch</span><span style="font-family: 宋体;">，</span><span style="font-family: Calibri;">ch</span><span style="font-family: 宋体;">的值就是</span><span style="font-family: Calibri;">0xc4</span><span style="font-family: 宋体;">，而内存是小端表示，便是</span><span style="font-family: Calibri;">c4 00 00 00</span></p>
<p><span style="font-family: 宋体;">同时，上面的</span>scanf<span style="font-family: 宋体;">会出现编译时警告：</span><span style="font-family: Calibri;">warning: format '%c' expects argument of type 'char *', but argument 2 has type 'int *' [-Wformat=]</span></p>]]></description></item><item><title>typedef声明变量也是一种求值过程</title><link>http://www.cnblogs.com/ryzz/archive/2020/01/26/12233761.html</link><dc:creator>RYZZ</dc:creator><author>RYZZ</author><pubDate>Sun, 26 Jan 2020 01:26:00 GMT</pubDate><guid>http://www.cnblogs.com/ryzz/archive/2020/01/26/12233761.html</guid><description><![CDATA[<p><span style="font-size: 14pt;"><strong>前言：</strong></span></p>
<p>什么叫做：声明变量是求值过程？请看下面的声明，</p>
<p>int i;</p>
<p>很简单，声明了个整型变量i，再看如下声明，</p>
<p>int *p;</p>
<p>也很简单，立刻反应出来它是指向整型的指针，但是具体如何推倒出来的呢？其实在C语言中，变量的声明就是一种求值过程，把*p这部分声明看成表达式，对这个表达式的求值的结果是int类型，这样就可以倒推出p是指针整型的指针了，因为只有对指向整型的指针进行解引用操作才是整型类型！还有很多复杂的声明，都可以使用这种方法求其具体的类型。</p>
<p><strong><span style="font-size: 14pt;">下面让我们来验证typedef定义的新类型和普通的声明变量一样，也是一种求值过程：</span></strong></p>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span>
<span style="color: #008080;"> 2</span> <span style="color: #008000;">验证：
</span><span style="color: #008080;"> 3</span> <span style="color: #008000;">用typedef定义的新类型名声明的变量是否与普通的声明变量一样，是一种求值的过程，还是单纯的替换过程？
</span><span style="color: #008080;"> 4</span> <span style="color: #008000;">*/</span>
<span style="color: #008080;"> 5</span> 
<span style="color: #008080;"> 6</span> typedef <span style="color: #0000ff;">short</span> <span style="color: #0000ff;">int</span> arrTen[<span style="color: #800080;">10</span>]; <span style="color: #008000;">//</span><span style="color: #008000;">定义了一个新类型，这个类型是：一个包含10个short类型元素的一维数组</span>
<span style="color: #008080;"> 7</span> 
<span style="color: #008080;"> 8</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
</span><span style="color: #008080;"> 9</span>     <span style="color: #0000ff;">short</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> j;
</span><span style="color: #008080;">10</span>     <span style="color: #0000ff;">short</span> <span style="color: #0000ff;">int</span> myarr[<span style="color: #800080;">10</span><span style="color: #000000;">];
</span><span style="color: #008080;">11</span>     arrTen *<span style="color: #000000;">arr1;
</span><span style="color: #008080;">12</span>     <span style="color: #008000;">/*</span>
<span style="color: #008080;">13</span> <span style="color: #008000;">    现在需要验证arr1的类型：
</span><span style="color: #008080;">14</span> <span style="color: #008000;">    假设是求值过程，那么意味着对表达式*arr1求值的结果是arrTen类型，也就是说arr1是一个指针，指向一个数组，但是在C语言中数组是一个很朴素的概念，它只是连续的内存单元，所以指向一个数组准确地说是指向一片拥有10个short元素的内存空间
</span><span style="color: #008080;">15</span> <span style="color: #008000;">    假设是替换过程，那么上述声明相当于：short int *arrTen[10]，而这个声明意味着arrTen是一个拥有10个元素的数组，每个元素的类型是指针，指向short类型的内存单元，在这里发现了问题，如果声明（用typedef定义(或声明)新类型时和用typedef声明变量时）用到了很多操作符，替换过程就会出现优先级的失调，所以在此猜测这种假设是错的
</span><span style="color: #008080;">16</span>     <span style="color: #008000;">*/</span>
<span style="color: #008080;">17</span> 
<span style="color: #008080;">18</span>     <span style="color: #008000;">/*</span><span style="color: #008000;"> 实际操作验证 </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">19</span>     <span style="color: #008000;">//</span><span style="color: #008000;">arr1[1]=&amp;j; </span><span style="color: #008000;">//</span><span style="color: #008000;">报错，GCC5.2:error: assignment to expression with array type</span>
<span style="color: #008080;">20</span>     arr1=&amp;myarr; <span style="color: #008000;">//</span><span style="color: #008000;">未报错，myarr的类型是一个指向short的指针，而&amp;myarr的类型是一个指向拥有10个short元素的数组的指针</span>
<span style="color: #008080;">21</span>     <span style="color: #008000;">/*</span><span style="color: #008000;"> 综上，arr1是一个指向数组的指针，所以第一种假设成立，typedef声明变量时也是一种求值过程 </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">22</span> 
<span style="color: #008080;">23</span>     <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">24</span> }</pre>
</div>]]></description></item><item><title>队列的链式存储结构（C语言实现）</title><link>http://www.cnblogs.com/ryzz/archive/2020/01/24/12232423.html</link><dc:creator>RYZZ</dc:creator><author>RYZZ</author><pubDate>Fri, 24 Jan 2020 09:45:00 GMT</pubDate><guid>http://www.cnblogs.com/ryzz/archive/2020/01/24/12232423.html</guid><description><![CDATA[<div class="cnblogs_code">
<pre><span style="color: #008080;">  1</span> #include &lt;stdio.h&gt;
<span style="color: #008080;">  2</span> #include &lt;stdlib.h&gt;
<span style="color: #008080;">  3</span> 
<span style="color: #008080;">  4</span> <span style="color: #0000ff;">#define</span> OK 1
<span style="color: #008080;">  5</span> <span style="color: #0000ff;">#define</span> ERR 2
<span style="color: #008080;">  6</span> <span style="color: #0000ff;">#define</span> TRUE 1
<span style="color: #008080;">  7</span> <span style="color: #0000ff;">#define</span> FALSE 0
<span style="color: #008080;">  8</span> 
<span style="color: #008080;">  9</span> typedef <span style="color: #0000ff;">int</span> status; <span style="color: #008000;">//</span><span style="color: #008000;">定义函数返回的状态，OK &amp; ERR</span>
<span style="color: #008080;"> 10</span> typedef <span style="color: #0000ff;">char</span> datatype; <span style="color: #008000;">//</span><span style="color: #008000;">定义队列中每个元素的数据类型，这里暂定为字符型</span>
<span style="color: #008080;"> 11</span> 
<span style="color: #008080;"> 12</span> typedef <span style="color: #0000ff;">struct</span><span style="color: #000000;"> LinkQueue_anon{
</span><span style="color: #008080;"> 13</span>     datatype data; <span style="color: #008000;">//</span><span style="color: #008000;">数据区</span>
<span style="color: #008080;"> 14</span>     <span style="color: #0000ff;">struct</span> LinkQueue_anon * next; <span style="color: #008000;">//</span><span style="color: #008000;">指针区</span>
<span style="color: #008080;"> 15</span> <span style="color: #000000;">} LinkQueue;
</span><span style="color: #008080;"> 16</span> typedef <span style="color: #0000ff;">struct</span><span style="color: #000000;"> {
</span><span style="color: #008080;"> 17</span>     LinkQueue * front, *<span style="color: #000000;"> rear;
</span><span style="color: #008080;"> 18</span>     <span style="color: #008000;">/*</span>
<span style="color: #008080;"> 19</span> <span style="color: #008000;">    创建队列的游标，保存着队列的头尾指针所指向的结点
</span><span style="color: #008080;"> 20</span> <span style="color: #008000;">    front指向队列的第一个结点（队头），rear指向队列的最后一个结点（队尾）
</span><span style="color: #008080;"> 21</span> <span style="color: #008000;">    规定：
</span><span style="color: #008080;"> 22</span> <span style="color: #008000;">        当front=rear=NULL时，表示队列为空
</span><span style="color: #008080;"> 23</span> <span style="color: #008000;">        当front=rear!=NULL时，表示队列只有一个元素
</span><span style="color: #008080;"> 24</span>     <span style="color: #008000;">*/</span>
<span style="color: #008080;"> 25</span> <span style="color: #000000;">}LinkQueueCursor;
</span><span style="color: #008080;"> 26</span> 
<span style="color: #008080;"> 27</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> 函数原型，队列的基本操作，与栈相同 </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 28</span> LinkQueueCursor *<span style="color: #000000;">createLinkQueue(datatype first_node_value);
</span><span style="color: #008080;"> 29</span> status isEmpty(LinkQueueCursor *<span style="color: #000000;">L);
</span><span style="color: #008080;"> 30</span> <span style="color: #0000ff;">void</span> clear(LinkQueueCursor *<span style="color: #000000;">L);
</span><span style="color: #008080;"> 31</span> datatype getTop(LinkQueueCursor *<span style="color: #000000;">L);
</span><span style="color: #008080;"> 32</span> <span style="color: #0000ff;">int</span> getLength(LinkQueueCursor *<span style="color: #000000;">L);
</span><span style="color: #008080;"> 33</span> status push(LinkQueueCursor *<span style="color: #000000;">L, datatype node_to_push);
</span><span style="color: #008080;"> 34</span> datatype pop(LinkQueueCursor *<span style="color: #000000;">L);
</span><span style="color: #008080;"> 35</span> <span style="color: #0000ff;">void</span> showQueue(LinkQueueCursor *<span style="color: #000000;">L);
</span><span style="color: #008080;"> 36</span> 
<span style="color: #008080;"> 37</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
</span><span style="color: #008080;"> 38</span>     <span style="color: #008000;">/*</span><span style="color: #008000;"> 测试 </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 39</span>     LinkQueueCursor *<span style="color: #000000;"> mycursor;
</span><span style="color: #008080;"> 40</span>     mycursor=createLinkQueue(<span style="color: #800000;">'</span><span style="color: #800000;">1</span><span style="color: #800000;">'</span>); <span style="color: #008000;">//</span><span style="color: #008000;">创建一个游标，同时入队一个元素，其值为'1'</span>
<span style="color: #008080;"> 41</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">isEmpty = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,isEmpty(mycursor));
</span><span style="color: #008080;"> 42</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">Length = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,getLength(mycursor));
</span><span style="color: #008080;"> 43</span>     push(mycursor,<span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 44</span>     push(mycursor,<span style="color: #800000;">'</span><span style="color: #800000;">b</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 45</span>     push(mycursor,<span style="color: #800000;">'</span><span style="color: #800000;">c</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 46</span>     push(mycursor,<span style="color: #800000;">'</span><span style="color: #800000;">d</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 47</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">isEmpty = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,isEmpty(mycursor));
</span><span style="color: #008080;"> 48</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">Length = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,getLength(mycursor));
</span><span style="color: #008080;"> 49</span> <span style="color: #000000;">    showQueue(mycursor);
</span><span style="color: #008080;"> 50</span>     putchar(<span style="color: #800000;">'</span><span style="color: #800000;">\n</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 51</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">pop = %c\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,pop(mycursor));
</span><span style="color: #008080;"> 52</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">pop = %c\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,pop(mycursor));
</span><span style="color: #008080;"> 53</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">getTop = %c\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,getTop(mycursor));
</span><span style="color: #008080;"> 54</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">isEmpty = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,isEmpty(mycursor));
</span><span style="color: #008080;"> 55</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">Length = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,getLength(mycursor));
</span><span style="color: #008080;"> 56</span> <span style="color: #000000;">    showQueue(mycursor);
</span><span style="color: #008080;"> 57</span>     putchar(<span style="color: #800000;">'</span><span style="color: #800000;">\n</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 58</span> <span style="color: #000000;">    clear(mycursor);
</span><span style="color: #008080;"> 59</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">isEmpty = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,isEmpty(mycursor));
</span><span style="color: #008080;"> 60</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">Length = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,getLength(mycursor));
</span><span style="color: #008080;"> 61</span> 
<span style="color: #008080;"> 62</span>     <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 63</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 64</span> 
<span style="color: #008080;"> 65</span> LinkQueueCursor *<span style="color: #000000;">createLinkQueue(datatype first_node_value){
</span><span style="color: #008080;"> 66</span>     LinkQueueCursor *<span style="color: #000000;">tmp_cur;
</span><span style="color: #008080;"> 67</span>     LinkQueue *<span style="color: #000000;">tmp;
</span><span style="color: #008080;"> 68</span>     tmp_cur=<span style="color: #0000ff;">malloc</span>(<span style="color: #0000ff;">sizeof</span>(LinkQueueCursor)); <span style="color: #008000;">//</span><span style="color: #008000;">void*类型指针能自动转为其他类型的指针</span>
<span style="color: #008080;"> 69</span>     tmp=<span style="color: #0000ff;">malloc</span>(<span style="color: #0000ff;">sizeof</span><span style="color: #000000;">(LinkQueue));
</span><span style="color: #008080;"> 70</span>     tmp_cur-&gt;front=tmp_cur-&gt;rear=tmp; <span style="color: #008000;">//</span><span style="color: #008000;">初始化游标</span>
<span style="color: #008080;"> 71</span>     tmp-&gt;data=first_node_value; <span style="color: #008000;">//</span><span style="color: #008000;">初始化数据区</span>
<span style="color: #008080;"> 72</span>     tmp-&gt;next=NULL; <span style="color: #008000;">//</span><span style="color: #008000;">初始化指针区</span>
<span style="color: #008080;"> 73</span>     <span style="color: #0000ff;">return</span><span style="color: #000000;"> tmp_cur;
</span><span style="color: #008080;"> 74</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 75</span> status isEmpty(LinkQueueCursor *<span style="color: #000000;">L){
</span><span style="color: #008080;"> 76</span>     <span style="color: #0000ff;">if</span> (L-&gt;front==L-&gt;rear &amp;&amp; L-&gt;front==<span style="color: #000000;">NULL)
</span><span style="color: #008080;"> 77</span>         <span style="color: #0000ff;">return</span><span style="color: #000000;"> TRUE;
</span><span style="color: #008080;"> 78</span>     <span style="color: #0000ff;">else</span>
<span style="color: #008080;"> 79</span>         <span style="color: #0000ff;">return</span><span style="color: #000000;"> FALSE;
</span><span style="color: #008080;"> 80</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 81</span> <span style="color: #0000ff;">void</span> clear(LinkQueueCursor *<span style="color: #000000;">L){
</span><span style="color: #008080;"> 82</span>     LinkQueue * p,*<span style="color: #000000;"> q;
</span><span style="color: #008080;"> 83</span>     <span style="color: #0000ff;">if</span> (isEmpty(L)) <span style="color: #0000ff;">return</span>; <span style="color: #008000;">//</span><span style="color: #008000;">空队列，不需要clear，所以直接返回</span>
<span style="color: #008080;"> 84</span>     <span style="color: #0000ff;">if</span> (L-&gt;front==L-&gt;rear &amp;&amp; L-&gt;front!=NULL){ <span style="color: #008000;">//</span><span style="color: #008000;">只有一个元素的队列，front和rear都指向这个元素</span>
<span style="color: #008080;"> 85</span>         <span style="color: #0000ff;">free</span>(L-&gt;<span style="color: #000000;">front);
</span><span style="color: #008080;"> 86</span>         L-&gt;front=L-&gt;rear=NULL; <span style="color: #008000;">//</span><span style="color: #008000;">把队列设为空</span>
<span style="color: #008080;"> 87</span>         <span style="color: #0000ff;">return</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 88</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 89</span>     <span style="color: #008000;">/*</span><span style="color: #008000;"> 当队列的元素大于1时 </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 90</span>     p=L-&gt;front; <span style="color: #008000;">//</span><span style="color: #008000;">p指向当前要被删除的结点</span>
<span style="color: #008080;"> 91</span>     <span style="color: #0000ff;">while</span><span style="color: #000000;"> (p){
</span><span style="color: #008080;"> 92</span>         <span style="color: #008000;">//</span><span style="color: #008000;">当p不为NULL继续循环</span>
<span style="color: #008080;"> 93</span>         q=p-&gt;next; <span style="color: #008000;">//</span><span style="color: #008000;">q指向p的下一个结点</span>
<span style="color: #008080;"> 94</span>         <span style="color: #0000ff;">free</span><span style="color: #000000;">(p);
</span><span style="color: #008080;"> 95</span>         p=q; <span style="color: #008000;">//</span><span style="color: #008000;">交换</span>
<span style="color: #008080;"> 96</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 97</span>     L-&gt;front=L-&gt;rear=NULL; <span style="color: #008000;">//</span><span style="color: #008000;">把队列设为空</span>
<span style="color: #008080;"> 98</span> 
<span style="color: #008080;"> 99</span> <span style="color: #000000;">}
</span><span style="color: #008080;">100</span> datatype getTop(LinkQueueCursor *<span style="color: #000000;">L){
</span><span style="color: #008080;">101</span>     <span style="color: #0000ff;">return</span> L-&gt;front-&gt;data; <span style="color: #008000;">//</span><span style="color: #008000;">直接返回队头的数据即可</span>
<span style="color: #008080;">102</span> <span style="color: #000000;">}
</span><span style="color: #008080;">103</span> <span style="color: #0000ff;">int</span> getLength(LinkQueueCursor *<span style="color: #000000;">L){
</span><span style="color: #008080;">104</span>     <span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">105</span>     LinkQueue *<span style="color: #000000;"> p;
</span><span style="color: #008080;">106</span>     <span style="color: #0000ff;">if</span> (isEmpty(L)) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span>; <span style="color: #008000;">//</span><span style="color: #008000;">空队列，返回0</span>
<span style="color: #008080;">107</span>     <span style="color: #0000ff;">if</span> (L-&gt;front==L-&gt;rear &amp;&amp; L-&gt;front!=NULL) <span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span>; <span style="color: #008000;">//</span><span style="color: #008000;">规定：front=rear，说明队列只有一个元素</span>
<span style="color: #008080;">108</span>     <span style="color: #008000;">/*</span><span style="color: #008000;"> 队列的长度大于1时 </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">109</span>     p=L-&gt;<span style="color: #000000;">front;
</span><span style="color: #008080;">110</span>     <span style="color: #0000ff;">while</span> (p!=L-&gt;rear){ <span style="color: #008000;">//</span><span style="color: #008000;">还没到rear（队尾）则继续循环</span>
<span style="color: #008080;">111</span>         i++; p=p-&gt;<span style="color: #000000;">next;
</span><span style="color: #008080;">112</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">113</span>     <span style="color: #0000ff;">return</span> i+<span style="color: #800080;">1</span><span style="color: #000000;">;
</span><span style="color: #008080;">114</span>     <span style="color: #008000;">/*</span>
<span style="color: #008080;">115</span> <span style="color: #008000;">    上面的【队列的长度大于1时】还能用下面的等价代码代替
</span><span style="color: #008080;">116</span> <span style="color: #008000;">    p=L-&gt;front;
</span><span style="color: #008080;">117</span> <span style="color: #008000;">    while (p){ //p不为NULL则继续循环，因为rear（队尾）结点的next（指针区）一定是NULL
</span><span style="color: #008080;">118</span> <span style="color: #008000;">        i++; p=p-&gt;next;
</span><span style="color: #008080;">119</span> <span style="color: #008000;">    }
</span><span style="color: #008080;">120</span> <span style="color: #008000;">    return i;
</span><span style="color: #008080;">121</span>     <span style="color: #008000;">*/</span>
<span style="color: #008080;">122</span> <span style="color: #000000;">}
</span><span style="color: #008080;">123</span> status push(LinkQueueCursor *<span style="color: #000000;">L, datatype node_to_push){
</span><span style="color: #008080;">124</span>     <span style="color: #008000;">//</span><span style="color: #008000;">node_to_insert表示想要在队尾处入队的元素</span>
<span style="color: #008080;">125</span>     LinkQueue * s=<span style="color: #0000ff;">malloc</span>(<span style="color: #0000ff;">sizeof</span><span style="color: #000000;">(LinkQueue));
</span><span style="color: #008080;">126</span>     s-&gt;data=node_to_push; <span style="color: #008000;">//</span><span style="color: #008000;">初始化新入队的元素</span>
<span style="color: #008080;">127</span>     s-&gt;next=<span style="color: #000000;">NULL;
</span><span style="color: #008080;">128</span>     <span style="color: #0000ff;">if</span> (isEmpty(L)==<span style="color: #000000;">TRUE){
</span><span style="color: #008080;">129</span>         <span style="color: #008000;">//</span><span style="color: #008000;">插入到空队列</span>
<span style="color: #008080;">130</span>         L-&gt;front=L-&gt;rear=s; <span style="color: #008000;">//</span><span style="color: #008000;">入队，当队列只有一个元素时，规定front和rear都指向这个元素</span>
<span style="color: #008080;">131</span>     }<span style="color: #0000ff;">else</span><span style="color: #000000;">{
</span><span style="color: #008080;">132</span>         <span style="color: #008000;">//</span><span style="color: #008000;">插入到已存在元素的队列</span>
<span style="color: #008080;">133</span>         L-&gt;rear-&gt;next=s; <span style="color: #008000;">//</span><span style="color: #008000;">入队，将新元素附在rear指向的结点的后面</span>
<span style="color: #008080;">134</span>         L-&gt;rear=s; <span style="color: #008000;">//</span><span style="color: #008000;">rear后移，即将它指向新元素</span>
<span style="color: #008080;">135</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">136</span>     <span style="color: #0000ff;">return</span><span style="color: #000000;"> OK;
</span><span style="color: #008080;">137</span> <span style="color: #000000;">}
</span><span style="color: #008080;">138</span> datatype pop(LinkQueueCursor *<span style="color: #000000;">L){
</span><span style="color: #008080;">139</span>     <span style="color: #008000;">//</span><span style="color: #008000;">出队，即将队头删除</span>
<span style="color: #008080;">140</span> <span style="color: #000000;">    datatype v;
</span><span style="color: #008080;">141</span>     LinkQueue *<span style="color: #000000;"> s;
</span><span style="color: #008080;">142</span>     <span style="color: #0000ff;">if</span> (isEmpty(L)) <span style="color: #0000ff;">return</span> (datatype)ERR; <span style="color: #008000;">//</span><span style="color: #008000;">空队列</span>
<span style="color: #008080;">143</span>     <span style="color: #0000ff;">if</span> (L-&gt;front==L-&gt;rear &amp;&amp; L-&gt;front!=NULL){ <span style="color: #008000;">//</span><span style="color: #008000;">队列只有一个元素</span>
<span style="color: #008080;">144</span>         v=L-&gt;front-&gt;data; <span style="color: #008000;">//</span><span style="color: #008000;">把这个元素的值赋值给临时变量</span>
<span style="color: #008080;">145</span>         <span style="color: #0000ff;">free</span>(L-&gt;front); <span style="color: #008000;">//</span><span style="color: #008000;">删除这个元素</span>
<span style="color: #008080;">146</span>         L-&gt;front=L-&gt;rear=NULL; <span style="color: #008000;">//</span><span style="color: #008000;">把队列设置为空</span>
<span style="color: #008080;">147</span>     }<span style="color: #0000ff;">else</span><span style="color: #000000;">{
</span><span style="color: #008080;">148</span>         v=L-&gt;front-&gt;data; <span style="color: #008000;">//</span><span style="color: #008000;">将要删除的元素的值先赋值给临时变量</span>
<span style="color: #008080;">149</span>         s=L-&gt;front; <span style="color: #008000;">//</span><span style="color: #008000;">将要删除的元素先赋值给临时变量</span>
<span style="color: #008080;">150</span>         L-&gt;front=L-&gt;front-&gt;next; <span style="color: #008000;">//</span><span style="color: #008000;">将游标所保存的front后移到下个结点（元素）</span>
<span style="color: #008080;">151</span>         <span style="color: #0000ff;">free</span>(s); <span style="color: #008000;">//</span><span style="color: #008000;">删除原来的头结点（元素）</span>
<span style="color: #008080;">152</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">153</span>     <span style="color: #0000ff;">return</span> v; <span style="color: #008000;">//</span><span style="color: #008000;">返回出队结点（元素）的值</span>
<span style="color: #008080;">154</span> <span style="color: #000000;">}
</span><span style="color: #008080;">155</span> <span style="color: #0000ff;">void</span> showQueue(LinkQueueCursor *<span style="color: #000000;">L){
</span><span style="color: #008080;">156</span>     <span style="color: #0000ff;">int</span><span style="color: #000000;"> i;
</span><span style="color: #008080;">157</span>     <span style="color: #0000ff;">int</span> total=<span style="color: #000000;">getLength(L);
</span><span style="color: #008080;">158</span>     LinkQueue *<span style="color: #000000;"> p;
</span><span style="color: #008080;">159</span>     p=L-&gt;<span style="color: #000000;">front;
</span><span style="color: #008080;">160</span>     <span style="color: #0000ff;">for</span> (i=<span style="color: #800080;">0</span>; i&lt;total; i++<span style="color: #000000;">){
</span><span style="color: #008080;">161</span>         printf(<span style="color: #800000;">"</span><span style="color: #800000;">%c\t</span><span style="color: #800000;">"</span>,p-&gt;data); p=p-&gt;<span style="color: #000000;">next;
</span><span style="color: #008080;">162</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">163</span> <span style="color: #000000;">}
</span><span style="color: #008080;">164</span> <span style="color: #008000;">/*</span>
<span style="color: #008080;">165</span> <span style="color: #008000;">    队列的定义：只允许在一端进行插入，另一端进行删除的线性表，也是一种操作受限的线性表
</span><span style="color: #008080;">166</span> <span style="color: #008000;">    一般，把允许插入的一端叫做队尾，允许删除的一端叫做队头
</span><span style="color: #008080;">167</span> <span style="color: #008000;">    不含任何元素的队列就是空队
</span><span style="color: #008080;">168</span> <span style="color: #008000;">    所以，队列又称先进先出(First in First out)的线性表
</span><span style="color: #008080;">169</span> <span style="color: #008000;">    队列的链式存储其实就是线性表中的单链表，只不过它只能尾进头出
</span><span style="color: #008080;">170</span> <span style="color: #008000;">*/</span>
<span style="color: #008080;">171</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> 环境: Code::Blocks with GCC 5.1 </span><span style="color: #008000;">*/</span></pre>
</div>
<p>运行截图：</p>
<p><img src="https://img2018.cnblogs.com/i-beta/1326234/202001/1326234-20200124174506770-603016281.png" alt="" width="470" height="314" /></p>
<p>&nbsp;</p>]]></description></item><item><title>队列的顺序存储结构（循环队列）（C语言实现）</title><link>http://www.cnblogs.com/ryzz/archive/2020/01/23/12230920.html</link><dc:creator>RYZZ</dc:creator><author>RYZZ</author><pubDate>Thu, 23 Jan 2020 09:43:00 GMT</pubDate><guid>http://www.cnblogs.com/ryzz/archive/2020/01/23/12230920.html</guid><description><![CDATA[<div class="cnblogs_code">
<pre><span style="color: #008080;">  1</span> #include &lt;stdio.h&gt;
<span style="color: #008080;">  2</span> #include &lt;stdlib.h&gt;
<span style="color: #008080;">  3</span> 
<span style="color: #008080;">  4</span> <span style="color: #0000ff;">#define</span> OK 1
<span style="color: #008080;">  5</span> <span style="color: #0000ff;">#define</span> ERR 2
<span style="color: #008080;">  6</span> <span style="color: #0000ff;">#define</span> TRUE 1
<span style="color: #008080;">  7</span> <span style="color: #0000ff;">#define</span> FALSE 0
<span style="color: #008080;">  8</span> <span style="color: #0000ff;">#define</span> MAXSIZE 4 <span style="color: #008000;">//</span><span style="color: #008000;">定义队列的最大长度</span>
<span style="color: #008080;">  9</span> 
<span style="color: #008080;"> 10</span> typedef <span style="color: #0000ff;">int</span> status; <span style="color: #008000;">//</span><span style="color: #008000;">定义函数返回的状态，OK &amp; ERR</span>
<span style="color: #008080;"> 11</span> typedef <span style="color: #0000ff;">char</span> datatype; <span style="color: #008000;">//</span><span style="color: #008000;">定义队列中每个元素的数据类型，这里暂定为字符型</span>
<span style="color: #008080;"> 12</span> 
<span style="color: #008080;"> 13</span> typedef <span style="color: #0000ff;">struct</span><span style="color: #000000;"> {
</span><span style="color: #008080;"> 14</span>     datatype data[MAXSIZE]; <span style="color: #008000;">//</span><span style="color: #008000;">存储着队列中的每个元素</span>
<span style="color: #008080;"> 15</span>     <span style="color: #0000ff;">int</span> front, rear; <span style="color: #008000;">//</span><span style="color: #008000;">头指针和尾指针</span>
<span style="color: #008080;"> 16</span>     <span style="color: #008000;">/*</span>
<span style="color: #008080;"> 17</span> <span style="color: #008000;">    假设用于模拟队列的数组长度为8，规定入队和出队方向都向左（即下标0的元素始终用于出队），有一个指针end永远标识队尾元素的下标，当end=0时表示队列只有一个元素，当end=-1时标识队列为空，类似于栈的top指针，
</span><span style="color: #008080;"> 18</span> <span style="color: #008000;">    现在入队3个元素，数组如下，
</span><span style="color: #008080;"> 19</span> <span style="color: #008000;">    A B C _ _ _ _ _ 指针end=2
</span><span style="color: #008080;"> 20</span> <span style="color: #008000;">    出队1个元素，即下标是0的元素出队，也就是A，
</span><span style="color: #008080;"> 21</span> <span style="color: #008000;">    _ B C _ _ _ _ _ 指针end=2
</span><span style="color: #008080;"> 22</span> <span style="color: #008000;">    这时下标0的元素为空，需要将后面的元素都前移，然后将指针end-1，如果队列很长，这个操作会带来很大开销，所以我们不应该用栈的固定思维去思考队列，也就是说队头不一定要在下标为0的位置，
</span><span style="color: #008080;"> 23</span> <span style="color: #008000;">    这样一来我们定义一个指针front用来表示队头所在元素的下标，再定义一个指针rear用来表示队尾所在元素的下一个元素的下标，当front=rear时表示队列为空，这就是队列的初始状态，
</span><span style="color: #008080;"> 24</span> <span style="color: #008000;">    现在我们用上述队列的存储结构来创建一个新队列，
</span><span style="color: #008080;"> 25</span> <span style="color: #008000;">    _ _ _ _ _ _ _ _ 指针front=0 指针rear=0
</span><span style="color: #008080;"> 26</span> <span style="color: #008000;">    入队3个元素，
</span><span style="color: #008080;"> 27</span> <span style="color: #008000;">    A B C _ _ _ _ _ 指针front=0 指针rear=3
</span><span style="color: #008080;"> 28</span> <span style="color: #008000;">    出队1个元素，
</span><span style="color: #008080;"> 29</span> <span style="color: #008000;">    _ B C _ _ _ _ _ 指针front=1 指针rear=3
</span><span style="color: #008080;"> 30</span> <span style="color: #008000;">    再入队3个元素，
</span><span style="color: #008080;"> 31</span> <span style="color: #008000;">    _ B C D E F _ _ 指针front=1 指针rear=6
</span><span style="color: #008080;"> 32</span> <span style="color: #008000;">    再出队3个元素，
</span><span style="color: #008080;"> 33</span> <span style="color: #008000;">    _ _ _ _ E F _ _ 指针front=4 指针rear=6
</span><span style="color: #008080;"> 34</span> <span style="color: #008000;">    可见新定义的队列的存储结构不需要大量前移元素了（因为队头元素由指针front唯一确定），这样，入队只需要rear+1，出队只需要front+1，
</span><span style="color: #008080;"> 35</span> <span style="color: #008000;">    但是又出现了个很严重的问题：当继续入队2个（G和H）元素，H元素便成为数组的最后一个元素，此时rear=8，而下标为8的位置是越界的，而数组最前面的下标（0~3，共4个）却空着，就造成了浪费，这种现象叫做假溢出，
</span><span style="color: #008080;"> 36</span> <span style="color: #008000;">    要解决上述问题，可将队列的头和尾相连，使之成为循环队列，
</span><span style="color: #008080;"> 37</span> <span style="color: #008000;">    当数组的最后一个元素也被使用了，此时可将rear等于0而不是8，
</span><span style="color: #008080;"> 38</span> <span style="color: #008000;">    _ _ _ _ E F G H 指针front=4 指针rear=0
</span><span style="color: #008080;"> 39</span> <span style="color: #008000;">    这时，再入队3个元素，数组如下，
</span><span style="color: #008080;"> 40</span> <span style="color: #008000;">    I J K _ E F G H 指针front=4 指针rear=3
</span><span style="color: #008080;"> 41</span> <span style="color: #008000;">    我们将循环队列的这种情况称为队列已满（rear和front之间空一个元素），不然再入队一个元素（L），那么rear=4，和front相等了，这时是空队列呢还是满队列呢？
</span><span style="color: #008080;"> 42</span> <span style="color: #008000;">    循环队列已满的条件：(rear+1)%QueueSize == front
</span><span style="color: #008080;"> 43</span> <span style="color: #008000;">    循环队列长度公式：(rear-front+QueueSize)%QueueSize
</span><span style="color: #008080;"> 44</span> <span style="color: #008000;">    入队（rear后移一位）：rear=(rear+1)%QueueSize
</span><span style="color: #008080;"> 45</span> <span style="color: #008000;">    出队（front后移一位）：front=(front+1)%QueueSize
</span><span style="color: #008080;"> 46</span> <span style="color: #008000;">    其中QueueSize是队列的最大长度（数组的长度），比如上面演示的队列的QueueSize就是8
</span><span style="color: #008080;"> 47</span> <span style="color: #008000;">    循环队列长度公式的由来，（以下讨论的数都是整数）
</span><span style="color: #008080;"> 48</span> <span style="color: #008000;">    当rear&gt;front时，队列的长度：rear-front，其中rear-front必然是正数
</span><span style="color: #008080;"> 49</span> <span style="color: #008000;">    当rear&lt;front时，队列的长度由两部分组成，
</span><span style="color: #008080;"> 50</span> <span style="color: #008000;">        第一部分是（空元素的后面）：QueueSize-front
</span><span style="color: #008080;"> 51</span> <span style="color: #008000;">        第二部分是（空元素的前面）：0+rear
</span><span style="color: #008080;"> 52</span> <span style="color: #008000;">        综上，队列的长度：rear-front+QueueSize，其中rear-front必然是负数
</span><span style="color: #008080;"> 53</span> <span style="color: #008000;">    如果rear-front+QueueSize这个公式用于rear&gt;front的队列，那么得到的队列长度就大于数组的最大长度（QueueSize），
</span><span style="color: #008080;"> 54</span> <span style="color: #008000;">    那到底大了多少呢，其实就是大了QueueSize，但我们又不能减去QueueSize，这样就不能计算rear&lt;front的队列长度，
</span><span style="color: #008080;"> 55</span> <span style="color: #008000;">    正确解决方法是对rear-front+QueueSize取余，模数是QueueSize，即(rear-front+QueueSize)%QueueSize，
</span><span style="color: #008080;"> 56</span> <span style="color: #008000;">    这样，
</span><span style="color: #008080;"> 57</span> <span style="color: #008000;">    对于rear&gt;front，虽然先加上了QueueSize，但最后的结果模上了QueueSize，相当于抵消了之前加的QueueSize
</span><span style="color: #008080;"> 58</span> <span style="color: #008000;">    对于rear&lt;front，由于rear-front必然是负数，但这个负数是大于-QueueSize的（这个负数的最小值是-QueueSize+1），所以rear-front+QueueSize的范围是[1,QueueSize-1]，对这个区间里的任何一个数模上QueueSize还是这个数本身
</span><span style="color: #008080;"> 59</span> <span style="color: #008000;">    其实对rear-front+QueueSize模上QueueSize是为了兼容rear&gt;front的队列
</span><span style="color: #008080;"> 60</span> 
<span style="color: #008080;"> 61</span>     <span style="color: #008000;">*/</span>
<span style="color: #008080;"> 62</span> <span style="color: #000000;">} SequenceQueue;
</span><span style="color: #008080;"> 63</span> 
<span style="color: #008080;"> 64</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> 函数原型，队列的基本操作，与栈相同 </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 65</span> SequenceQueue *createSequenceQueue(<span style="color: #0000ff;">void</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 66</span> status isEmpty(SequenceQueue *<span style="color: #000000;">L);
</span><span style="color: #008080;"> 67</span> <span style="color: #0000ff;">void</span> clear(SequenceQueue *<span style="color: #000000;">L);
</span><span style="color: #008080;"> 68</span> datatype getTop(SequenceQueue *<span style="color: #000000;">L);
</span><span style="color: #008080;"> 69</span> <span style="color: #0000ff;">int</span> getLength(SequenceQueue *<span style="color: #000000;">L);
</span><span style="color: #008080;"> 70</span> status push(SequenceQueue *<span style="color: #000000;">L, datatype node_to_push);
</span><span style="color: #008080;"> 71</span> datatype pop(SequenceQueue *<span style="color: #000000;">L);
</span><span style="color: #008080;"> 72</span> <span style="color: #0000ff;">void</span> showQueue(SequenceQueue *<span style="color: #000000;">L);
</span><span style="color: #008080;"> 73</span> 
<span style="color: #008080;"> 74</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
</span><span style="color: #008080;"> 75</span>     <span style="color: #008000;">/*</span><span style="color: #008000;"> 测试 </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 76</span>     SequenceQueue *root; <span style="color: #008000;">//</span><span style="color: #008000;">指向一个通过createSequenceQueue函数创建的栈</span>
<span style="color: #008080;"> 77</span>     root=<span style="color: #000000;">createSequenceQueue();
</span><span style="color: #008080;"> 78</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">isEmpty = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,isEmpty(root));
</span><span style="color: #008080;"> 79</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">Length = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,getLength(root));
</span><span style="color: #008080;"> 80</span>     push(root,<span style="color: #800000;">'</span><span style="color: #800000;">1</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 81</span>     push(root,<span style="color: #800000;">'</span><span style="color: #800000;">2</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 82</span>     push(root,<span style="color: #800000;">'</span><span style="color: #800000;">3</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 83</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">isEmpty = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,isEmpty(root));
</span><span style="color: #008080;"> 84</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">Length = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,getLength(root));
</span><span style="color: #008080;"> 85</span> <span style="color: #000000;">    showQueue(root);
</span><span style="color: #008080;"> 86</span>     putchar(<span style="color: #800000;">'</span><span style="color: #800000;">\n</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 87</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">can continue to push? %d\n</span><span style="color: #800000;">"</span>,push(root,<span style="color: #800000;">'</span><span style="color: #800000;">4</span><span style="color: #800000;">'</span><span style="color: #000000;">));
</span><span style="color: #008080;"> 88</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">getTop = %c\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,getTop(root));
</span><span style="color: #008080;"> 89</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">pop = %c\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,pop(root));
</span><span style="color: #008080;"> 90</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">pop = %c\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,pop(root));
</span><span style="color: #008080;"> 91</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">isEmpty = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,isEmpty(root));
</span><span style="color: #008080;"> 92</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">Length = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,getLength(root));
</span><span style="color: #008080;"> 93</span>     push(root,<span style="color: #800000;">'</span><span style="color: #800000;">5</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 94</span> <span style="color: #000000;">    showQueue(root);
</span><span style="color: #008080;"> 95</span>     putchar(<span style="color: #800000;">'</span><span style="color: #800000;">\n</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 96</span> <span style="color: #000000;">    clear(root);
</span><span style="color: #008080;"> 97</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">isEmpty = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,isEmpty(root));
</span><span style="color: #008080;"> 98</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">Length = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,getLength(root));
</span><span style="color: #008080;"> 99</span> 
<span style="color: #008080;">100</span>     <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">101</span> <span style="color: #000000;">}
</span><span style="color: #008080;">102</span> 
<span style="color: #008080;">103</span> SequenceQueue *createSequenceQueue(<span style="color: #0000ff;">void</span><span style="color: #000000;">){
</span><span style="color: #008080;">104</span>     SequenceQueue *<span style="color: #000000;">tmp;
</span><span style="color: #008080;">105</span>     tmp=<span style="color: #0000ff;">malloc</span>(<span style="color: #0000ff;">sizeof</span>(SequenceQueue)); <span style="color: #008000;">//</span><span style="color: #008000;">void*类型指针能自动转为其他类型的指针</span>
<span style="color: #008080;">106</span>     tmp-&gt;front=tmp-&gt;rear=<span style="color: #800080;">0</span>; <span style="color: #008000;">//</span><span style="color: #008000;">初始化队列的头尾指针</span>
<span style="color: #008080;">107</span>     <span style="color: #0000ff;">return</span><span style="color: #000000;"> tmp;
</span><span style="color: #008080;">108</span> <span style="color: #000000;">}
</span><span style="color: #008080;">109</span> status isEmpty(SequenceQueue *<span style="color: #000000;">L){
</span><span style="color: #008080;">110</span>     <span style="color: #0000ff;">if</span> (L-&gt;front==L-&gt;rear) <span style="color: #008000;">//</span><span style="color: #008000;">front=rear表示队列是空的</span>
<span style="color: #008080;">111</span>         <span style="color: #0000ff;">return</span><span style="color: #000000;"> TRUE;
</span><span style="color: #008080;">112</span>     <span style="color: #0000ff;">else</span>
<span style="color: #008080;">113</span>         <span style="color: #0000ff;">return</span><span style="color: #000000;"> FALSE;
</span><span style="color: #008080;">114</span> <span style="color: #000000;">}
</span><span style="color: #008080;">115</span> <span style="color: #0000ff;">void</span> clear(SequenceQueue *<span style="color: #000000;">L){
</span><span style="color: #008080;">116</span>     L-&gt;front=L-&gt;rear=<span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">117</span> <span style="color: #000000;">}
</span><span style="color: #008080;">118</span> datatype getTop(SequenceQueue *<span style="color: #000000;">L){
</span><span style="color: #008080;">119</span>     <span style="color: #008000;">//</span><span style="color: #008000;">返回队头元素的值</span>
<span style="color: #008080;">120</span>     <span style="color: #0000ff;">return</span> L-&gt;data[L-&gt;<span style="color: #000000;">front];
</span><span style="color: #008080;">121</span> <span style="color: #000000;">}
</span><span style="color: #008080;">122</span> <span style="color: #0000ff;">int</span> getLength(SequenceQueue *<span style="color: #000000;">L){
</span><span style="color: #008080;">123</span>     <span style="color: #0000ff;">return</span> (L-&gt;rear-L-&gt;front+MAXSIZE)%<span style="color: #000000;">MAXSIZE;
</span><span style="color: #008080;">124</span> <span style="color: #000000;">}
</span><span style="color: #008080;">125</span> status push(SequenceQueue *<span style="color: #000000;">L, datatype node_to_push){
</span><span style="color: #008080;">126</span>     <span style="color: #008000;">//</span><span style="color: #008000;">node_to_insert表示想要入队的元素</span>
<span style="color: #008080;">127</span>     <span style="color: #0000ff;">if</span> ((L-&gt;rear+<span style="color: #800080;">1</span>)%MAXSIZE == L-&gt;front) <span style="color: #0000ff;">return</span> ERR; <span style="color: #008000;">//</span><span style="color: #008000;">队列已满</span>
<span style="color: #008080;">128</span>     L-&gt;data[L-&gt;rear]=node_to_push; <span style="color: #008000;">//</span><span style="color: #008000;">将新元素入队</span>
<span style="color: #008080;">129</span>     L-&gt;rear=(L-&gt;rear+<span style="color: #800080;">1</span>)%MAXSIZE; <span style="color: #008000;">//</span><span style="color: #008000;">指针rear后移</span>
<span style="color: #008080;">130</span>     <span style="color: #0000ff;">return</span><span style="color: #000000;"> OK;
</span><span style="color: #008080;">131</span> <span style="color: #000000;">}
</span><span style="color: #008080;">132</span> datatype pop(SequenceQueue *<span style="color: #000000;">L){
</span><span style="color: #008080;">133</span> <span style="color: #000000;">    datatype q;
</span><span style="color: #008080;">134</span>     <span style="color: #0000ff;">if</span> (isEmpty(L)) <span style="color: #0000ff;">return</span> ERR; <span style="color: #008000;">//</span><span style="color: #008000;">队列是空</span>
<span style="color: #008080;">135</span>     q=L-&gt;data[L-&gt;front]; <span style="color: #008000;">//</span><span style="color: #008000;">将要出队的元素先赋值给临时变量s</span>
<span style="color: #008080;">136</span>     L-&gt;front=(L-&gt;front+<span style="color: #800080;">1</span>)%MAXSIZE; <span style="color: #008000;">//</span><span style="color: #008000;">指针front后移</span>
<span style="color: #008080;">137</span>     <span style="color: #0000ff;">return</span> q; <span style="color: #008000;">//</span><span style="color: #008000;">返回出队的元素的值</span>
<span style="color: #008080;">138</span> <span style="color: #000000;">}
</span><span style="color: #008080;">139</span> <span style="color: #0000ff;">void</span> showQueue(SequenceQueue *<span style="color: #000000;">L){
</span><span style="color: #008080;">140</span>     <span style="color: #0000ff;">int</span><span style="color: #000000;"> i;
</span><span style="color: #008080;">141</span>     <span style="color: #0000ff;">int</span> total=<span style="color: #000000;">getLength(L);
</span><span style="color: #008080;">142</span>     <span style="color: #0000ff;">for</span> (i=<span style="color: #800080;">0</span>; i&lt;total; i++<span style="color: #000000;">){
</span><span style="color: #008080;">143</span>         printf(<span style="color: #800000;">"</span><span style="color: #800000;">%c\t</span><span style="color: #800000;">"</span>,L-&gt;data[ (L-&gt;front+i)%<span style="color: #000000;">MAXSIZE ]);
</span><span style="color: #008080;">144</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">145</span> <span style="color: #000000;">}
</span><span style="color: #008080;">146</span> <span style="color: #008000;">/*</span>
<span style="color: #008080;">147</span> <span style="color: #008000;">    队列的定义：只允许在一端进行插入，另一端进行删除的线性表，也是一种操作受限的线性表
</span><span style="color: #008080;">148</span> <span style="color: #008000;">    一般，把允许插入的一端叫做队尾，允许删除的一端叫做队头
</span><span style="color: #008080;">149</span> <span style="color: #008000;">    不含任何元素的队列就是空队
</span><span style="color: #008080;">150</span> <span style="color: #008000;">    所以，队列又称先进先出(First in First out)的线性表
</span><span style="color: #008080;">151</span> <span style="color: #008000;">*/</span>
<span style="color: #008080;">152</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> 环境: Code::Blocks with GCC 5.1 </span><span style="color: #008000;">*/</span></pre>
</div>
<p>&nbsp;</p>
<p>运行截图：</p>
<p><img src="https://img2018.cnblogs.com/i-beta/1326234/202001/1326234-20200123174217901-1119326907.png" alt="" width="411" height="282" /></p>]]></description></item><item><title>栈的链式存储结构（C语言实现）</title><link>http://www.cnblogs.com/ryzz/archive/2020/01/22/12228219.html</link><dc:creator>RYZZ</dc:creator><author>RYZZ</author><pubDate>Wed, 22 Jan 2020 03:27:00 GMT</pubDate><guid>http://www.cnblogs.com/ryzz/archive/2020/01/22/12228219.html</guid><description><![CDATA[<div class="cnblogs_code">
<pre><span style="color: #008080;">  1</span> #include &lt;stdio.h&gt;
<span style="color: #008080;">  2</span> #include &lt;stdlib.h&gt;
<span style="color: #008080;">  3</span> 
<span style="color: #008080;">  4</span> <span style="color: #0000ff;">#define</span> OK 1
<span style="color: #008080;">  5</span> <span style="color: #0000ff;">#define</span> ERR 2
<span style="color: #008080;">  6</span> <span style="color: #0000ff;">#define</span> TRUE 1
<span style="color: #008080;">  7</span> <span style="color: #0000ff;">#define</span> FALSE 0
<span style="color: #008080;">  8</span> 
<span style="color: #008080;">  9</span> typedef <span style="color: #0000ff;">int</span> status; <span style="color: #008000;">//</span><span style="color: #008000;">定义函数返回的状态，OK &amp; ERR</span>
<span style="color: #008080;"> 10</span> typedef <span style="color: #0000ff;">char</span> datatype; <span style="color: #008000;">//</span><span style="color: #008000;">定义栈中每个元素的数据类型，这里暂定为字符型</span>
<span style="color: #008080;"> 11</span> 
<span style="color: #008080;"> 12</span> typedef <span style="color: #0000ff;">struct</span><span style="color: #000000;"> LinkStack_anon{
</span><span style="color: #008080;"> 13</span>     datatype data; <span style="color: #008000;">//</span><span style="color: #008000;">数据区</span>
<span style="color: #008080;"> 14</span>     <span style="color: #0000ff;">struct</span> LinkStack_anon * next; <span style="color: #008000;">//</span><span style="color: #008000;">指针区</span>
<span style="color: #008080;"> 15</span> <span style="color: #000000;">} LinkStack;
</span><span style="color: #008080;"> 16</span> 
<span style="color: #008080;"> 17</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> 函数原型，栈的基本操作 </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 18</span> LinkStack *<span style="color: #000000;">createLinkStack(datatype first_node_value);
</span><span style="color: #008080;"> 19</span> status isEmpty(LinkStack *<span style="color: #000000;">L);
</span><span style="color: #008080;"> 20</span> <span style="color: #0000ff;">void</span> clear(LinkStack **<span style="color: #000000;">L);
</span><span style="color: #008080;"> 21</span> datatype getTop(LinkStack *<span style="color: #000000;">L);
</span><span style="color: #008080;"> 22</span> <span style="color: #0000ff;">int</span> getLength(LinkStack *<span style="color: #000000;">L);
</span><span style="color: #008080;"> 23</span> status push(LinkStack *<span style="color: #000000;">L, datatype node_to_push);
</span><span style="color: #008080;"> 24</span> datatype pop(LinkStack *<span style="color: #000000;">L);
</span><span style="color: #008080;"> 25</span> <span style="color: #0000ff;">void</span> showStack(LinkStack *<span style="color: #000000;">L);
</span><span style="color: #008080;"> 26</span> 
<span style="color: #008080;"> 27</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
</span><span style="color: #008080;"> 28</span>     <span style="color: #008000;">/*</span><span style="color: #008000;"> 测试 </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 29</span>     LinkStack *root; <span style="color: #008000;">//</span><span style="color: #008000;">指向一个通过createLinkStack函数创建的栈</span>
<span style="color: #008080;"> 30</span>     root=createLinkStack(<span style="color: #800000;">'</span><span style="color: #800000;">f</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 31</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">isEmpty = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,isEmpty(root));
</span><span style="color: #008080;"> 32</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">Length = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,getLength(root));
</span><span style="color: #008080;"> 33</span>     push(root,<span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 34</span>     push(root,<span style="color: #800000;">'</span><span style="color: #800000;">b</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 35</span>     push(root,<span style="color: #800000;">'</span><span style="color: #800000;">c</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 36</span>     push(root,<span style="color: #800000;">'</span><span style="color: #800000;">d</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 37</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">isEmpty = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,isEmpty(root));
</span><span style="color: #008080;"> 38</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">Length = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,getLength(root));
</span><span style="color: #008080;"> 39</span> <span style="color: #000000;">    showStack(root);
</span><span style="color: #008080;"> 40</span>     putchar(<span style="color: #800000;">'</span><span style="color: #800000;">\n</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 41</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">pop = %c\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,pop(root));
</span><span style="color: #008080;"> 42</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">pop = %c\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,pop(root));
</span><span style="color: #008080;"> 43</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">getTop = %c\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,getTop(root));
</span><span style="color: #008080;"> 44</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">isEmpty = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,isEmpty(root));
</span><span style="color: #008080;"> 45</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">Length = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,getLength(root));
</span><span style="color: #008080;"> 46</span> <span style="color: #000000;">    showStack(root);
</span><span style="color: #008080;"> 47</span>     putchar(<span style="color: #800000;">'</span><span style="color: #800000;">\n</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 48</span>     clear(&amp;<span style="color: #000000;">root);
</span><span style="color: #008080;"> 49</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">isEmpty = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,isEmpty(root));
</span><span style="color: #008080;"> 50</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">Length = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,getLength(root));
</span><span style="color: #008080;"> 51</span> 
<span style="color: #008080;"> 52</span>     <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 53</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 54</span> 
<span style="color: #008080;"> 55</span> LinkStack *<span style="color: #000000;">createLinkStack(datatype first_node_value){
</span><span style="color: #008080;"> 56</span>     LinkStack *<span style="color: #000000;">tmp;
</span><span style="color: #008080;"> 57</span>     tmp=<span style="color: #0000ff;">malloc</span>(<span style="color: #0000ff;">sizeof</span>(LinkStack)); <span style="color: #008000;">//</span><span style="color: #008000;">void*类型指针能自动转为其他类型的指针</span>
<span style="color: #008080;"> 58</span>     tmp-&gt;data=first_node_value; <span style="color: #008000;">//</span><span style="color: #008000;">初始化栈顶的数据区</span>
<span style="color: #008080;"> 59</span>     tmp-&gt;next=NULL; <span style="color: #008000;">//</span><span style="color: #008000;">初始化栈顶的指针区</span>
<span style="color: #008080;"> 60</span>     <span style="color: #0000ff;">return</span><span style="color: #000000;"> tmp;
</span><span style="color: #008080;"> 61</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 62</span> status isEmpty(LinkStack *<span style="color: #000000;">L){
</span><span style="color: #008080;"> 63</span>     <span style="color: #0000ff;">if</span> (L==<span style="color: #000000;">NULL)
</span><span style="color: #008080;"> 64</span>         <span style="color: #0000ff;">return</span><span style="color: #000000;"> TRUE;
</span><span style="color: #008080;"> 65</span>     <span style="color: #0000ff;">else</span>
<span style="color: #008080;"> 66</span>         <span style="color: #0000ff;">return</span><span style="color: #000000;"> FALSE;
</span><span style="color: #008080;"> 67</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 68</span> <span style="color: #0000ff;">void</span> clear(LinkStack **<span style="color: #000000;">L){
</span><span style="color: #008080;"> 69</span>     <span style="color: #008000;">//</span><span style="color: #008000;">之所以形参的类型是双重指针，是因为这个函数需要修改传入的实参的值
</span><span style="color: #008080;"> 70</span>     <span style="color: #008000;">//</span><span style="color: #008000;">函数clear的作用是将栈清空，这时实参应当指向NULL，所以需要在这个函数内修改实参的值</span>
<span style="color: #008080;"> 71</span>     <span style="color: #0000ff;">if</span> (isEmpty(*L)==<span style="color: #000000;">FALSE){
</span><span style="color: #008080;"> 72</span>         <span style="color: #008000;">//</span><span style="color: #008000;">不为空时才执行删除</span>
<span style="color: #008080;"> 73</span>         LinkStack * p,* q; <span style="color: #008000;">//</span><span style="color: #008000;">p始终指向当前要被删除的结点，而q始终指向要被删除的结点的下一个</span>
<span style="color: #008080;"> 74</span>         p=*L; <span style="color: #008000;">//</span><span style="color: #008000;">将p指向单链表的头结点，即栈的栈顶</span>
<span style="color: #008080;"> 75</span>         <span style="color: #0000ff;">while</span> (p!=<span style="color: #000000;">NULL){
</span><span style="color: #008080;"> 76</span>             <span style="color: #008000;">//</span><span style="color: #008000;">不是NULL就继续</span>
<span style="color: #008080;"> 77</span>             q=p-&gt;next; <span style="color: #008000;">//</span><span style="color: #008000;">q始终指向下一个结点</span>
<span style="color: #008080;"> 78</span>             <span style="color: #0000ff;">free</span>(p); <span style="color: #008000;">//</span><span style="color: #008000;">释放p所指的结点</span>
<span style="color: #008080;"> 79</span>             p=q; <span style="color: #008000;">//</span><span style="color: #008000;">交换</span>
<span style="color: #008080;"> 80</span> <span style="color: #000000;">        }
</span><span style="color: #008080;"> 81</span>         *L=NULL; <span style="color: #008000;">//</span><span style="color: #008000;">将指向栈的指针设为NULL</span>
<span style="color: #008080;"> 82</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 83</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 84</span> datatype getTop(LinkStack *<span style="color: #000000;">L){
</span><span style="color: #008080;"> 85</span>     LinkStack * p=<span style="color: #000000;">L;
</span><span style="color: #008080;"> 86</span>     <span style="color: #0000ff;">while</span> (p &amp;&amp; p-&gt;next!=NULL) <span style="color: #008000;">//</span><span style="color: #008000;">遍历到最后一个结点</span>
<span style="color: #008080;"> 87</span>         p=p-&gt;<span style="color: #000000;">next;
</span><span style="color: #008080;"> 88</span>     <span style="color: #0000ff;">return</span> p-&gt;<span style="color: #000000;">data;
</span><span style="color: #008080;"> 89</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 90</span> <span style="color: #0000ff;">int</span> getLength(LinkStack *<span style="color: #000000;">L){
</span><span style="color: #008080;"> 91</span>     <span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 92</span>     LinkStack * p=<span style="color: #000000;">L;
</span><span style="color: #008080;"> 93</span>     <span style="color: #0000ff;">while</span><span style="color: #000000;"> (p){
</span><span style="color: #008080;"> 94</span>         i++; p=p-&gt;<span style="color: #000000;">next;
</span><span style="color: #008080;"> 95</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 96</span>     <span style="color: #0000ff;">return</span><span style="color: #000000;"> i;
</span><span style="color: #008080;"> 97</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 98</span> status push(LinkStack *<span style="color: #000000;">L, datatype node_to_push){
</span><span style="color: #008080;"> 99</span>     <span style="color: #008000;">//</span><span style="color: #008000;">node_to_insert表示想要入栈的元素
</span><span style="color: #008080;">100</span>     <span style="color: #008000;">//</span><span style="color: #008000;">单链表中的尾插法</span>
<span style="color: #008080;">101</span>     LinkStack * s=<span style="color: #0000ff;">malloc</span>(<span style="color: #0000ff;">sizeof</span>(LinkStack)); <span style="color: #008000;">//</span><span style="color: #008000;">等待入栈的新结点</span>
<span style="color: #008080;">102</span>     LinkStack * p=<span style="color: #000000;">L;
</span><span style="color: #008080;">103</span>     s-&gt;data=<span style="color: #000000;">node_to_push;
</span><span style="color: #008080;">104</span>     s-&gt;next=<span style="color: #000000;">NULL;
</span><span style="color: #008080;">105</span>     <span style="color: #0000ff;">while</span>(p &amp;&amp; p-&gt;next!=NULL) <span style="color: #008000;">//</span><span style="color: #008000;">找到栈的最后一个结点</span>
<span style="color: #008080;">106</span>         p=p-&gt;<span style="color: #000000;">next;
</span><span style="color: #008080;">107</span>     p-&gt;next=<span style="color: #000000;">s;
</span><span style="color: #008080;">108</span>     <span style="color: #0000ff;">return</span><span style="color: #000000;"> OK;
</span><span style="color: #008080;">109</span> <span style="color: #000000;">}
</span><span style="color: #008080;">110</span> datatype pop(LinkStack *<span style="color: #000000;">L){
</span><span style="color: #008080;">111</span>     <span style="color: #008000;">//</span><span style="color: #008000;">尾删法</span>
<span style="color: #008080;">112</span> <span style="color: #000000;">    datatype s;
</span><span style="color: #008080;">113</span>     LinkStack * p=<span style="color: #000000;">L;
</span><span style="color: #008080;">114</span>     <span style="color: #0000ff;">if</span> (isEmpty(L)) <span style="color: #0000ff;">return</span> ERR; <span style="color: #008000;">//</span><span style="color: #008000;">空栈</span>
<span style="color: #008080;">115</span>     <span style="color: #0000ff;">while</span>(p &amp;&amp; p-&gt;next-&gt;next!=NULL) <span style="color: #008000;">//</span><span style="color: #008000;">找到栈的最后一个结点的前一个结点</span>
<span style="color: #008080;">116</span>         p=p-&gt;<span style="color: #000000;">next;
</span><span style="color: #008080;">117</span>     s=p-&gt;next-&gt;data; <span style="color: #008000;">//</span><span style="color: #008000;">先将最后一个结点的值保存</span>
<span style="color: #008080;">118</span>     <span style="color: #0000ff;">free</span>(p-&gt;next); <span style="color: #008000;">//</span><span style="color: #008000;">释放最后一个结点</span>
<span style="color: #008080;">119</span>     p-&gt;next=<span style="color: #000000;">NULL;
</span><span style="color: #008080;">120</span>     <span style="color: #0000ff;">return</span> s; <span style="color: #008000;">//</span><span style="color: #008000;">返回出栈的元素的值</span>
<span style="color: #008080;">121</span> <span style="color: #000000;">}
</span><span style="color: #008080;">122</span> <span style="color: #0000ff;">void</span> showStack(LinkStack *<span style="color: #000000;">L){
</span><span style="color: #008080;">123</span>     <span style="color: #0000ff;">int</span><span style="color: #000000;"> i;
</span><span style="color: #008080;">124</span>     <span style="color: #0000ff;">int</span> total=<span style="color: #000000;">getLength(L);
</span><span style="color: #008080;">125</span>     LinkStack * p=<span style="color: #000000;">L;
</span><span style="color: #008080;">126</span>     <span style="color: #0000ff;">for</span> (i=<span style="color: #800080;">0</span>; i&lt;total; i++<span style="color: #000000;">){
</span><span style="color: #008080;">127</span>         printf(<span style="color: #800000;">"</span><span style="color: #800000;">%c\t</span><span style="color: #800000;">"</span>,p-&gt;data); p=p-&gt;<span style="color: #000000;">next;
</span><span style="color: #008080;">128</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">129</span> <span style="color: #000000;">}
</span><span style="color: #008080;">130</span> <span style="color: #008000;">/*</span>
<span style="color: #008080;">131</span> <span style="color: #008000;">    栈的定义：仅限定在表尾进行插入和删除操作的线性表，即操作受限的线性表
</span><span style="color: #008080;">132</span> <span style="color: #008000;">    一般，把允许插入和删除的一端作为栈顶，另一端则是栈底
</span><span style="color: #008080;">133</span> <span style="color: #008000;">    不含任何元素的栈就是空栈
</span><span style="color: #008080;">134</span> <span style="color: #008000;">    所以，栈又称后进先出(Last in First out)的线性表
</span><span style="color: #008080;">135</span> <span style="color: #008000;">    对于链式存储的栈，不存在栈满的情况，除非已经没有可用的内存了，如果真的发生，那此时计算机就面临死机崩溃的地步了
</span><span style="color: #008080;">136</span> <span style="color: #008000;">*/</span>
<span style="color: #008080;">137</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> 环境: Code::Blocks with GCC 5.1 </span><span style="color: #008000;">*/</span></pre>
</div>
<p>运行截图：</p>
<p><img src="https://img2018.cnblogs.com/i-beta/1326234/202001/1326234-20200122112647206-1160250436.png" alt="" width="436" height="278" /></p>
]]></description></item><item><title>栈的顺序存储结构（C语言实现）</title><link>http://www.cnblogs.com/ryzz/archive/2020/01/21/12220927.html</link><dc:creator>RYZZ</dc:creator><author>RYZZ</author><pubDate>Tue, 21 Jan 2020 02:48:00 GMT</pubDate><guid>http://www.cnblogs.com/ryzz/archive/2020/01/21/12220927.html</guid><description><![CDATA[<div class="cnblogs_code">
<pre><span style="color: #008080;">  1</span> #include &lt;stdio.h&gt;
<span style="color: #008080;">  2</span> #include &lt;stdlib.h&gt;
<span style="color: #008080;">  3</span> 
<span style="color: #008080;">  4</span> <span style="color: #0000ff;">#define</span> OK 1
<span style="color: #008080;">  5</span> <span style="color: #0000ff;">#define</span> ERR 2
<span style="color: #008080;">  6</span> <span style="color: #0000ff;">#define</span> TRUE 1
<span style="color: #008080;">  7</span> <span style="color: #0000ff;">#define</span> FALSE 0
<span style="color: #008080;">  8</span> <span style="color: #0000ff;">#define</span> MAXSIZE 20 <span style="color: #008000;">//</span><span style="color: #008000;">定义栈的最大长度</span>
<span style="color: #008080;">  9</span> 
<span style="color: #008080;"> 10</span> typedef <span style="color: #0000ff;">int</span> status; <span style="color: #008000;">//</span><span style="color: #008000;">定义函数返回的状态，OK &amp; ERR</span>
<span style="color: #008080;"> 11</span> typedef <span style="color: #0000ff;">char</span> datatype; <span style="color: #008000;">//</span><span style="color: #008000;">定义栈中每个元素的数据类型，这里暂定为字符型</span>
<span style="color: #008080;"> 12</span> 
<span style="color: #008080;"> 13</span> typedef <span style="color: #0000ff;">struct</span><span style="color: #000000;"> {
</span><span style="color: #008080;"> 14</span>     datatype data[MAXSIZE]; <span style="color: #008000;">//</span><span style="color: #008000;">存储着栈中的每个元素</span>
<span style="color: #008080;"> 15</span>     <span style="color: #0000ff;">int</span> top; <span style="color: #008000;">//</span><span style="color: #008000;">用于标识栈顶，永远保存着栈顶元素的下标</span>
<span style="color: #008080;"> 16</span> <span style="color: #000000;">} SequenceStack;
</span><span style="color: #008080;"> 17</span> 
<span style="color: #008080;"> 18</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> 函数原型，栈的基本操作 </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 19</span> SequenceStack *createSequenceStack(<span style="color: #0000ff;">void</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 20</span> status isEmpty(SequenceStack *<span style="color: #000000;">L);
</span><span style="color: #008080;"> 21</span> <span style="color: #0000ff;">void</span> clear(SequenceStack *<span style="color: #000000;">L);
</span><span style="color: #008080;"> 22</span> datatype getTop(SequenceStack *<span style="color: #000000;">L);
</span><span style="color: #008080;"> 23</span> <span style="color: #0000ff;">int</span> getLength(SequenceStack *<span style="color: #000000;">L);
</span><span style="color: #008080;"> 24</span> status push(SequenceStack *<span style="color: #000000;">L, datatype node_to_push);
</span><span style="color: #008080;"> 25</span> datatype pop(SequenceStack *<span style="color: #000000;">L);
</span><span style="color: #008080;"> 26</span> <span style="color: #0000ff;">void</span> showStack(SequenceStack *<span style="color: #000000;">L);
</span><span style="color: #008080;"> 27</span> 
<span style="color: #008080;"> 28</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
</span><span style="color: #008080;"> 29</span>     <span style="color: #008000;">/*</span><span style="color: #008000;"> 测试 </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 30</span>     SequenceStack *root; <span style="color: #008000;">//</span><span style="color: #008000;">指向一个通过createSequenceStack函数创建的栈</span>
<span style="color: #008080;"> 31</span>     root=<span style="color: #000000;">createSequenceStack();
</span><span style="color: #008080;"> 32</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">isEmpty = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,isEmpty(root));
</span><span style="color: #008080;"> 33</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">Length = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,getLength(root));
</span><span style="color: #008080;"> 34</span>     push(root,<span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 35</span>     push(root,<span style="color: #800000;">'</span><span style="color: #800000;">b</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 36</span>     push(root,<span style="color: #800000;">'</span><span style="color: #800000;">c</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 37</span>     push(root,<span style="color: #800000;">'</span><span style="color: #800000;">d</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 38</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">isEmpty = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,isEmpty(root));
</span><span style="color: #008080;"> 39</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">Length = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,getLength(root));
</span><span style="color: #008080;"> 40</span> <span style="color: #000000;">    showStack(root);
</span><span style="color: #008080;"> 41</span>     putchar(<span style="color: #800000;">'</span><span style="color: #800000;">\n</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 42</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">pop = %c\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,pop(root));
</span><span style="color: #008080;"> 43</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">pop = %c\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,pop(root));
</span><span style="color: #008080;"> 44</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">getTop = %c\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,getTop(root));
</span><span style="color: #008080;"> 45</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">isEmpty = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,isEmpty(root));
</span><span style="color: #008080;"> 46</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">Length = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,getLength(root));
</span><span style="color: #008080;"> 47</span> <span style="color: #000000;">    showStack(root);
</span><span style="color: #008080;"> 48</span>     putchar(<span style="color: #800000;">'</span><span style="color: #800000;">\n</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 49</span> <span style="color: #000000;">    clear(root);
</span><span style="color: #008080;"> 50</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">isEmpty = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,isEmpty(root));
</span><span style="color: #008080;"> 51</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">Length = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,getLength(root));
</span><span style="color: #008080;"> 52</span> 
<span style="color: #008080;"> 53</span>     <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 54</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 55</span> 
<span style="color: #008080;"> 56</span> SequenceStack *createSequenceStack(<span style="color: #0000ff;">void</span><span style="color: #000000;">){
</span><span style="color: #008080;"> 57</span>     SequenceStack *<span style="color: #000000;">tmp;
</span><span style="color: #008080;"> 58</span>     tmp=<span style="color: #0000ff;">malloc</span>(<span style="color: #0000ff;">sizeof</span>(SequenceStack)); <span style="color: #008000;">//</span><span style="color: #008000;">void*类型指针能自动转为其他类型的指针</span>
<span style="color: #008080;"> 59</span>     tmp-&gt;top=-<span style="color: #800080;">1</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 60</span>     <span style="color: #008000;">//</span><span style="color: #008000;">初始化栈的栈顶指针，-1代表空栈，0表示只有一个元素的栈，那个元素就是数组下标0，依次类推</span>
<span style="color: #008080;"> 61</span>     <span style="color: #0000ff;">return</span><span style="color: #000000;"> tmp;
</span><span style="color: #008080;"> 62</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 63</span> status isEmpty(SequenceStack *<span style="color: #000000;">L){
</span><span style="color: #008080;"> 64</span>     <span style="color: #0000ff;">if</span> (L-&gt;top==-<span style="color: #800080;">1</span><span style="color: #000000;">)
</span><span style="color: #008080;"> 65</span>         <span style="color: #0000ff;">return</span><span style="color: #000000;"> TRUE;
</span><span style="color: #008080;"> 66</span>     <span style="color: #0000ff;">else</span>
<span style="color: #008080;"> 67</span>         <span style="color: #0000ff;">return</span><span style="color: #000000;"> FALSE;
</span><span style="color: #008080;"> 68</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 69</span> <span style="color: #0000ff;">void</span> clear(SequenceStack *<span style="color: #000000;">L){
</span><span style="color: #008080;"> 70</span>     L-&gt;top=-<span style="color: #800080;">1</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 71</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 72</span> datatype getTop(SequenceStack *<span style="color: #000000;">L){
</span><span style="color: #008080;"> 73</span>     <span style="color: #0000ff;">return</span> L-&gt;data[L-&gt;<span style="color: #000000;">top];
</span><span style="color: #008080;"> 74</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 75</span> <span style="color: #0000ff;">int</span> getLength(SequenceStack *<span style="color: #000000;">L){
</span><span style="color: #008080;"> 76</span>     <span style="color: #0000ff;">return</span> L-&gt;top+<span style="color: #800080;">1</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 77</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 78</span> status push(SequenceStack *<span style="color: #000000;">L, datatype node_to_push){
</span><span style="color: #008080;"> 79</span>     <span style="color: #008000;">//</span><span style="color: #008000;">node_to_insert表示想要入栈的元素</span>
<span style="color: #008080;"> 80</span>     <span style="color: #0000ff;">if</span> (L-&gt;top==MAXSIZE-<span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> ERR; <span style="color: #008000;">//</span><span style="color: #008000;">满栈</span>
<span style="color: #008080;"> 81</span>     L-&gt;top++; <span style="color: #008000;">//</span><span style="color: #008000;">栈顶指针+1</span>
<span style="color: #008080;"> 82</span>     L-&gt;data[L-&gt;top]=node_to_push; <span style="color: #008000;">//</span><span style="color: #008000;">将新元素入栈</span>
<span style="color: #008080;"> 83</span>     <span style="color: #0000ff;">return</span><span style="color: #000000;"> OK;
</span><span style="color: #008080;"> 84</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 85</span> datatype pop(SequenceStack *<span style="color: #000000;">L){
</span><span style="color: #008080;"> 86</span> <span style="color: #000000;">    datatype s;
</span><span style="color: #008080;"> 87</span>     <span style="color: #0000ff;">if</span> (L-&gt;top==-<span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> ERR; <span style="color: #008000;">//</span><span style="color: #008000;">空栈</span>
<span style="color: #008080;"> 88</span>     s=L-&gt;data[L-&gt;top]; <span style="color: #008000;">//</span><span style="color: #008000;">将要出栈的元素先赋值给临时变量s</span>
<span style="color: #008080;"> 89</span>     L-&gt;top--; <span style="color: #008000;">//</span><span style="color: #008000;">栈顶指针-1</span>
<span style="color: #008080;"> 90</span>     <span style="color: #0000ff;">return</span> s; <span style="color: #008000;">//</span><span style="color: #008000;">返回出栈的元素的值</span>
<span style="color: #008080;"> 91</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 92</span> <span style="color: #0000ff;">void</span> showStack(SequenceStack *<span style="color: #000000;">L){
</span><span style="color: #008080;"> 93</span>     <span style="color: #0000ff;">int</span><span style="color: #000000;"> i;
</span><span style="color: #008080;"> 94</span>     <span style="color: #0000ff;">int</span> total=<span style="color: #000000;">getLength(L);
</span><span style="color: #008080;"> 95</span>     <span style="color: #0000ff;">for</span> (i=<span style="color: #800080;">0</span>; i&lt;total; i++<span style="color: #000000;">){
</span><span style="color: #008080;"> 96</span>         printf(<span style="color: #800000;">"</span><span style="color: #800000;">%c\t</span><span style="color: #800000;">"</span>,L-&gt;<span style="color: #000000;">data[i]);
</span><span style="color: #008080;"> 97</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 98</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 99</span> <span style="color: #008000;">/*</span>
<span style="color: #008080;">100</span> <span style="color: #008000;">    栈的定义：仅限定在表尾进行插入和删除操作的线性表，即操作受限的线性表
</span><span style="color: #008080;">101</span> <span style="color: #008000;">    一般，把允许插入和删除的一端作为栈顶，另一端则是栈底
</span><span style="color: #008080;">102</span> <span style="color: #008000;">    不含任何元素的栈就是空栈
</span><span style="color: #008080;">103</span> <span style="color: #008000;">    所以，栈又称后进先出(Last in First out)的线性表
</span><span style="color: #008080;">104</span> <span style="color: #008000;">*/</span>
<span style="color: #008080;">105</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> 环境: Code::Blocks with GCC 5.1 </span><span style="color: #008000;">*/</span></pre>
</div>
<p>运行截图：</p>
<p><img src="https://img2018.cnblogs.com/i-beta/1326234/202001/1326234-20200121104729204-1680622385.png" alt="" width="392" height="275" /></p>
]]></description></item><item><title>线性表的链式存储结构（C语言实现）</title><link>http://www.cnblogs.com/ryzz/archive/2020/01/19/12215331.html</link><dc:creator>RYZZ</dc:creator><author>RYZZ</author><pubDate>Sun, 19 Jan 2020 11:44:00 GMT</pubDate><guid>http://www.cnblogs.com/ryzz/archive/2020/01/19/12215331.html</guid><description><![CDATA[<div class="cnblogs_code">
<pre><span style="color: #008080;">  1</span> #include &lt;stdio.h&gt;
<span style="color: #008080;">  2</span> #include &lt;stdlib.h&gt;
<span style="color: #008080;">  3</span> 
<span style="color: #008080;">  4</span> <span style="color: #0000ff;">#define</span> OK 1
<span style="color: #008080;">  5</span> <span style="color: #0000ff;">#define</span> ERR 2
<span style="color: #008080;">  6</span> <span style="color: #0000ff;">#define</span> TRUE 1
<span style="color: #008080;">  7</span> <span style="color: #0000ff;">#define</span> FALSE 0
<span style="color: #008080;">  8</span> 
<span style="color: #008080;">  9</span> typedef <span style="color: #0000ff;">int</span> status; <span style="color: #008000;">//</span><span style="color: #008000;">定义函数返回的状态，OK &amp; ERR</span>
<span style="color: #008080;"> 10</span> typedef <span style="color: #0000ff;">char</span> datatype; <span style="color: #008000;">//</span><span style="color: #008000;">定义线性表中每个结点的数据类型，这里暂定为字符型</span>
<span style="color: #008080;"> 11</span> 
<span style="color: #008080;"> 12</span> typedef <span style="color: #0000ff;">struct</span><span style="color: #000000;"> LinkList_anon{
</span><span style="color: #008080;"> 13</span>     datatype data; <span style="color: #008000;">//</span><span style="color: #008000;">数据区</span>
<span style="color: #008080;"> 14</span>     <span style="color: #0000ff;">struct</span> LinkList_anon * next; <span style="color: #008000;">//</span><span style="color: #008000;">指针区</span>
<span style="color: #008080;"> 15</span> <span style="color: #000000;">} LinkList;
</span><span style="color: #008080;"> 16</span> 
<span style="color: #008080;"> 17</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> 函数原型，线性表的基本操作 </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 18</span> LinkList *<span style="color: #000000;">createLinkList(datatype first_node_value);
</span><span style="color: #008080;"> 19</span> status isEmpty(LinkList *<span style="color: #000000;">L);
</span><span style="color: #008080;"> 20</span> <span style="color: #0000ff;">void</span> clear(LinkList **<span style="color: #000000;">L);
</span><span style="color: #008080;"> 21</span> <span style="color: #0000ff;">int</span> getLength(LinkList *<span style="color: #000000;">L);
</span><span style="color: #008080;"> 22</span> <span style="color: #0000ff;">int</span> locateNode(LinkList *<span style="color: #000000;">L,datatype node_to_locate);
</span><span style="color: #008080;"> 23</span> datatype getNode(LinkList *L, <span style="color: #0000ff;">int</span><span style="color: #000000;"> index);
</span><span style="color: #008080;"> 24</span> status insert(LinkList **L, <span style="color: #0000ff;">int</span><span style="color: #000000;"> index, datatype node_to_insert);
</span><span style="color: #008080;"> 25</span> status delete(LinkList **L, <span style="color: #0000ff;">int</span><span style="color: #000000;"> index);
</span><span style="color: #008080;"> 26</span> <span style="color: #0000ff;">void</span> showList(LinkList *<span style="color: #000000;">L);
</span><span style="color: #008080;"> 27</span> 
<span style="color: #008080;"> 28</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
</span><span style="color: #008080;"> 29</span>     <span style="color: #008000;">/*</span><span style="color: #008000;"> 测试 </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 30</span>     LinkList *root; <span style="color: #008000;">//</span><span style="color: #008000;">指向线性表</span>
<span style="color: #008080;"> 31</span>     root=createLinkList(<span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span>); <span style="color: #008000;">//</span><span style="color: #008000;">创建一个线性表</span>
<span style="color: #008080;"> 32</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">Length = %d\n</span><span style="color: #800000;">"</span>,getLength(root)); <span style="color: #008000;">//</span><span style="color: #008000;">打印线性表的当前长度</span>
<span style="color: #008080;"> 33</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">isEmpty = %d\n</span><span style="color: #800000;">"</span>,isEmpty(root)); <span style="color: #008000;">//</span><span style="color: #008000;">打印线性表是否为空</span>
<span style="color: #008080;"> 34</span>     insert(&amp;root,<span style="color: #800080;">0</span>,<span style="color: #800000;">'</span><span style="color: #800000;">B</span><span style="color: #800000;">'</span>); <span style="color: #008000;">//</span><span style="color: #008000;">头插法插入2个结点</span>
<span style="color: #008080;"> 35</span>     insert(&amp;root,<span style="color: #800080;">0</span>,<span style="color: #800000;">'</span><span style="color: #800000;">C</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 36</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">Length = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,getLength(root));
</span><span style="color: #008080;"> 37</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">isEmpty = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,isEmpty(root));
</span><span style="color: #008080;"> 38</span> <span style="color: #000000;">    showList(root);
</span><span style="color: #008080;"> 39</span>     putchar(<span style="color: #800000;">'</span><span style="color: #800000;">\n</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 40</span>     insert(&amp;root,getLength(root),<span style="color: #800000;">'</span><span style="color: #800000;">D</span><span style="color: #800000;">'</span>); <span style="color: #008000;">//</span><span style="color: #008000;">尾插法插入2个结点</span>
<span style="color: #008080;"> 41</span>     insert(&amp;root,getLength(root),<span style="color: #800000;">'</span><span style="color: #800000;">E</span><span style="color: #800000;">'</span>); <span style="color: #008000;">//</span><span style="color: #008000;">尾插法插入2个结点</span>
<span style="color: #008080;"> 42</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">Length = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,getLength(root));
</span><span style="color: #008080;"> 43</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">isEmpty = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,isEmpty(root));
</span><span style="color: #008080;"> 44</span> <span style="color: #000000;">    showList(root);
</span><span style="color: #008080;"> 45</span>     putchar(<span style="color: #800000;">'</span><span style="color: #800000;">\n</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 46</span>     insert(&amp;root,<span style="color: #800080;">1</span>,<span style="color: #800000;">'</span><span style="color: #800000;">F</span><span style="color: #800000;">'</span>); <span style="color: #008000;">//</span><span style="color: #008000;">在index=1（第2个结点）插入新结点</span>
<span style="color: #008080;"> 47</span>     insert(&amp;root,<span style="color: #800080;">2</span>,<span style="color: #800000;">'</span><span style="color: #800000;">G</span><span style="color: #800000;">'</span>); <span style="color: #008000;">//</span><span style="color: #008000;">在index=2（第3个结点）插入新节点</span>
<span style="color: #008080;"> 48</span>     insert(&amp;root,<span style="color: #800080;">2</span>,<span style="color: #800000;">'</span><span style="color: #800000;">H</span><span style="color: #800000;">'</span>); <span style="color: #008000;">//</span><span style="color: #008000;">在index=2（第3个结点）插入新节点</span>
<span style="color: #008080;"> 49</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">Length = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,getLength(root));
</span><span style="color: #008080;"> 50</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">isEmpty = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,isEmpty(root));
</span><span style="color: #008080;"> 51</span>     showList(root); <span style="color: #008000;">//</span><span style="color: #008000;">打印线性表</span>
<span style="color: #008080;"> 52</span>     putchar(<span style="color: #800000;">'</span><span style="color: #800000;">\n</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 53</span>     delete(&amp;root,<span style="color: #800080;">0</span>); <span style="color: #008000;">//</span><span style="color: #008000;">删除头结点</span>
<span style="color: #008080;"> 54</span> <span style="color: #000000;">    showList(root);
</span><span style="color: #008080;"> 55</span>     putchar(<span style="color: #800000;">'</span><span style="color: #800000;">\n</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 56</span>     delete(&amp;root,getLength(root)-<span style="color: #800080;">1</span>); <span style="color: #008000;">//</span><span style="color: #008000;">删除尾结点</span>
<span style="color: #008080;"> 57</span> <span style="color: #000000;">    showList(root);
</span><span style="color: #008080;"> 58</span>     putchar(<span style="color: #800000;">'</span><span style="color: #800000;">\n</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 59</span>     delete(&amp;root,<span style="color: #800080;">3</span>); <span style="color: #008000;">//</span><span style="color: #008000;">删除index=3（第4个）结点</span>
<span style="color: #008080;"> 60</span> <span style="color: #000000;">    showList(root);
</span><span style="color: #008080;"> 61</span>     putchar(<span style="color: #800000;">'</span><span style="color: #800000;">\n</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 62</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">Locate = %d\n</span><span style="color: #800000;">"</span>,locateNode(root,<span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span>)); <span style="color: #008000;">//</span><span style="color: #008000;">打印查找到的结点的位置</span>
<span style="color: #008080;"> 63</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">getNode = %c\n</span><span style="color: #800000;">"</span>,getNode(root,<span style="color: #800080;">1</span>)); <span style="color: #008000;">//</span><span style="color: #008000;">打印下标是1的结点的值</span>
<span style="color: #008080;"> 64</span>     clear(&amp;root); <span style="color: #008000;">//</span><span style="color: #008000;">清空线性表</span>
<span style="color: #008080;"> 65</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">isEmpty = %d</span><span style="color: #800000;">"</span><span style="color: #000000;">,isEmpty(root));
</span><span style="color: #008080;"> 66</span> 
<span style="color: #008080;"> 67</span>     <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 68</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 69</span> 
<span style="color: #008080;"> 70</span> LinkList *<span style="color: #000000;">createLinkList(datatype first_node_value){
</span><span style="color: #008080;"> 71</span>     LinkList *<span style="color: #000000;">tmp;
</span><span style="color: #008080;"> 72</span>     tmp=<span style="color: #0000ff;">malloc</span>(<span style="color: #0000ff;">sizeof</span>(LinkList));<span style="color: #008000;">//</span><span style="color: #008000;">void*类型指针能自动转为其他类型的指针</span>
<span style="color: #008080;"> 73</span>     tmp-&gt;data=first_node_value; <span style="color: #008000;">//</span><span style="color: #008000;">初始化头指针的数据区</span>
<span style="color: #008080;"> 74</span>     tmp-&gt;next=NULL; <span style="color: #008000;">//</span><span style="color: #008000;">初始化头结点的指针区</span>
<span style="color: #008080;"> 75</span>     <span style="color: #0000ff;">return</span><span style="color: #000000;"> tmp;
</span><span style="color: #008080;"> 76</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 77</span> status isEmpty(LinkList *<span style="color: #000000;">L){
</span><span style="color: #008080;"> 78</span>     <span style="color: #0000ff;">if</span> (L==<span style="color: #000000;">NULL)
</span><span style="color: #008080;"> 79</span>         <span style="color: #0000ff;">return</span> TRUE; <span style="color: #008000;">//</span><span style="color: #008000;">链表为空返回TRUE</span>
<span style="color: #008080;"> 80</span>     <span style="color: #0000ff;">else</span>
<span style="color: #008080;"> 81</span>         <span style="color: #0000ff;">return</span> FALSE; <span style="color: #008000;">//</span><span style="color: #008000;">链表不为空返回FALSE</span>
<span style="color: #008080;"> 82</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 83</span> <span style="color: #0000ff;">void</span> clear(LinkList **<span style="color: #000000;">L){
</span><span style="color: #008080;"> 84</span>     <span style="color: #0000ff;">if</span> (isEmpty(*L)==<span style="color: #000000;">FALSE){
</span><span style="color: #008080;"> 85</span>         <span style="color: #008000;">//</span><span style="color: #008000;">不为空时才执行删除</span>
<span style="color: #008080;"> 86</span>         LinkList * p,* q; <span style="color: #008000;">//</span><span style="color: #008000;">p始终指向当前要被删除的结点，而q始终指向要被删除的结点的下一个</span>
<span style="color: #008080;"> 87</span>         p=*L; <span style="color: #008000;">//</span><span style="color: #008000;">将p指向线性表的头结点</span>
<span style="color: #008080;"> 88</span>         <span style="color: #0000ff;">while</span> (p!=<span style="color: #000000;">NULL){
</span><span style="color: #008080;"> 89</span>             <span style="color: #008000;">//</span><span style="color: #008000;">p不是NULL就继续循环</span>
<span style="color: #008080;"> 90</span>             q=p-&gt;next; <span style="color: #008000;">//</span><span style="color: #008000;">q始终指向下一个结点</span>
<span style="color: #008080;"> 91</span>             <span style="color: #0000ff;">free</span>(p); <span style="color: #008000;">//</span><span style="color: #008000;">释放p所指的结点</span>
<span style="color: #008080;"> 92</span>             p=q; <span style="color: #008000;">//</span><span style="color: #008000;">交换</span>
<span style="color: #008080;"> 93</span> <span style="color: #000000;">        }
</span><span style="color: #008080;"> 94</span>         *L=NULL; <span style="color: #008000;">//</span><span style="color: #008000;">将指向线性表的指针设为NULL</span>
<span style="color: #008080;"> 95</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 96</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 97</span> <span style="color: #0000ff;">int</span> getLength(LinkList *<span style="color: #000000;">L){
</span><span style="color: #008080;"> 98</span>     <span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 99</span>     LinkList * p=<span style="color: #000000;">L;
</span><span style="color: #008080;">100</span>     <span style="color: #0000ff;">if</span> (isEmpty(L)==TRUE) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">101</span>     <span style="color: #0000ff;">while</span><span style="color: #000000;"> (p){
</span><span style="color: #008080;">102</span>         i++<span style="color: #000000;">;
</span><span style="color: #008080;">103</span>         p=p-&gt;<span style="color: #000000;">next;
</span><span style="color: #008080;">104</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">105</span>     <span style="color: #0000ff;">return</span><span style="color: #000000;"> i;
</span><span style="color: #008080;">106</span> <span style="color: #000000;">}
</span><span style="color: #008080;">107</span> <span style="color: #0000ff;">int</span> locateNode(LinkList *<span style="color: #000000;">L, datatype node_to_locate){
</span><span style="color: #008080;">108</span>     <span style="color: #008000;">//</span><span style="color: #008000;">返回找到的结点的index
</span><span style="color: #008080;">109</span>     <span style="color: #008000;">//</span><span style="color: #008000;">node_to_locate应当是能唯一标识一个结点的数据，否则只返回匹配的第一个结点</span>
<span style="color: #008080;">110</span>     <span style="color: #0000ff;">int</span><span style="color: #000000;"> i;
</span><span style="color: #008080;">111</span>     <span style="color: #0000ff;">int</span> total=<span style="color: #000000;">getLength(L);
</span><span style="color: #008080;">112</span>     LinkList * p=<span style="color: #000000;">L;
</span><span style="color: #008080;">113</span>     <span style="color: #0000ff;">for</span> (i=<span style="color: #800080;">0</span>; i&lt;total; i++<span style="color: #000000;">){
</span><span style="color: #008080;">114</span>         <span style="color: #0000ff;">if</span> (p-&gt;data==<span style="color: #000000;">node_to_locate)
</span><span style="color: #008080;">115</span>             <span style="color: #0000ff;">return</span><span style="color: #000000;"> i;
</span><span style="color: #008080;">116</span>         <span style="color: #0000ff;">else</span>
<span style="color: #008080;">117</span>             p=p-&gt;<span style="color: #000000;">next;
</span><span style="color: #008080;">118</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">119</span>     <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span>; <span style="color: #008000;">//</span><span style="color: #008000;">未找到任何匹配</span>
<span style="color: #008080;">120</span> <span style="color: #000000;">}
</span><span style="color: #008080;">121</span> datatype getNode(LinkList *L, <span style="color: #0000ff;">int</span><span style="color: #000000;"> index){
</span><span style="color: #008080;">122</span>     <span style="color: #008000;">//</span><span style="color: #008000;">index表示线性表中第N个结点，头结点的index是0</span>
<span style="color: #008080;">123</span>     <span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>; <span style="color: #008000;">//</span><span style="color: #008000;">计数器</span>
<span style="color: #008080;">124</span>     LinkList * p=L; <span style="color: #008000;">//</span><span style="color: #008000;">临时结点，用于遍历</span>
<span style="color: #008080;">125</span>     <span style="color: #0000ff;">if</span> (isEmpty(L)==TRUE) <span style="color: #0000ff;">return</span> (datatype)ERR; <span style="color: #008000;">//</span><span style="color: #008000;">线性表为空</span>
<span style="color: #008080;">126</span>     <span style="color: #0000ff;">while</span> (p!=NULL &amp;&amp; i&lt;<span style="color: #000000;">index){
</span><span style="color: #008080;">127</span>         <span style="color: #008000;">//</span><span style="color: #008000;">p不是NULL且i还没等于index时，循环继续</span>
<span style="color: #008080;">128</span>         p=p-&gt;<span style="color: #000000;">next;
</span><span style="color: #008080;">129</span>         i++<span style="color: #000000;">;
</span><span style="color: #008080;">130</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">131</span>     <span style="color: #0000ff;">return</span> p-&gt;<span style="color: #000000;">data;
</span><span style="color: #008080;">132</span> <span style="color: #000000;">}
</span><span style="color: #008080;">133</span> status insert(LinkList **L, <span style="color: #0000ff;">int</span><span style="color: #000000;"> index, datatype node_to_insert){
</span><span style="color: #008080;">134</span>     <span style="color: #008000;">//</span><span style="color: #008000;">node_to_insert表示想要插入的结点
</span><span style="color: #008080;">135</span>     <span style="color: #008000;">//</span><span style="color: #008000;">当列表为空时，只有index=0才能插入
</span><span style="color: #008080;">136</span>     <span style="color: #008000;">//</span><span style="color: #008000;">当index=0时，即头插，会修改传入的指针，将其指向新的头结点
</span><span style="color: #008080;">137</span>     <span style="color: #008000;">//</span><span style="color: #008000;">当index=getLength(root)时，即尾插</span>
<span style="color: #008080;">138</span>     <span style="color: #0000ff;">int</span><span style="color: #000000;"> k;
</span><span style="color: #008080;">139</span>     LinkList *<span style="color: #000000;"> p;
</span><span style="color: #008080;">140</span>     LinkList * tmp=<span style="color: #0000ff;">malloc</span>(<span style="color: #0000ff;">sizeof</span><span style="color: #000000;">(LinkList));
</span><span style="color: #008080;">141</span>     <span style="color: #0000ff;">if</span> (index&lt;<span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> ERR; <span style="color: #008000;">//</span><span style="color: #008000;">index不在有效范围</span>
<span style="color: #008080;">142</span>     <span style="color: #0000ff;">if</span> (index==<span style="color: #800080;">0</span><span style="color: #000000;">){
</span><span style="color: #008080;">143</span>         <span style="color: #008000;">//</span><span style="color: #008000;">头插</span>
<span style="color: #008080;">144</span>         tmp-&gt;next=*L; <span style="color: #008000;">//</span><span style="color: #008000;">将新结点的指针区指向链表的头结点，随之，新节点变成链表的头结点</span>
<span style="color: #008080;">145</span>         tmp-&gt;data=node_to_insert; <span style="color: #008000;">//</span><span style="color: #008000;">数据区</span>
<span style="color: #008080;">146</span>         *L=tmp; <span style="color: #008000;">//</span><span style="color: #008000;">将原来指向头结点的指针修改为现在的新头结点</span>
<span style="color: #008080;">147</span>         <span style="color: #0000ff;">return</span><span style="color: #000000;"> OK;
</span><span style="color: #008080;">148</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">149</span>     <span style="color: #0000ff;">if</span> (index&gt;getLength(*L)-<span style="color: #800080;">1</span><span style="color: #000000;">){
</span><span style="color: #008080;">150</span>         <span style="color: #008000;">//</span><span style="color: #008000;">尾插</span>
<span style="color: #008080;">151</span>         tmp-&gt;next=NULL; <span style="color: #008000;">//</span><span style="color: #008000;">因为是尾插，此结点是链表的最后一个结点，所以指针区为NULL</span>
<span style="color: #008080;">152</span>         tmp-&gt;data=node_to_insert; <span style="color: #008000;">//</span><span style="color: #008000;">数据区</span>
<span style="color: #008080;">153</span>         p=*L; <span style="color: #008000;">//</span><span style="color: #008000;">变量p用于遍历</span>
<span style="color: #008080;">154</span>         <span style="color: #0000ff;">while</span><span style="color: #000000;"> (p){
</span><span style="color: #008080;">155</span>             <span style="color: #008000;">//</span><span style="color: #008000;">寻找当前线性表的最后一个结点，用于将新结点附在它的后面</span>
<span style="color: #008080;">156</span>             <span style="color: #0000ff;">if</span> (p-&gt;next==<span style="color: #000000;">NULL)
</span><span style="color: #008080;">157</span>                 <span style="color: #008000;">//</span><span style="color: #008000;">找到了当前链表的最后一个</span>
<span style="color: #008080;">158</span>                 <span style="color: #0000ff;">break</span><span style="color: #000000;">;
</span><span style="color: #008080;">159</span>             p=p-&gt;next; <span style="color: #008000;">//</span><span style="color: #008000;">继续下一个结点</span>
<span style="color: #008080;">160</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">161</span>         p-&gt;next=tmp; <span style="color: #008000;">//</span><span style="color: #008000;">将原来线性表的最后一个结点指向新的尾结点</span>
<span style="color: #008080;">162</span>         <span style="color: #0000ff;">return</span><span style="color: #000000;"> OK;
</span><span style="color: #008080;">163</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">164</span>     <span style="color: #008000;">//</span><span style="color: #008000;">不是头插也不是尾插</span>
<span style="color: #008080;">165</span>     k=<span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">166</span>     p=*<span style="color: #000000;">L;
</span><span style="color: #008080;">167</span>     <span style="color: #0000ff;">for</span> (k=<span style="color: #800080;">0</span>; k&lt;index-<span style="color: #800080;">1</span>; k++<span style="color: #000000;">){
</span><span style="color: #008080;">168</span>         <span style="color: #008000;">//</span><span style="color: #008000;">遍历到第index个结点的前一个结点，头结点的index等于0
</span><span style="color: #008080;">169</span>         <span style="color: #008000;">//</span><span style="color: #008000;">利用index的前一个结点的next就可以知道第index个结点</span>
<span style="color: #008080;">170</span>         p=p-&gt;<span style="color: #000000;">next;
</span><span style="color: #008080;">171</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">172</span>     tmp-&gt;next=p-&gt;next; <span style="color: #008000;">//</span><span style="color: #008000;">把tmp接到index前面</span>
<span style="color: #008080;">173</span>     p-&gt;next=tmp; <span style="color: #008000;">//</span><span style="color: #008000;">再把tmp接到index前一个结点的后面</span>
<span style="color: #008080;">174</span>     tmp-&gt;data=node_to_insert; <span style="color: #008000;">//</span><span style="color: #008000;">数据区</span>
<span style="color: #008080;">175</span>     <span style="color: #0000ff;">return</span><span style="color: #000000;"> OK;
</span><span style="color: #008080;">176</span> <span style="color: #000000;">}
</span><span style="color: #008080;">177</span> status delete(LinkList **L, <span style="color: #0000ff;">int</span><span style="color: #000000;"> index){
</span><span style="color: #008080;">178</span>     <span style="color: #008000;">//</span><span style="color: #008000;">当index=0时，即头删
</span><span style="color: #008080;">179</span>     <span style="color: #008000;">//</span><span style="color: #008000;">当index=getLength(root)-1时，即尾删</span>
<span style="color: #008080;">180</span>     <span style="color: #0000ff;">int</span><span style="color: #000000;"> k;
</span><span style="color: #008080;">181</span>     LinkList * p,*<span style="color: #000000;"> q;
</span><span style="color: #008080;">182</span>     <span style="color: #0000ff;">if</span> (index&lt;<span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> ERR; <span style="color: #008000;">//</span><span style="color: #008000;">index不在有效范围</span>
<span style="color: #008080;">183</span>     <span style="color: #0000ff;">if</span> (index==<span style="color: #800080;">0</span><span style="color: #000000;">){
</span><span style="color: #008080;">184</span>         <span style="color: #008000;">//</span><span style="color: #008000;">头删</span>
<span style="color: #008080;">185</span>         p=(*L)-&gt;next; <span style="color: #008000;">//</span><span style="color: #008000;">先将原来的头结点的下一个结点的指针保存起来</span>
<span style="color: #008080;">186</span>         <span style="color: #0000ff;">free</span>(*L); <span style="color: #008000;">//</span><span style="color: #008000;">释放原来的头结点</span>
<span style="color: #008080;">187</span>         *L=p; <span style="color: #008000;">//</span><span style="color: #008000;">将原来指向头结点的指针修改为现在的新头结点</span>
<span style="color: #008080;">188</span>         <span style="color: #0000ff;">return</span><span style="color: #000000;"> OK;
</span><span style="color: #008080;">189</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">190</span>     <span style="color: #0000ff;">if</span> (index&gt;getLength(*L)-<span style="color: #800080;">2</span><span style="color: #000000;">){
</span><span style="color: #008080;">191</span>         <span style="color: #008000;">//</span><span style="color: #008000;">尾删</span>
<span style="color: #008080;">192</span>         p=*L; <span style="color: #008000;">//</span><span style="color: #008000;">变量p用于遍历</span>
<span style="color: #008080;">193</span>         <span style="color: #0000ff;">while</span><span style="color: #000000;"> (p){
</span><span style="color: #008080;">194</span>             <span style="color: #008000;">//</span><span style="color: #008000;">寻找当前线性表的最后一个结点的前一个结点，将这个结点的后一个结点（即最后一个结点）删除</span>
<span style="color: #008080;">195</span>             <span style="color: #0000ff;">if</span> (p-&gt;next-&gt;next==<span style="color: #000000;">NULL)
</span><span style="color: #008080;">196</span>                 <span style="color: #008000;">//</span><span style="color: #008000;">找到</span>
<span style="color: #008080;">197</span>                 <span style="color: #0000ff;">break</span><span style="color: #000000;">;
</span><span style="color: #008080;">198</span>             p=p-&gt;next; <span style="color: #008000;">//</span><span style="color: #008000;">继续下一个结点</span>
<span style="color: #008080;">199</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">200</span>         <span style="color: #0000ff;">free</span>(p-&gt;next); <span style="color: #008000;">//</span><span style="color: #008000;">将原来线性表的最后一个结点删除</span>
<span style="color: #008080;">201</span>         p-&gt;next=NULL; <span style="color: #008000;">//</span><span style="color: #008000;">将原来的倒数第二个结点变成尾结点</span>
<span style="color: #008080;">202</span>         <span style="color: #0000ff;">return</span><span style="color: #000000;"> OK;
</span><span style="color: #008080;">203</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">204</span>     <span style="color: #008000;">//</span><span style="color: #008000;">不是头插也不是尾插</span>
<span style="color: #008080;">205</span>     p=*<span style="color: #000000;">L;
</span><span style="color: #008080;">206</span>     <span style="color: #0000ff;">for</span> (k=<span style="color: #800080;">0</span>; k&lt;index-<span style="color: #800080;">1</span>; k++<span style="color: #000000;">){
</span><span style="color: #008080;">207</span>         <span style="color: #008000;">//</span><span style="color: #008000;">遍历到第index个结点的前一个结点，头结点的index等于0
</span><span style="color: #008080;">208</span>         <span style="color: #008000;">//</span><span style="color: #008000;">利用index的前一个结点的next就可以知道第index个结点</span>
<span style="color: #008080;">209</span>         p=p-&gt;<span style="color: #000000;">next;
</span><span style="color: #008080;">210</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">211</span>     q=p-&gt;<span style="color: #000000;">next;
</span><span style="color: #008080;">212</span>     p-&gt;next=p-&gt;next-&gt;next; <span style="color: #008000;">//</span><span style="color: #008000;">将index前一个结点和后一个结点相连</span>
<span style="color: #008080;">213</span>     <span style="color: #0000ff;">free</span>(q); <span style="color: #008000;">//</span><span style="color: #008000;">删除index的结点</span>
<span style="color: #008080;">214</span>     <span style="color: #0000ff;">return</span><span style="color: #000000;"> OK;
</span><span style="color: #008080;">215</span> <span style="color: #000000;">}
</span><span style="color: #008080;">216</span> <span style="color: #0000ff;">void</span> showList(LinkList *<span style="color: #000000;">L){
</span><span style="color: #008080;">217</span>     <span style="color: #0000ff;">int</span><span style="color: #000000;"> i;
</span><span style="color: #008080;">218</span>     <span style="color: #0000ff;">int</span> total=<span style="color: #000000;">getLength(L);
</span><span style="color: #008080;">219</span>     LinkList * p=<span style="color: #000000;">L;
</span><span style="color: #008080;">220</span>     <span style="color: #0000ff;">for</span> (i=<span style="color: #800080;">0</span>; i&lt;total; i++<span style="color: #000000;">){
</span><span style="color: #008080;">221</span>         printf(<span style="color: #800000;">"</span><span style="color: #800000;">%c\t</span><span style="color: #800000;">"</span>,p-&gt;data); p=p-&gt;<span style="color: #000000;">next;
</span><span style="color: #008080;">222</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">223</span> <span style="color: #000000;">}
</span><span style="color: #008080;">224</span> 
<span style="color: #008080;">225</span> <span style="color: #008000;">/*</span>
<span style="color: #008080;">226</span> <span style="color: #008000;">    链式存储结构的线性表的优缺点：（注意，上述实现的链式线性表叫做单链表）
</span><span style="color: #008080;">227</span> <span style="color: #008000;">    优点：
</span><span style="color: #008080;">228</span> <span style="color: #008000;">        1.插入和删除的时间复杂度是0(1)
</span><span style="color: #008080;">229</span> <span style="color: #008000;">        2.存储空间不受预设限制
</span><span style="color: #008080;">230</span> <span style="color: #008000;">    缺点：
</span><span style="color: #008080;">231</span> <span style="color: #008000;">        1.寻找某个结点需要进行遍历操作
</span><span style="color: #008080;">232</span> <span style="color: #008000;">    另外，
</span><span style="color: #008080;">233</span> <span style="color: #008000;">        把单链表的尾结点的指针区指向头结点，便成为循环链表；
</span><span style="color: #008080;">234</span> <span style="color: #008000;">        把单链表的每个结点再增加一个指针区，新加的指针区指向前一个结点，便成为双向链表
</span><span style="color: #008080;">235</span> <span style="color: #008000;">*/</span>
<span style="color: #008080;">236</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> 环境: Code::Blocks with GCC 5.1 </span><span style="color: #008000;">*/</span></pre>
</div>
<p>&nbsp;</p>
<p>运行截图：</p>
<p><img src="https://img2018.cnblogs.com/i-beta/1326234/202001/1326234-20200119193747481-1734079600.png" alt="" width="424" height="280" /></p>]]></description></item><item><title>线性表的顺序存储结构（C语言实现）</title><link>http://www.cnblogs.com/ryzz/archive/2020/01/18/12209859.html</link><dc:creator>RYZZ</dc:creator><author>RYZZ</author><pubDate>Sat, 18 Jan 2020 10:34:00 GMT</pubDate><guid>http://www.cnblogs.com/ryzz/archive/2020/01/18/12209859.html</guid><description><![CDATA[<div class="cnblogs_code">
<pre><span style="color: #008080;">  1</span> #include &lt;stdio.h&gt;
<span style="color: #008080;">  2</span> #include &lt;stdlib.h&gt;
<span style="color: #008080;">  3</span> 
<span style="color: #008080;">  4</span> <span style="color: #0000ff;">#define</span> OK 1
<span style="color: #008080;">  5</span> <span style="color: #0000ff;">#define</span> ERR 2
<span style="color: #008080;">  6</span> <span style="color: #0000ff;">#define</span> TRUE 1
<span style="color: #008080;">  7</span> <span style="color: #0000ff;">#define</span> FALSE 0
<span style="color: #008080;">  8</span> <span style="color: #0000ff;">#define</span> MAXSIZE 20 <span style="color: #008000;">//</span><span style="color: #008000;">定义线性表的最大长度</span>
<span style="color: #008080;">  9</span> 
<span style="color: #008080;"> 10</span> typedef <span style="color: #0000ff;">int</span> status; <span style="color: #008000;">//</span><span style="color: #008000;">定义函数返回的状态，OK &amp; ERR</span>
<span style="color: #008080;"> 11</span> typedef <span style="color: #0000ff;">char</span> datatype; <span style="color: #008000;">//</span><span style="color: #008000;">定义线性表中每个结点的数据类型，这里暂定为字符型</span>
<span style="color: #008080;"> 12</span> 
<span style="color: #008080;"> 13</span> typedef <span style="color: #0000ff;">struct</span><span style="color: #000000;"> {
</span><span style="color: #008080;"> 14</span>     datatype data[MAXSIZE]; <span style="color: #008000;">//</span><span style="color: #008000;">存储着线性表中的每个结点</span>
<span style="color: #008080;"> 15</span>     <span style="color: #0000ff;">int</span> length; <span style="color: #008000;">//</span><span style="color: #008000;">线性表当前的长度</span>
<span style="color: #008080;"> 16</span> <span style="color: #000000;">} SequenceList;
</span><span style="color: #008080;"> 17</span> 
<span style="color: #008080;"> 18</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> 函数原型，线性表的基本操作 </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 19</span> SequenceList *createSequenceList(<span style="color: #0000ff;">void</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 20</span> status isEmpty(SequenceList *<span style="color: #000000;">L);
</span><span style="color: #008080;"> 21</span> <span style="color: #0000ff;">void</span> clear(SequenceList *<span style="color: #000000;">L);
</span><span style="color: #008080;"> 22</span> <span style="color: #0000ff;">int</span> getLength(SequenceList *<span style="color: #000000;">L);
</span><span style="color: #008080;"> 23</span> <span style="color: #0000ff;">int</span> locateNode(SequenceList *<span style="color: #000000;">L,datatype node_to_locate);
</span><span style="color: #008080;"> 24</span> datatype getNode(SequenceList *L, <span style="color: #0000ff;">int</span><span style="color: #000000;"> index);
</span><span style="color: #008080;"> 25</span> status insert(SequenceList *L, <span style="color: #0000ff;">int</span><span style="color: #000000;"> index, datatype node_to_insert);
</span><span style="color: #008080;"> 26</span> status delete(SequenceList *L, <span style="color: #0000ff;">int</span><span style="color: #000000;"> index);
</span><span style="color: #008080;"> 27</span> <span style="color: #0000ff;">void</span> showList(SequenceList *<span style="color: #000000;">L);
</span><span style="color: #008080;"> 28</span> 
<span style="color: #008080;"> 29</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
</span><span style="color: #008080;"> 30</span>     <span style="color: #008000;">/*</span><span style="color: #008000;"> 测试 </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 31</span>     SequenceList *root; <span style="color: #008000;">//</span><span style="color: #008000;">指向线性表</span>
<span style="color: #008080;"> 32</span>     root=createSequenceList(); <span style="color: #008000;">//</span><span style="color: #008000;">创建一个线性表</span>
<span style="color: #008080;"> 33</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">Length = %d\n</span><span style="color: #800000;">"</span>,getLength(root)); <span style="color: #008000;">//</span><span style="color: #008000;">打印线性表的当前长度</span>
<span style="color: #008080;"> 34</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">isEmpty = %d\n</span><span style="color: #800000;">"</span>,isEmpty(root)); <span style="color: #008000;">//</span><span style="color: #008000;">打印线性表是否为空</span>
<span style="color: #008080;"> 35</span>     insert(root,<span style="color: #800080;">0</span>,<span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span>); <span style="color: #008000;">//</span><span style="color: #008000;">分别插入4个结点</span>
<span style="color: #008080;"> 36</span>     insert(root,<span style="color: #800080;">0</span>,<span style="color: #800000;">'</span><span style="color: #800000;">B</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 37</span>     insert(root,<span style="color: #800080;">1</span>,<span style="color: #800000;">'</span><span style="color: #800000;">C</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 38</span>     insert(root,<span style="color: #800080;">1</span>,<span style="color: #800000;">'</span><span style="color: #800000;">D</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 39</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">Length = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,getLength(root));
</span><span style="color: #008080;"> 40</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">isEmpty = %d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,isEmpty(root));
</span><span style="color: #008080;"> 41</span>     showList(root); <span style="color: #008000;">//</span><span style="color: #008000;">打印线性表</span>
<span style="color: #008080;"> 42</span>     putchar(<span style="color: #800000;">'</span><span style="color: #800000;">\n</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 43</span>     delete(root,<span style="color: #800080;">1</span>); <span style="color: #008000;">//</span><span style="color: #008000;">删除index=1（数组下标为1）的结点</span>
<span style="color: #008080;"> 44</span> <span style="color: #000000;">    showList(root);
</span><span style="color: #008080;"> 45</span>     putchar(<span style="color: #800000;">'</span><span style="color: #800000;">\n</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 46</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">Locate = %d\n</span><span style="color: #800000;">"</span>,locateNode(root,<span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span>)); <span style="color: #008000;">//</span><span style="color: #008000;">打印查找到的结点的位置</span>
<span style="color: #008080;"> 47</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">getNode = %c\n</span><span style="color: #800000;">"</span>,getNode(root,<span style="color: #800080;">1</span>)); <span style="color: #008000;">//</span><span style="color: #008000;">打印下标是1的结点的值</span>
<span style="color: #008080;"> 48</span>     clear(root); <span style="color: #008000;">//</span><span style="color: #008000;">清空线性表</span>
<span style="color: #008080;"> 49</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">isEmpty = %d</span><span style="color: #800000;">"</span><span style="color: #000000;">,isEmpty(root));
</span><span style="color: #008080;"> 50</span> 
<span style="color: #008080;"> 51</span>     <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 52</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 53</span> 
<span style="color: #008080;"> 54</span> SequenceList *createSequenceList(<span style="color: #0000ff;">void</span><span style="color: #000000;">){
</span><span style="color: #008080;"> 55</span>     SequenceList *<span style="color: #000000;">tmp;
</span><span style="color: #008080;"> 56</span>     tmp=<span style="color: #0000ff;">malloc</span>(<span style="color: #0000ff;">sizeof</span>(SequenceList));<span style="color: #008000;">//</span><span style="color: #008000;">void*类型指针能自动转为其他类型的指针</span>
<span style="color: #008080;"> 57</span>     tmp-&gt;length=<span style="color: #800080;">0</span>; <span style="color: #008000;">//</span><span style="color: #008000;">初始化线性表长度</span>
<span style="color: #008080;"> 58</span>     <span style="color: #0000ff;">return</span><span style="color: #000000;"> tmp;
</span><span style="color: #008080;"> 59</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 60</span> status isEmpty(SequenceList *<span style="color: #000000;">L){
</span><span style="color: #008080;"> 61</span>     <span style="color: #0000ff;">if</span> (L-&gt;length==<span style="color: #800080;">0</span><span style="color: #000000;">)
</span><span style="color: #008080;"> 62</span>         <span style="color: #0000ff;">return</span><span style="color: #000000;"> TRUE;
</span><span style="color: #008080;"> 63</span>     <span style="color: #0000ff;">else</span>
<span style="color: #008080;"> 64</span>         <span style="color: #0000ff;">return</span><span style="color: #000000;"> FALSE;
</span><span style="color: #008080;"> 65</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 66</span> <span style="color: #0000ff;">void</span> clear(SequenceList *<span style="color: #000000;">L){
</span><span style="color: #008080;"> 67</span>     L-&gt;length=<span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 68</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 69</span> <span style="color: #0000ff;">int</span> getLength(SequenceList *<span style="color: #000000;">L){
</span><span style="color: #008080;"> 70</span>     <span style="color: #0000ff;">return</span> L-&gt;<span style="color: #000000;">length;
</span><span style="color: #008080;"> 71</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 72</span> <span style="color: #0000ff;">int</span> locateNode(SequenceList *<span style="color: #000000;">L, datatype node_to_locate){
</span><span style="color: #008080;"> 73</span>     <span style="color: #008000;">//</span><span style="color: #008000;">返回找到的结点的index
</span><span style="color: #008080;"> 74</span>     <span style="color: #008000;">//</span><span style="color: #008000;">node_to_locate应当是能唯一标识一个结点的数据，否则只返回匹配的第一个结点</span>
<span style="color: #008080;"> 75</span>     <span style="color: #0000ff;">int</span><span style="color: #000000;"> i;
</span><span style="color: #008080;"> 76</span>     <span style="color: #0000ff;">for</span> (i=<span style="color: #800080;">0</span>; i&lt;L-&gt;length; i++<span style="color: #000000;">){
</span><span style="color: #008080;"> 77</span>         <span style="color: #0000ff;">if</span> (L-&gt;data[i]==<span style="color: #000000;">node_to_locate)
</span><span style="color: #008080;"> 78</span>             <span style="color: #0000ff;">return</span><span style="color: #000000;"> i;
</span><span style="color: #008080;"> 79</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 80</span>     <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span>; <span style="color: #008000;">//</span><span style="color: #008000;">未找到任何匹配</span>
<span style="color: #008080;"> 81</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 82</span> datatype getNode(SequenceList *L, <span style="color: #0000ff;">int</span><span style="color: #000000;"> index){
</span><span style="color: #008080;"> 83</span>     <span style="color: #008000;">//</span><span style="color: #008000;">index表示线性表中第N个结点，头结点的index是0</span>
<span style="color: #008080;"> 84</span>     <span style="color: #0000ff;">if</span> (L-&gt;length==<span style="color: #800080;">0</span> || index&lt;<span style="color: #800080;">0</span> || index&gt;L-&gt;length-<span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> (datatype)ERR;
</span><span style="color: #008080;"> 85</span>     <span style="color: #0000ff;">return</span> L-&gt;<span style="color: #000000;">data[index];
</span><span style="color: #008080;"> 86</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 87</span> status insert(SequenceList *L, <span style="color: #0000ff;">int</span><span style="color: #000000;"> index, datatype node_to_insert){
</span><span style="color: #008080;"> 88</span>     <span style="color: #008000;">//</span><span style="color: #008000;">node_to_insert表示想要插入的结点
</span><span style="color: #008080;"> 89</span>     <span style="color: #008000;">//</span><span style="color: #008000;">当列表为空时，只有index=0才能插入</span>
<span style="color: #008080;"> 90</span>     <span style="color: #0000ff;">int</span><span style="color: #000000;"> k;
</span><span style="color: #008080;"> 91</span>     <span style="color: #0000ff;">if</span> (L-&gt;length == MAXSIZE) <span style="color: #0000ff;">return</span> ERR; <span style="color: #008000;">//</span><span style="color: #008000;">线性表已满</span>
<span style="color: #008080;"> 92</span>     <span style="color: #0000ff;">if</span> (index&lt;<span style="color: #800080;">0</span> || index&gt;L-&gt;length) <span style="color: #0000ff;">return</span> ERR; <span style="color: #008000;">//</span><span style="color: #008000;">index不在有效范围</span>
<span style="color: #008080;"> 93</span>     <span style="color: #0000ff;">if</span> (index&lt;L-&gt;<span style="color: #000000;">length){
</span><span style="color: #008080;"> 94</span>         <span style="color: #008000;">//</span><span style="color: #008000;">插入的位置不是最后一个结点的下一个结点</span>
<span style="color: #008080;"> 95</span>         <span style="color: #0000ff;">for</span> (k=L-&gt;length-<span style="color: #800080;">1</span>; k&gt;=index; k--<span style="color: #000000;">){
</span><span style="color: #008080;"> 96</span>             L-&gt;data[k+<span style="color: #800080;">1</span>]=L-&gt;data[k]; <span style="color: #008000;">//</span><span style="color: #008000;">将要插入结点后面的所有结点都往后移</span>
<span style="color: #008080;"> 97</span> <span style="color: #000000;">        }
</span><span style="color: #008080;"> 98</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 99</span>     L-&gt;data[index]=node_to_insert; <span style="color: #008000;">//</span><span style="color: #008000;">将新结点插入</span>
<span style="color: #008080;">100</span>     L-&gt;length++<span style="color: #000000;">;
</span><span style="color: #008080;">101</span>     <span style="color: #0000ff;">return</span><span style="color: #000000;"> OK;
</span><span style="color: #008080;">102</span> <span style="color: #000000;">}
</span><span style="color: #008080;">103</span> status delete(SequenceList *L, <span style="color: #0000ff;">int</span><span style="color: #000000;"> index){
</span><span style="color: #008080;">104</span>     <span style="color: #0000ff;">int</span><span style="color: #000000;"> k;
</span><span style="color: #008080;">105</span>     <span style="color: #0000ff;">if</span> (L-&gt;length == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> ERR; <span style="color: #008000;">//</span><span style="color: #008000;">线性表为空</span>
<span style="color: #008080;">106</span>     <span style="color: #0000ff;">if</span> (index&lt;<span style="color: #800080;">0</span> || index&gt;L-&gt;length-<span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> ERR; <span style="color: #008000;">//</span><span style="color: #008000;">index不在有效范围</span>
<span style="color: #008080;">107</span>     <span style="color: #0000ff;">if</span> (index&lt;L-&gt;length-<span style="color: #800080;">1</span><span style="color: #000000;">){
</span><span style="color: #008080;">108</span>         <span style="color: #008000;">//</span><span style="color: #008000;">删除的位置不是最后一个结点</span>
<span style="color: #008080;">109</span>         <span style="color: #0000ff;">for</span> (k=index; k&lt;L-&gt;length-<span style="color: #800080;">1</span>; k++<span style="color: #000000;">){
</span><span style="color: #008080;">110</span>                 L-&gt;data[k]=L-&gt;data[k+<span style="color: #800080;">1</span>]; <span style="color: #008000;">//</span><span style="color: #008000;">将删除位置后面的结点都往前移</span>
<span style="color: #008080;">111</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">112</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">113</span>     L-&gt;length--<span style="color: #000000;">;
</span><span style="color: #008080;">114</span>     <span style="color: #0000ff;">return</span><span style="color: #000000;"> OK;
</span><span style="color: #008080;">115</span> <span style="color: #000000;">}
</span><span style="color: #008080;">116</span> <span style="color: #0000ff;">void</span> showList(SequenceList *<span style="color: #000000;">L){
</span><span style="color: #008080;">117</span>     <span style="color: #0000ff;">int</span><span style="color: #000000;"> i;
</span><span style="color: #008080;">118</span>     <span style="color: #0000ff;">for</span> (i=<span style="color: #800080;">0</span>; i&lt;L-&gt;length; i++<span style="color: #000000;">){
</span><span style="color: #008080;">119</span>         printf(<span style="color: #800000;">"</span><span style="color: #800000;">%c\t</span><span style="color: #800000;">"</span>,L-&gt;<span style="color: #000000;">data[i]);
</span><span style="color: #008080;">120</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">121</span> <span style="color: #000000;">}
</span><span style="color: #008080;">122</span> 
<span style="color: #008080;">123</span> <span style="color: #008000;">/*</span>
<span style="color: #008080;">124</span> <span style="color: #008000;">    顺序存储结构的线性表的优缺点：
</span><span style="color: #008080;">125</span> <span style="color: #008000;">    优点：
</span><span style="color: #008080;">126</span> <span style="color: #008000;">        1.不必为每个结点之间的逻辑关系增加额外的存储空间
</span><span style="color: #008080;">127</span> <span style="color: #008000;">        2.可以快速地读和写表中任意一个结点
</span><span style="color: #008080;">128</span> <span style="color: #008000;">    缺点：
</span><span style="color: #008080;">129</span> <span style="color: #008000;">        1.插入和删除需要移动大量结点
</span><span style="color: #008080;">130</span> <span style="color: #008000;">        2.线性表动态变化较大，难以确定所需的存储空间
</span><span style="color: #008080;">131</span> <span style="color: #008000;">        3.数组预设过长会造成空间浪费（存储碎片）
</span><span style="color: #008080;">132</span> <span style="color: #008000;">*/</span>
<span style="color: #008080;">133</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> 环境: Code::Blocks with GCC 5.1 </span><span style="color: #008000;">*/</span></pre>
</div>
<p>运行截图：</p>
<p><img src="https://img2018.cnblogs.com/i-beta/1326234/202001/1326234-20200118184054844-1796212553.png" alt="" width="478" height="243" /></p>
]]></description></item><item><title>分析FAT32内部结构-入门篇-</title><link>http://www.cnblogs.com/ryzz/archive/2019/09/21/11562325.html</link><dc:creator>RYZZ</dc:creator><author>RYZZ</author><pubDate>Sat, 21 Sep 2019 04:18:00 GMT</pubDate><guid>http://www.cnblogs.com/ryzz/archive/2019/09/21/11562325.html</guid><description><![CDATA[<p>FAT32(File Allocation Table)<span style="font-family: 宋体;">是一种</span><span style="font-family: Calibri;">32</span><span style="font-family: 宋体;">位的</span><span style="font-family: Calibri;">FAT</span><span style="font-family: 宋体;">文件系统，微软在</span><span style="font-family: Calibri;">1996</span><span style="font-family: 宋体;">年</span><span style="font-family: Calibri;">8</span><span style="font-family: 宋体;">月发布。</span></p>
<p>FAT32<span style="font-family: 宋体;">的数字</span><span style="font-family: Calibri;">32</span><span style="font-family: 宋体;">是下面会讲到的</span><span style="font-family: Calibri;">FAT</span><span style="font-family: 宋体;">中每个表项的长度。</span></p>
<p>磁盘（硬盘）是数据的载体，而文件系统则是将这些数据以某种合理的结构组织起来方便操作系统的管理。</p>
<p><span style="font-family: 宋体;">借此文分析一下微软的</span>FAT32<span style="font-family: 宋体;">文件系统格式：（<strong>本文分析</strong></span><strong>的FAT32分区是D盘，大小为128MB</strong><span style="font-family: 宋体;"><strong>！环境为VMware虚拟机下的XP系统！</strong>）</span></p>
<p>FAT32<span style="font-family: 宋体;">由</span><span style="font-family: Calibri;">4</span><span style="font-family: 宋体;">个部分组成，分别是</span><span style="font-family: Calibri;">DBR,FAT1,FAT2</span><span style="font-family: 宋体;">和</span><span style="font-family: Calibri;">DATA</span><span style="font-family: 宋体;">，如图：</span></p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/blog/1326234/201909/1326234-20190921121143401-1598209756.png" alt="" /></p>
<p>DBR<span style="font-family: 宋体;">：该分区的引导程序，在</span><span style="font-family: Calibri;">DBR</span><span style="font-family: 宋体;">的结尾部分会有一些重要的保留扇区（这些保留扇区属于</span><span style="font-family: Calibri;">DBR</span><span style="font-family: 宋体;">，图中未画出）</span></p>
<p>FAT1<span style="font-family: 宋体;">：</span><span style="font-family: Calibri;">FAT</span><span style="font-family: 宋体;">的首要文件分配表</span></p>
<p>FAT2<span style="font-family: 宋体;">：文件分配表的备份</span></p>
<p>DATA<span style="font-family: 宋体;">：数据区（最小单位为簇</span><span style="font-family: Calibri;">(cluster)</span><span style="font-family: 宋体;">，一般</span><span style="font-family: Calibri;">2</span><span style="font-family: 宋体;">个扇区为</span><span style="font-family: Calibri;">1</span><span style="font-family: 宋体;">簇，是微软规定的一种磁盘存储单位，与</span><span style="font-family: Calibri;">Linux</span><span style="font-family: 宋体;">的</span><span style="font-family: Calibri;">block</span><span style="font-family: 宋体;">概念类似）</span></p>
<p>&nbsp;</p>
<p>FAT32<span style="font-family: 宋体;">的</span><span style="font-family: Calibri;">DBR</span><span style="font-family: 宋体;">结构图：</span></p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/blog/1326234/201909/1326234-20190921121153079-189091759.png" alt="" /></p>
<p><span style="font-family: 宋体;">红色：跳转指令，将当前执行流程跳转到引导程序处，占</span>2<span style="font-family: 宋体;">字节，对应汇编</span><span style="font-family: Calibri;">JUMP 58H; NOP;</span></p>
<p><span style="font-family: 宋体;">蓝色：</span>OEM<span style="font-family: 宋体;">代号，由创建该文件系统的厂商规定，占</span><span style="font-family: Calibri;">8</span><span style="font-family: 宋体;">字节，一般为</span>&rdquo;MSDOS5.0&rdquo;</p>
<p><span style="font-family: 宋体;">绿色：</span>BPB(BIOS Paramter Block)<span style="font-family: 宋体;">，从</span><span style="font-family: Calibri;">DBR</span><span style="font-family: 宋体;">的第</span><span style="font-family: Calibri;">12</span><span style="font-family: 宋体;">个字节开始共占用</span><span style="font-family: Calibri;">79</span><span style="font-family: 宋体;">字节，记录了文件系统的重要信息，相关字段参数见下表</span></p>
<p><span style="font-family: 宋体;">粉红色：</span>DBR<span style="font-family: 宋体;">引导程序，如果该分区没安装操作系统那么这段程序是没用的</span></p>
<p><span style="font-family: 宋体;">黄色：</span>DBR<span style="font-family: 宋体;">结束标记</span></p>
<table border="1" cellspacing="0">
<tbody>
<tr>
<td colspan="3" valign="top" width="568">
<p>BPB<span style="font-family: 宋体;">表：</span></p>
</td>
</tr>
<tr>
<td valign="top" width="49">
<p>偏移</p>
</td>
<td valign="top" width="32">
<p>字节</p>
</td>
<td valign="top" width="486">
<p>含义</p>
</td>
</tr>
<tr>
<td valign="top" width="49">
<p>BH</p>
</td>
<td valign="top" width="32">
<p>2</p>
</td>
<td valign="top" width="486">
<p>每扇区的字节个数</p>
</td>
</tr>
<tr>
<td valign="top" width="49">
<p>DH</p>
</td>
<td valign="top" width="32">
<p>1</p>
</td>
<td valign="top" width="486">
<p>每簇扇区数</p>
</td>
</tr>
<tr>
<td valign="top" width="49">
<p>EH</p>
</td>
<td valign="top" width="32">
<p>2</p>
</td>
<td valign="top" width="486">
<p>保留的扇区个数</p>
</td>
</tr>
<tr>
<td valign="top" width="49">
<p>10H</p>
</td>
<td valign="top" width="32">
<p>1</p>
</td>
<td valign="top" width="486">
<p>FAT<span style="font-family: 宋体;">个数</span></p>
</td>
</tr>
<tr>
<td valign="top" width="49">
<p>11H</p>
</td>
<td valign="top" width="32">
<p>2</p>
</td>
<td valign="top" width="486">
<p>不使用（根目录数量，<span style="font-family: Calibri;">FAT32</span><span style="font-family: 宋体;">已突破此限制，已无效，一般为</span><span style="font-family: Calibri;">0</span><span style="font-family: 宋体;">）</span></p>
</td>
</tr>
<tr>
<td valign="top" width="49">
<p>13H</p>
</td>
<td valign="top" width="32">
<p>2</p>
</td>
<td valign="top" width="486">
<p>不使用（扇区总数，小于<span style="font-family: Calibri;">32M</span><span style="font-family: 宋体;">时才使用）</span></p>
</td>
</tr>
<tr>
<td valign="top" width="49">
<p>15H</p>
</td>
<td valign="top" width="32">
<p>1</p>
</td>
<td valign="top" width="486">
<p>存储介质描述符</p>
</td>
</tr>
<tr>
<td valign="top" width="49">
<p>16H</p>
</td>
<td valign="top" width="32">
<p>2</p>
</td>
<td valign="top" width="486">
<p>不使用（<span style="font-family: Calibri;">FAT</span><span style="font-family: 宋体;">占的扇区数，小于</span><span style="font-family: Calibri;">32M</span><span style="font-family: 宋体;">时才使用）</span></p>
</td>
</tr>
<tr>
<td valign="top" width="49">
<p>18H</p>
</td>
<td valign="top" width="32">
<p>2</p>
</td>
<td valign="top" width="486">
<p>每磁道扇区个数</p>
</td>
</tr>
<tr>
<td valign="top" width="49">
<p>1AH</p>
</td>
<td valign="top" width="32">
<p>2</p>
</td>
<td valign="top" width="486">
<p>磁头数</p>
</td>
</tr>
<tr>
<td valign="top" width="49">
<p>1CH</p>
</td>
<td valign="top" width="32">
<p>4</p>
</td>
<td valign="top" width="486">
<p>隐藏扇区</p>
</td>
</tr>
<tr>
<td valign="top" width="49">
<p>20H</p>
</td>
<td valign="top" width="32">
<p>4</p>
</td>
<td valign="top" width="486">
<p>扇区总数（大于<span style="font-family: Calibri;">32M</span><span style="font-family: 宋体;">时使用）</span></p>
</td>
</tr>
<tr>
<td valign="top" width="49">
<p>24H</p>
</td>
<td valign="top" width="32">
<p>4</p>
</td>
<td valign="top" width="486">
<p>FAT<span style="font-family: 宋体;">占的扇区数（大于</span><span style="font-family: Calibri;">32M</span><span style="font-family: 宋体;">时使用）</span></p>
</td>
</tr>
<tr>
<td valign="top" width="49">
<p>28H</p>
</td>
<td valign="top" width="32">
<p>2</p>
</td>
<td valign="top" width="486">
<p>扩展标记</p>
</td>
</tr>
<tr>
<td valign="top" width="49">
<p>2AH</p>
</td>
<td valign="top" width="32">
<p>2</p>
</td>
<td valign="top" width="486">
<p>版本，一般为<span style="font-family: Calibri;">0</span></p>
</td>
</tr>
<tr>
<td valign="top" width="49">
<p>2CH</p>
</td>
<td valign="top" width="32">
<p>4</p>
</td>
<td valign="top" width="486">
<p>根目录的首簇号</p>
</td>
</tr>
<tr>
<td valign="top" width="49">
<p>30H</p>
</td>
<td valign="top" width="32">
<p>2</p>
</td>
<td valign="top" width="486">
<p>文件系统整体信息扇区号</p>
</td>
</tr>
<tr>
<td valign="top" width="49">
<p>32H</p>
</td>
<td valign="top" width="32">
<p>2</p>
</td>
<td valign="top" width="486">
<p>DBR<span style="font-family: 宋体;">备份所在的扇区号</span></p>
</td>
</tr>
<tr>
<td valign="top" width="49">
<p>34H</p>
</td>
<td valign="top" width="32">
<p>12</p>
</td>
<td valign="top" width="486">
<p>保留，固定为<span style="font-family: Calibri;">0</span></p>
</td>
</tr>
<tr>
<td valign="top" width="49">
<p>40H</p>
</td>
<td valign="top" width="32">
<p>1</p>
</td>
<td valign="top" width="486">
<p>BIOS<span style="font-family: 宋体;">驱动器号</span></p>
</td>
</tr>
<tr>
<td valign="top" width="49">
<p>41H</p>
</td>
<td valign="top" width="32">
<p>1</p>
</td>
<td valign="top" width="486">
<p>不使用，一般为<span style="font-family: Calibri;">0</span></p>
</td>
</tr>
<tr>
<td valign="top" width="49">
<p>42H</p>
</td>
<td valign="top" width="32">
<p>1</p>
</td>
<td valign="top" width="486">
<p>扩展引导标记</p>
</td>
</tr>
<tr>
<td valign="top" width="49">
<p>43H</p>
</td>
<td valign="top" width="32">
<p>4</p>
</td>
<td valign="top" width="486">
<p>卷序列号</p>
</td>
</tr>
<tr>
<td valign="top" width="49">
<p>47H</p>
</td>
<td valign="top" width="32">
<p>11</p>
</td>
<td valign="top" width="486">
<p>卷标</p>
</td>
</tr>
<tr>
<td valign="top" width="49">
<p>52H</p>
</td>
<td valign="top" width="32">
<p>8</p>
</td>
<td valign="top" width="486">
<p>文件系统类型名，固定为&rdquo;FAT32 &nbsp;&nbsp;&rdquo;</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>FAT32<span style="font-family: 宋体;">文件系统在</span><span style="font-family: Calibri;">DBR</span><span style="font-family: 宋体;">的保留扇区中</span>有<span style="font-family: 宋体;">一个文件系统信息扇区，用以记录数据区中空闲簇的数量及下一个空闲簇的簇号，该扇区一般在分区的</span>LAB1<span style="font-family: 宋体;">扇区，也就是紧跟着</span><span style="font-family: Calibri;">DBR</span><span style="font-family: 宋体;">后的一个扇区，其内如下：</span></p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/blog/1326234/201909/1326234-20190921121205167-189024457.png" alt="" /></p>
<p><span style="font-family: 宋体;">褐色：扩展引导标签，为</span>52 52 61 41<span style="font-family: 宋体;">，</span><span style="font-family: Calibri;">ASCII</span><span style="font-family: 宋体;">为</span>&rdquo;RRaA&rdquo;</p>
<p><span style="font-family: 宋体;">青色：文件系统信息签名，为</span>72 72 41 61<span style="font-family: 宋体;">，</span><span style="font-family: Calibri;">ASCII</span><span style="font-family: 宋体;">为</span>&rdquo;rrAa&rdquo;</p>
<p><span style="font-family: 宋体;">蓝色：空闲簇的数量，</span>(1FBB0)=129968<span style="font-family: 宋体;">，每个簇</span><span style="font-family: Calibri;">1K</span><span style="font-family: 宋体;">，约等于</span><span style="font-family: Calibri;">127MB</span><span style="font-family: 宋体;">，即</span>D盘<span style="font-family: 宋体;">的大小</span></p>
<p>紫色：下一个空闲簇的簇号</p>
<p>黄色：结束标记</p>
<p><span style="font-family: 宋体;">其他字节：不使用，填充</span>0</p>
<p>&nbsp;</p>
<p><span style="font-family: 宋体;">由于</span>FAT<span style="font-family: 宋体;">紧跟在</span><span style="font-family: Calibri;">DBR</span><span style="font-family: 宋体;">的保留扇区之后，所以定位到最后一个保留扇区，那么下一个扇区就是</span><span style="font-family: Calibri;">FAT</span><span style="font-family: 宋体;">啦！</span></p>
<p><span style="font-family: 宋体;">在上面的</span>DBR<span style="font-family: 宋体;">图中可以找到保留扇区的个数为</span><span style="font-family: Calibri;">20H=32</span><span style="font-family: 宋体;">（</span><span style="font-family: Calibri;">20 00</span><span style="font-family: 宋体;">是小端表示法），所以</span><span style="font-family: Calibri;">DBR</span><span style="font-family: 宋体;">往后</span><span style="font-family: Calibri;">32</span><span style="font-family: 宋体;">个扇区就是首要</span><span style="font-family: Calibri;">FAT</span><span style="font-family: 宋体;">啦，如图：</span></p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/blog/1326234/201909/1326234-20190921121214319-20798062.png" alt="" /></p>
<p>&nbsp;</p>
<p>FAT<span style="font-family: 宋体;">以</span><span style="font-family: Calibri;">4</span><span style="font-family: 宋体;">字节（</span><span style="font-family: Calibri;">32</span><span style="font-family: 宋体;">位）为一个表项，每个表项值的含义：</span></p>
<table border="1" cellspacing="0">
<tbody>
<tr>
<td valign="top" width="284">
<p>0x0000 0000</p>
</td>
<td valign="top" width="284">
<p>空闲簇，可用簇</p>
</td>
</tr>
<tr>
<td valign="top" width="284">
<p>0x0000 0001</p>
</td>
<td valign="top" width="284">
<p>保留簇</p>
</td>
</tr>
<tr>
<td valign="top" width="284">
<p>0x0000 0002 ~ 0x0FFF FFEF</p>
</td>
<td valign="top" width="284">
<p>该簇已用，其值指向下一个簇号</p>
</td>
</tr>
<tr>
<td valign="top" width="284">
<p>0x0FFF FFF0 ~ 0X0FFF FFF6</p>
</td>
<td valign="top" width="284">
<p>这些值保留，不使用</p>
</td>
</tr>
<tr>
<td valign="top" width="284">
<p>0x0FFF FFF7</p>
</td>
<td valign="top" width="284">
<p>坏簇，当一个簇中有一个扇区损坏（如物理损坏、病毒感染）时称为坏簇，这个簇将不被<span style="font-family: Calibri;">FAT32</span><span style="font-family: 宋体;">使用</span></p>
</td>
</tr>
<tr>
<td valign="top" width="284">
<p>0x0FFF FFF8 ~ 0x0FFF FFFF</p>
</td>
<td valign="top" width="284">
<p>文件的最后一个簇</p>
</td>
</tr>
</tbody>
</table>
<p><span style="font-family: 宋体;">每个表项的值对应了相应簇的使用情况，如</span>2<span style="font-family: 宋体;">号表项对应了</span><span style="font-family: Calibri;">2</span><span style="font-family: 宋体;">号簇的使用情况，</span><span style="font-family: Calibri;">3</span><span style="font-family: 宋体;">号表项对应了</span><span style="font-family: Calibri;">3</span><span style="font-family: 宋体;">号簇的使用情况，注意的是，最开头的两个表项是不使用的，它们代表</span><span style="font-family: Calibri;">FAT</span><span style="font-family: 宋体;">的表头，其值是固定的</span><span style="font-family: Calibri;">0xFFF FFF8</span><span style="font-family: 宋体;">和</span><span style="font-family: Calibri;">0xFFFF FFFF</span><span style="font-family: 宋体;">，所以！</span><span style="font-family: Calibri;">FAT32</span><span style="font-family: 宋体;">中不存在</span><span style="font-family: Calibri;">0</span><span style="font-family: 宋体;">号簇和</span><span style="font-family: Calibri;">1</span><span style="font-family: 宋体;">号簇，第</span><span style="font-family: Calibri;">1</span><span style="font-family: 宋体;">个簇是</span><span style="font-family: Calibri;">2</span><span style="font-family: 宋体;">号簇！画张图：</span></p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/blog/1326234/201909/1326234-20190921121221588-767383399.png" alt="" /></p>
<p>&nbsp;</p>
<p><span style="font-family: 宋体;">如果该簇是文件的最后一簇，填入的值为</span>0x0FFFFFFF，<span style="font-family: 宋体;">如果该簇不是文件的最后一簇，则填入的值为该文件占用的下一簇号</span>（<span style="font-family: 宋体;">所以可以看</span>出<span style="font-family: 宋体;">在</span>FAT32文件系统<span style="font-family: 宋体;">中文件是以</span>簇链表<span style="font-family: 宋体;">的形式保存起来的</span>）。</p>
<p>2<span style="font-family: 宋体;">号表项</span><span style="font-family: 宋体;">存储的是</span>2<span style="font-family: 宋体;">号簇</span><span style="font-family: 宋体;">的使用情况，</span><span style="font-family: 宋体;">一般</span>2<span style="font-family: 宋体;">号</span><span style="font-family: 宋体;">簇</span><span style="font-family: 宋体;">（也就是文件系统的第</span>1<span style="font-family: 宋体;">个簇）</span><span style="font-family: 宋体;">存储的是文件系统的根目录</span>，<span style="font-family: 宋体;">虽然在</span>FAT32<span style="font-family: 宋体;">中，根目录的位置不再硬性固定，可以存储在分区内可寻址的任意簇内，不过通常根目录是最早建立的</span>（<span style="font-family: 宋体;">格式化</span>时）<span style="font-family: 宋体;">目录</span>，<span style="font-family: 宋体;">所以基本上都是根目录首簇紧邻</span>FAT2<span style="font-family: 宋体;">，占簇区顺序上的第</span><span style="font-family: Calibri;">1</span><span style="font-family: 宋体;">个簇（即</span><span style="font-family: Calibri;">2</span><span style="font-family: 宋体;">号簇）</span>，<span style="font-family: 宋体;">同时，</span>FAT32<span style="font-family: 宋体;">将根目录当做普通的数据文件，所有没有了目录</span>个<span style="font-family: 宋体;">数的限制，在需要的时候可以分配空簇</span>。<span style="font-family: 宋体;">这一项</span><span style="font-family: 宋体;">（</span>2<span style="font-family: 宋体;">号表项）</span><span style="font-family: 宋体;">的值为</span>0x0FFFFFFF <span style="font-family: 宋体;">，说明</span>当前<span style="font-family: 宋体;">根目录占了</span>1<span style="font-family: 宋体;">个簇</span>的大小<span style="font-family: 宋体;">。</span></p>
<p><span style="font-family: 宋体;">现在来分析数据区，数据区是紧接在</span>FAT2<span style="font-family: 宋体;">之后的，所以在</span><span style="font-family: Calibri;">DBR</span><span style="font-family: 宋体;">往后（保留扇区</span><span style="font-family: Calibri;">+FAT1</span><span style="font-family: 宋体;">占用的扇区</span><span style="font-family: Calibri;">+FAT2</span><span style="font-family: 宋体;">占用的扇区）个扇区就是数据区啦，如图（这是数据区的第一个扇区，也是第一个簇的前半部分）：</span></p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/blog/1326234/201909/1326234-20190921121243054-155514071.png" alt="" /></p>
<p><span style="font-family: 宋体;">发现前</span>11<span style="font-family: 宋体;">字节是我们的卷标！</span></p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/blog/1326234/201909/1326234-20190921121248424-1804056454.png" alt="" /></p>
<p>&nbsp;</p>
<p><span style="font-family: 宋体;">而在</span>BPB<span style="font-family: 宋体;">中卷标那项的值永远是</span>&rdquo;NO NAME &nbsp;&nbsp;&nbsp;&rdquo;<span style="font-family: 宋体;">，也就是说卷标被移动到了数据区的前</span>11<span style="font-family: 宋体;">字节，而且</span><span style="font-family: Calibri;">FAT32</span><span style="font-family: 宋体;">卷标最长</span><span style="font-family: Calibri;">11</span><span style="font-family: 宋体;">字节（因为</span><span style="font-family: Calibri;">BPB</span><span style="font-family: 宋体;">中已经规定了），而</span><span style="font-family: Calibri;">NTFS</span><span style="font-family: 宋体;">已经突破了这个限制。</span></p>
<p>其实，卷标是根目录下的第一个文件！</p>
<p>&nbsp;</p>
<p><span style="font-family: 宋体;">现在来分析一下</span>FAT32<span style="font-family: 宋体;">下文件和目录之间是如何组织的，如何存储的，如何保存属性的：</span></p>
<p><span style="font-family: 宋体;">先低级格式化</span>D<span style="font-family: 宋体;">盘，以确保分区干净（指的是数据区全填充为</span><span style="font-family: Calibri;">0</span><span style="font-family: 宋体;">），</span></p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/blog/1326234/201909/1326234-20190921121310105-1352442345.png" alt="" /></p>
<p>&nbsp;</p>
<p><span style="font-family: 宋体;">低级格式化完成（如果分区较大，低格的速度会变慢，耐心等待）之后，查看一个首要</span>FAT<span style="font-family: 宋体;">表，</span></p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/blog/1326234/201909/1326234-20190921121318332-551236514.png" alt="" /></p>
<p>&nbsp;</p>
<p><span style="font-family: 宋体;">有一个表项，它的值为</span>FFF FFFFH<span style="font-family: 宋体;">，意思就是结束簇，这就是我们的根目录啦，再查看一个根目录所在的起始簇，</span></p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/blog/1326234/201909/1326234-20190921121324638-108683975.png" alt="" /></p>
<p>&nbsp;</p>
<p><span style="font-family: 宋体;">发现前两行（</span>32<span style="font-family: 宋体;">字节）有数据，后面全是</span><span style="font-family: Calibri;">0</span><span style="font-family: 宋体;">，然后我们在</span><span style="font-family: Calibri;">D</span><span style="font-family: 宋体;">盘（根目录）下粘贴一个空文件（在其他盘（如</span><span style="font-family: Calibri;">C</span><span style="font-family: 宋体;">盘）新建一个文本文件，然后复制到</span><span style="font-family: Calibri;">D</span><span style="font-family: 宋体;">盘，下面会讲为什么不能直接在</span><span style="font-family: Calibri;">D</span><span style="font-family: 宋体;">盘新建文件，而非要从其他盘复制），</span></p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/blog/1326234/201909/1326234-20190921121331348-1090512504.png" alt="" /></p>
<p>&nbsp;</p>
<p><span style="font-family: 宋体;">再去首要</span>FAT<span style="font-family: 宋体;">中查看变化，</span>发现没有变化，看起来新建的文件不占表项，再去根目录所在簇查看一下，</p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/blog/1326234/201909/1326234-20190921121345678-1463829794.png" alt="" /></p>
<p>&nbsp;</p>
<p><span style="font-family: 宋体;">发现！多了</span>2<span style="font-family: 宋体;">行（</span><span style="font-family: Calibri;">32</span><span style="font-family: 宋体;">字节），这就是我们刚刚新建（其实是粘贴）的空文件</span><span style="font-family: Calibri;">A.TXT</span><span style="font-family: 宋体;">啦，现在我们要引入一个</span><span style="font-family: Calibri;">FAT32</span><span style="font-family: 宋体;">下短文件目录项概念了，来个表格，</span></p>
<table border="1" cellspacing="0">
<tbody>
<tr>
<td valign="top" width="83">
<p>字节偏移</p>
</td>
<td colspan="2" valign="top" width="68">
<p>字节数</p>
</td>
<td valign="top" width="261">
<p>说明</p>
</td>
</tr>
<tr>
<td valign="top" width="83">
<p>0H</p>
</td>
<td colspan="2" valign="top" width="68">
<p>8</p>
</td>
<td valign="top" width="261">
<p>文件名</p>
</td>
</tr>
<tr>
<td valign="top" width="83">
<p>8H</p>
</td>
<td colspan="2" valign="top" width="68">
<p>3</p>
</td>
<td valign="top" width="261">
<p>后缀名，扩展名，类型名</p>
</td>
</tr>
<tr>
<td rowspan="7" valign="top" width="83">
<p>BH</p>
</td>
<td rowspan="7" valign="top" width="34">
<p>1</p>
</td>
<td rowspan="7" valign="top" width="34">
<p>文件属性</p>
</td>
<td valign="top" width="261">
<p>0000 0000B, 0H <span style="font-family: 宋体;">读写</span></p>
</td>
</tr>
<tr>
<td valign="top" width="261">
<p>0000 0001B, 1H <span style="font-family: 宋体;">只读</span></p>
</td>
</tr>
<tr>
<td valign="top" width="261">
<p>0000 0010B, 2H <span style="font-family: 宋体;">隐藏</span></p>
</td>
</tr>
<tr>
<td valign="top" width="261">
<p>0000 0100B, 4H <span style="font-family: 宋体;">系统</span></p>
</td>
</tr>
<tr>
<td valign="top" width="261">
<p>0000 1000B, 8H <span style="font-family: 宋体;">卷标</span></p>
</td>
</tr>
<tr>
<td valign="top" width="261">
<p>0001 0000B, 10H <span style="font-family: 宋体;">子目录</span></p>
</td>
</tr>
<tr>
<td valign="top" width="261">
<p>0010 0000B, 20H <span style="font-family: 宋体;">归档</span></p>
</td>
</tr>
<tr>
<td valign="top" width="83">
<p>CH</p>
</td>
<td colspan="2" valign="top" width="68">
<p>1</p>
</td>
<td valign="top" width="261">
<p>保留</p>
</td>
</tr>
<tr>
<td valign="top" width="83">
<p>DH</p>
</td>
<td colspan="2" valign="top" width="68">
<p>1</p>
</td>
<td valign="top" width="261">
<p>创建时间的<span style="font-family: Calibri;">10</span><span style="font-family: 宋体;">毫秒位</span></p>
</td>
</tr>
<tr>
<td valign="top" width="83">
<p>EH</p>
</td>
<td colspan="2" valign="top" width="68">
<p>2</p>
</td>
<td valign="top" width="261">
<p>创建时间</p>
</td>
</tr>
<tr>
<td valign="top" width="83">
<p>10H</p>
</td>
<td colspan="2" valign="top" width="68">
<p>2</p>
</td>
<td valign="top" width="261">
<p>创建日期</p>
</td>
</tr>
<tr>
<td valign="top" width="83">
<p>12H</p>
</td>
<td colspan="2" valign="top" width="68">
<p>2</p>
</td>
<td valign="top" width="261">
<p>最后一次访问的日期</p>
</td>
</tr>
<tr>
<td valign="top" width="83">
<p>14H</p>
</td>
<td colspan="2" valign="top" width="68">
<p>2</p>
</td>
<td valign="top" width="261">
<p>起始簇号的高<span style="font-family: Calibri;">16</span><span style="font-family: 宋体;">位</span></p>
</td>
</tr>
<tr>
<td valign="top" width="83">
<p>16H</p>
</td>
<td colspan="2" valign="top" width="68">
<p>2</p>
</td>
<td valign="top" width="261">
<p>最近一次修改的时间</p>
</td>
</tr>
<tr>
<td valign="top" width="83">
<p>18H</p>
</td>
<td colspan="2" valign="top" width="68">
<p>2</p>
</td>
<td valign="top" width="261">
<p>最近一次修改的日期</p>
</td>
</tr>
<tr>
<td valign="top" width="83">
<p>1AH</p>
</td>
<td colspan="2" valign="top" width="68">
<p>2</p>
</td>
<td valign="top" width="261">
<p>起始簇号的低<span style="font-family: Calibri;">16</span><span style="font-family: 宋体;">位</span></p>
</td>
</tr>
<tr>
<td valign="top" width="83">
<p>1CH</p>
</td>
<td colspan="2" valign="top" width="68">
<p>4</p>
</td>
<td valign="top" width="261">
<p>文件长度</p>
</td>
</tr>
</tbody>
</table>
<p><span style="font-family: 宋体;">可以看出文件长度为</span>0<span style="font-family: 宋体;">，起始簇号高</span><span style="font-family: Calibri;">16</span><span style="font-family: 宋体;">位为</span><span style="font-family: Calibri;">0H</span><span style="font-family: 宋体;">，低</span><span style="font-family: Calibri;">16</span><span style="font-family: 宋体;">位也为</span><span style="font-family: Calibri;">0H</span><span style="font-family: 宋体;">，也就是指向</span><span style="font-family: Calibri;">0</span><span style="font-family: 宋体;">号簇，但是</span><span style="font-family: Calibri;">0</span><span style="font-family: 宋体;">号簇不存在，所以此文件不存在起始簇，也就验证了文件长度为</span><span style="font-family: Calibri;">0</span><span style="font-family: 宋体;">，现在我们用记事本打开此文件，向其中写几个单词，</span></p>
<p>&nbsp;</p>
<p>再来看看此文件的属性，</p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/blog/1326234/201909/1326234-20190921121410281-2044196018.png" alt="" /></p>
<p>&nbsp;</p>
<p><span style="font-family: 宋体;">现在先去看一下首要</span>FAT<span style="font-family: 宋体;">的变化，</span></p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/blog/1326234/201909/1326234-20190921121420598-775849842.png" alt="" /></p>
<p>&nbsp;</p>
<p><span style="font-family: 宋体;">哈哈，多了一个表项哦，这个多的表项的值也是</span>FFF FFFFH<span style="font-family: 宋体;">，也就是结束簇，我们再去根目录所在簇看看，</span></p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/blog/1326234/201909/1326234-20190921121429512-842763097.png" alt="" /></p>
<p>&nbsp;</p>
<p><span style="font-family: 宋体;">发现了没，起始簇号和文件长度都发现了相应的变化，图中给出了计算值，这符合前面用右键查看的</span>A.TXT<span style="font-family: 宋体;">属性，且起始簇号为</span><span style="font-family: Calibri;">3</span><span style="font-family: 宋体;">也是正确的，因为簇号</span><span style="font-family: Calibri;">2</span><span style="font-family: 宋体;">被根目录所占用，那么下一个簇号就是</span><span style="font-family: Calibri;">3</span><span style="font-family: 宋体;">啦，现在我们去簇号</span><span style="font-family: Calibri;">3</span><span style="font-family: 宋体;">看看，</span></p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/blog/1326234/201909/1326234-20190921121438702-1029691295.png" alt="" /></p>
<p>&nbsp;</p>
<p><span style="font-family: 宋体;">现在我们将</span>A.TXT<span style="font-family: 宋体;">增加到几</span><span style="font-family: Calibri;">KB</span><span style="font-family: 宋体;">（我从网上找了微软的百度百科复制了其中一段），这里需要注意，因为我这个</span><span style="font-family: Calibri;">D</span><span style="font-family: 宋体;">盘的簇大小仅仅为</span><span style="font-family: Calibri;">1KB</span><span style="font-family: 宋体;">，所以大于</span><span style="font-family: Calibri;">1KB</span><span style="font-family: 宋体;">就可以完成本步骤的实验了，如果你们的簇大小为</span><span style="font-family: Calibri;">NKB</span><span style="font-family: 宋体;">，那么</span><span style="font-family: Calibri;">A.TXT</span><span style="font-family: 宋体;">需要大于</span><span style="font-family: Calibri;">NKB</span><span style="font-family: 宋体;">才行，</span></p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/blog/1326234/201909/1326234-20190921121447887-1231982184.png" alt="" /></p>
<p>&nbsp;</p>
<p>然后我们先去根目录查看一下，</p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/blog/1326234/201909/1326234-20190921121459458-398240325.png" alt="" /></p>
<p>&nbsp;</p>
<p><span style="font-family: 宋体;">数值又发生了变化，但是一定和上图的属性中一样，这里不再计算，然后我们再去首要</span>FAT<span style="font-family: 宋体;">看一下，</span></p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/blog/1326234/201909/1326234-20190921121506142-911126456.png" alt="" /></p>
<p>&nbsp;</p>
<p><span style="font-family: 宋体;">发现，多了</span>6<span style="font-family: 宋体;">项，且原来的</span><span style="font-family: Calibri;">3</span><span style="font-family: 宋体;">号表项已经不是</span><span style="font-family: Calibri;">FFF FFFFH</span><span style="font-family: 宋体;">了，取而代之的是</span><span style="font-family: Calibri;">9</span><span style="font-family: 宋体;">号表项变成了</span><span style="font-family: Calibri;">FFF FFFFH</span><span style="font-family: 宋体;">，这样就形成了簇链，文件系统读取时就通过这个单链表读取，我们简单计算一下，</span><span style="font-family: Calibri;">A.TXT</span><span style="font-family: 宋体;">最多占</span><span style="font-family: Calibri;">7</span><span style="font-family: 宋体;">个簇（第</span><span style="font-family: Calibri;">7</span><span style="font-family: 宋体;">个簇恰好全部用完，即占用空间的大小），最少占</span><span style="font-family: Calibri;">6</span><span style="font-family: 宋体;">个簇（第</span><span style="font-family: Calibri;">7</span><span style="font-family: 宋体;">个簇只用了</span><span style="font-family: Calibri;">1</span><span style="font-family: 宋体;">个字节），那么推测出</span><span style="font-family: Calibri;">A.TXT</span><span style="font-family: 宋体;">大小在</span><span style="font-family: Calibri;">[6144+1,7168]</span><span style="font-family: 宋体;">字节，而</span><span style="font-family: Calibri;">A.TXT</span><span style="font-family: 宋体;">在其的属性截图中大小为</span><span style="font-family: Calibri;">6546</span><span style="font-family: 宋体;">字节，占用空间为</span><span style="font-family: Calibri;">7168</span><span style="font-family: 宋体;">字节，完全符合，</span></p>
<p><span style="font-family: 宋体;">现在我们来看一下</span>FAT32<span style="font-family: 宋体;">的长文件目录项格式（现在基本用的都是长文件名啦），</span></p>
<table border="1" cellspacing="0">
<tbody>
<tr>
<td valign="top" width="72">
<p>字节偏移</p>
</td>
<td valign="top" width="62">
<p>字节数</p>
</td>
<td valign="top" width="432">
<p>说明</p>
</td>
</tr>
<tr>
<td rowspan="4" valign="top" width="72">
<p>0H</p>
</td>
<td rowspan="4" valign="top" width="62">
<p>1</p>
</td>
<td valign="top" width="432">
<p>第<span style="font-family: Calibri;">7</span><span style="font-family: 宋体;">位：保留</span></p>
</td>
</tr>
<tr>
<td valign="top" width="432">
<p>第<span style="font-family: Calibri;">6</span><span style="font-family: 宋体;">位：</span><span style="font-family: Calibri;">1</span><span style="font-family: 宋体;">表示长文件最后一个目录项</span></p>
</td>
</tr>
<tr>
<td valign="top" width="432">
<p>第<span style="font-family: Calibri;">5</span><span style="font-family: 宋体;">位：保留</span></p>
</td>
</tr>
<tr>
<td valign="top" width="432">
<p>第<span style="font-family: Calibri;">0~4</span><span style="font-family: 宋体;">位：顺序号</span></p>
</td>
</tr>
<tr>
<td valign="top" width="72">
<p>1H</p>
</td>
<td valign="top" width="62">
<p>10</p>
</td>
<td valign="top" width="432">
<p>Unicode<span style="font-family: 宋体;">文件名第</span><span style="font-family: Calibri;">1</span><span style="font-family: 宋体;">部分</span></p>
</td>
</tr>
<tr>
<td valign="top" width="72">
<p>BH</p>
</td>
<td valign="top" width="62">
<p>1</p>
</td>
<td valign="top" width="432">
<p>长文件名目录项标志，值默认<span style="font-family: Calibri;">FH</span></p>
</td>
</tr>
<tr>
<td valign="top" width="72">
<p>CH</p>
</td>
<td valign="top" width="62">
<p>1</p>
</td>
<td valign="top" width="432">
<p>保留</p>
</td>
</tr>
<tr>
<td valign="top" width="72">
<p>DH</p>
</td>
<td valign="top" width="62">
<p>1</p>
</td>
<td valign="top" width="432">
<p>校验值（根据短文件名计算）</p>
</td>
</tr>
<tr>
<td valign="top" width="72">
<p>EH</p>
</td>
<td valign="top" width="62">
<p>12</p>
</td>
<td valign="top" width="432">
<p>Unicode<span style="font-family: 宋体;">文件名第</span><span style="font-family: Calibri;">2</span><span style="font-family: 宋体;">部分</span></p>
</td>
</tr>
<tr>
<td valign="top" width="72">
<p>1AH</p>
</td>
<td valign="top" width="62">
<p>2</p>
</td>
<td valign="top" width="432">
<p>起始簇号</p>
</td>
</tr>
<tr>
<td valign="top" width="72">
<p>1CH</p>
</td>
<td valign="top" width="62">
<p>4</p>
</td>
<td valign="top" width="432">
<p>Unicode<span style="font-family: 宋体;">文件名第</span><span style="font-family: Calibri;">3</span><span style="font-family: 宋体;">部分</span></p>
</td>
</tr>
</tbody>
</table>
<p>我们再从其他盘复制过来一个长文件名的空文本文件，</p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/blog/1326234/201909/1326234-20190921121521512-1499784852.png" alt="" /></p>
<p>&nbsp;</p>
<p>查看一下根目录，</p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/blog/1326234/201909/1326234-20190921121527635-1464037013.png" alt="" /></p>
<p>长文件名是以链表方式存储的，所以能存很长很长的文件名，文件名结束符为&rsquo;\0&rsquo;<span style="font-family: 宋体;">，即</span>0H<span style="font-family: 宋体;">，如果结束符之后还有剩余的</span><span style="font-family: Calibri;">Unicode</span><span style="font-family: 宋体;">字符则以</span><span style="font-family: Calibri;">FFH</span><span style="font-family: 宋体;">填充，在长文件目录项的最后两行是它的短目录项存储格式哦，简单说一下为什么长文件目录项第</span><span style="font-family: Calibri;">1</span><span style="font-family: 宋体;">行第</span><span style="font-family: Calibri;">1</span><span style="font-family: 宋体;">字节为</span><span style="font-family: Calibri;">43H</span><span style="font-family: 宋体;">，下图，</span></p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/blog/1326234/201909/1326234-20190921121535570-1469730672.png" alt="" /></p>
<p>&nbsp;</p>
<p><span style="font-family: 宋体;">至此，简单的</span>FAT32<span style="font-family: 宋体;">组织结构已经介绍完了，欢迎读者深入探究。</span></p>
<p><span style="font-family: 宋体;">附上，一篇写</span>FAT32<span style="font-family: 宋体;">不错的博文：</span><a href="https://blog.csdn.net/yangyang031213/article/details/79030247" target="_blank"><span style="text-decoration: underline;">https://blog.csdn.net/yangyang031213/article/details/79030247</span></a></p>
<p>&nbsp;</p>
<p><span style="font-family: 宋体;">来说一下为什么上面要复制其他盘的文件到</span>D<span style="font-family: 宋体;">盘，因为直接在</span><span style="font-family: Calibri;">D</span><span style="font-family: 宋体;">盘新建一个文本文件是&ldquo;新建 文本文档</span><span style="font-family: Calibri;">.txt</span><span style="font-family: 宋体;">&rdquo;，然后我们将它重名名为&ldquo;</span><span style="font-family: Calibri;">NEW.TXT</span><span style="font-family: 宋体;">&rdquo;，然后在</span><span style="font-family: Calibri;">winhex</span><span style="font-family: 宋体;">查看，</span><span style="font-family: 宋体;">发现还是存在一个</span>&ldquo;新建 文本文档<span style="font-family: Calibri;">.txt</span><span style="font-family: 宋体;">&rdquo;的，只不过是删除状态的，所以为了避免这项因素的干扰，我就选择了从其他盘复制文件过来。</span></p>
<p>&nbsp;</p>
<p>附上簇的取值范围表：</p>
<table border="1" cellspacing="0">
<tbody>
<tr>
<td valign="top" width="91">
<p>分区大小</p>
</td>
<td valign="top" width="239">
<p>FAT32<span style="font-family: 宋体;">默认簇大小</span></p>
</td>
</tr>
<tr>
<td valign="top" width="91">
<p>32~256M</p>
</td>
<td valign="top" width="239">
<p>中间还分多个挡位：<span style="font-family: Calibri;">512B,1K,2K</span></p>
</td>
</tr>
<tr>
<td valign="top" width="91">
<p>257M~8G</p>
</td>
<td valign="top" width="239">
<p>4K</p>
</td>
</tr>
<tr>
<td valign="top" width="91">
<p>8G~16G</p>
</td>
<td valign="top" width="239">
<p>8K</p>
</td>
</tr>
<tr>
<td valign="top" width="91">
<p>32G~2T</p>
</td>
<td valign="top" width="239">
<p>32K</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-family: 宋体;">题外话，也算是一个练习，验证网上说的</span>&ldquo;<span style="font-family: Calibri;">FAT32</span><span style="font-family: 宋体;">最大只能存放</span><span style="font-family: Calibri;">4G</span><span style="font-family: 宋体;">的文件&rdquo;：</span></p>
<p><span style="font-family: 宋体;">因为</span>FAT32<span style="font-family: 宋体;">中目录项中每个文件的文件长度是</span><span style="font-family: Calibri;">4</span><span style="font-family: 宋体;">字节，</span><span style="font-family: Calibri;">4</span><span style="font-family: 宋体;">字节最大能寻址的字节数为</span><span style="font-family: Calibri;">2</span><span style="font-family: 宋体;">的</span><span style="font-family: Calibri;">32</span><span style="font-family: 宋体;">次，换算为</span><span style="font-family: Calibri;">G</span><span style="font-family: 宋体;">就是</span><span style="font-family: Calibri;">4G</span><span style="font-family: 宋体;">啦，即</span><span style="font-family: Calibri;">2^32B/1024^3=4G</span><span style="font-family: 宋体;">。</span></p>
<p>&nbsp;</p>]]></description></item><item><title>分享一下今天遇到的两个问题，一个是关于C语言内存泄漏问题，另一个是关于Linux下grep使用时的问题</title><link>http://www.cnblogs.com/ryzz/archive/2019/09/09/11491948.html</link><dc:creator>RYZZ</dc:creator><author>RYZZ</author><pubDate>Mon, 09 Sep 2019 07:28:00 GMT</pubDate><guid>http://www.cnblogs.com/ryzz/archive/2019/09/09/11491948.html</guid><description><![CDATA[<p><span style="font-size: 18pt;"><strong>C语言内存泄漏问题：</strong></span></p>
<p>给出如下代码：</p>
<div class="cnblogs_Highlighter">
<pre class="brush:cpp;gutter:true;">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main(){
	int *p;
	p=(int*)malloc(4);
	p[0]=12; //等于*p=12
	p[1]=13; //等于*(p+1)=13
	printf("%d\n",p[0]);
	printf("%d\n",p[1]);
	free(p);
	return 0;
}</pre>
</div>
<p>上述代码在VC++6.0下运行报错，错误截图如下：</p>
<p><img style="border: 1px solid black;" src="https://img2018.cnblogs.com/blog/1326234/201909/1326234-20190909150223147-660589292.png" alt="" width="225" height="170" /></p>
<p>原因是，我只申请了4字节的内存空间，但是却放了2个int（4字节）的数据，所以free的时候出现错误，但是！在GCC下编译却能运行，很奇怪（此问题待解决，如果懂的朋友可以在本文下方留言，欢迎讨论和学习）。（GCC是Win10下的CodeBlocks自带的MinGW的GCC5.1.0和RHEL7下的GCC4.8.2）</p>
<p><strong><span style="font-size: 18pt;">Linux的grep问题：</span></strong></p>
<p>给出如下shell代码：</p>
<div class="cnblogs_Highlighter">
<pre class="brush:cpp;gutter:true;">ll | grep a*
</pre>
</div>
<p>当前目录下有三个文件，分别为：a.c, a.c~, a.out。</p>
<p>而此shell运行的结果为：</p>
<p><img style="border: 1px solid black;" src="https://img2018.cnblogs.com/blog/1326234/201909/1326234-20190909151149724-1290048085.png" alt="" width="389" height="126" /></p>
<p>为什么结果不是输出所有以a开头的文件呢，而输出了"Binary file a.out matches"？</p>
<p>我们先来复习一下管道符的作用，它将前一个命令的<strong>标准输出</strong>重定向到后一个命令的<strong>标准输入</strong>，所以，如果一个命令不支持接收标准输入，那么使用管道符就没意义了。</p>
<p>我们还需要知道grep的基本用法，即grep string_to_search file1 file2 file3...</p>
<p>再来看一下grep命令的手册，其中在DESCRIPTION有这样一段话（粉色框）：</p>
<p><img style="border: 1px solid black;" src="https://img2018.cnblogs.com/blog/1326234/201909/1326234-20190910122155275-1719932576.png" alt="" width="536" height="139" /></p>
<p>大概的意思是说，grep会在给出的文件中或者标准输入中寻找要匹配的字符串，也就是说文件或者标准输入二选一，那么如果文件和标准输入同时给出会怎么样呢，我们试验一下：在abc目录下有两个文件，名为myFile1和myFile2，其中myFile1内容是一行"hello"，myFile2内容是一行"OKmy"，然后是三个命令以及它们的运行结果（下图）</p>
<p><img style="border: 1px solid black;" src="https://img2018.cnblogs.com/blog/1326234/201909/1326234-20190910122948739-505370048.png" alt="" width="393" height="235" /></p>
<p>分析一下这三条命令：</p>
<p>1."grep my myFile1 myFile2"：在给出的文件（myFile1和myFile2）中搜索字符串"my"</p>
<p>2."ls | grep my"：在来自ls的标准输出中搜索字符串"my"</p>
<p>3."ls | grep my myFile1 myFile2"：在这条grep中，我们<strong>同时</strong>给出了文件和标准输入（来自ls的标准输出），发现它运行的结果和第一条一样，所以我们可以看出，如果对grep同时给出文件和标准输入，那么它<strong>只在文件中搜索，而忽略标准输入！</strong></p>
<p>现在，我们再来看一下最初的问题，直接在终端上写的*是一种通配符，它会自动进行文件名扩展（这里推荐《学习bash：第二版》，第一章将各种扩展讲得很详细），所以上述代码"ll |grep a*"经过扩展之后就是"ll |grep a.c a.c~ a.out"了，再来看看扩展后的代码是在干嘛，扩展后的代码将ll的输出通过管道符重定向到grep命令的输入，但是，由于grep已经给出了搜索的文件（a.c~和a.out），所以这个标准输入被忽略，所以这个扩展后的代码是在做：从a.c~和a.out文件中搜索字符串"a.c"！！！！而a.out是一个程序，是一个二进制文件，当grep在二进制文件搜索文本时会提示"Binary file a.out matches"！</p>
<p>解决方法，使用双引号或单引号来抑制文件名扩展（使*的通配符功能消失，变成普通的字符，而这个普通的*会被grep当作正则表达式的元字符&mdash;&mdash;重复前一个字符0或多次！）：</p>
<p><img style="border: 1px solid black;" src="https://img2018.cnblogs.com/blog/1326234/201909/1326234-20190909153121863-1674534056.png" alt="" width="382" height="169" /></p>
<p>&nbsp;对上面粉色框中的文字更准确的理解：<br />grep会在给出的文件中搜索将要匹配的字符串，如果没有给出任何文件，那么将从标准输入中搜索，如下面的代码，只给出了要匹配的字符串"my"而没有给出文件，所以grep将在标准输入中搜索（按下^D结束标准输入流，也就结束了grep命令）：</p>
<p><img style="border: 1px solid black;" src="https://img2018.cnblogs.com/blog/1326234/201909/1326234-20190910124911361-1296096285.png" alt="" width="251" height="148" /></p>
<p>&nbsp;</p>]]></description></item><item><title>利用OD破解一个简单的C语言程序</title><link>http://www.cnblogs.com/ryzz/archive/2019/08/31/11439665.html</link><dc:creator>RYZZ</dc:creator><author>RYZZ</author><pubDate>Sat, 31 Aug 2019 09:01:00 GMT</pubDate><guid>http://www.cnblogs.com/ryzz/archive/2019/08/31/11439665.html</guid><description><![CDATA[<p>最近在学习汇编（看的是王爽老师的《汇编语言(第三版)》），然后想尝试使用OD(Ollydbg)软件破解一个简单的C语言程序练练手。</p>
<p><span style="font-size: 12px;"><em>环境：</em></span></p>
<p><span style="font-size: 12px;"><em>C语言编译环境：VC++6.0</em></span></p>
<p><span style="font-size: 12px;"><em>系统：在Windows10下开的VM虚拟机中的Windows XP</em></span></p>
<p>C语言程序代码：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> #include &lt;STDIO.H&gt;
<span style="color: #008080;"> 2</span> 
<span style="color: #008080;"> 3</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
</span><span style="color: #008080;"> 4</span>     <span style="color: #0000ff;">int</span><span style="color: #000000;"> age;
</span><span style="color: #008080;"> 5</span>     age=<span style="color: #800080;">10</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 6</span>     <span style="color: #0000ff;">if</span> (age==<span style="color: #800080;">10</span><span style="color: #000000;">){
</span><span style="color: #008080;"> 7</span>         printf(<span style="color: #800000;">"</span><span style="color: #800000;">Successful\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 8</span>     }<span style="color: #0000ff;">else</span><span style="color: #000000;">{
</span><span style="color: #008080;"> 9</span>         printf(<span style="color: #800000;">"</span><span style="color: #800000;">No Access\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">10</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">11</span> <span style="color: #000000;">    getchar();
</span><span style="color: #008080;">12</span> 
<span style="color: #008080;">13</span>     <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">14</span> }</pre>
</div>
<p>这个程序编译后，正常运行输出的是"Successful"，而现在的目的是采用反汇编让该程序输出"NO Access"。</p>
<p>我们先在VC6中分析一下这个程序反汇编(Disassembly)之后的结果：（这个步骤不会请自行百度）</p>
<p><img style="border: 1px solid black;" src="https://img2018.cnblogs.com/blog/1326234/201908/1326234-20190831163341936-1686581853.png" alt="" width="497" height="342" /></p>
<p>简单分析之后，可以看出"if (age==10)"被编译为：</p>
<p>CMP DWORD PTR [EBP-4],0AH</p>
<p>JNE main+34H&nbsp;</p>
<p>分析一下这两条汇编指令：</p>
<p>CMP用于将SS:[EBP-4]内存单元中（这个内存单元保存的就是变量age的值）数据与0AH做减法运算，但是不保存结果，只影响标志位，由于被减数和减数都是0AH，所以相减为0，标志位ZF=1。</p>
<p>JNE全称为Jump if Not Equal，它与JNZ(Jump if Not Zero)指令等价（为什么要说到JNZ呢，因为在OD软件中是JNZ而不是JNE），JNE/JNZ判断标志位ZF是否为1，如果为1则不跳转，显然此时的ZF=1，那就是不跳转了，将继续执行下面的指令，就输出了"Successful"了。</p>
<p>而我们需要输出"No Access"，就需要让它跳转，那怎么让它跳转呢，很简单，只需要将JNE修改为JE就行了，JE就是如果ZF=1则跳转。</p>
<p>知道了突破口，用OD打开这个程序，找到00401033H行（由于编译环境不同，读者可能不是此行，建议使用ASCII字符串搜索"Successful"进行跳转，此方法自行百度）。</p>
<p><img src="https://img2018.cnblogs.com/blog/1326234/201908/1326234-20190831165429117-63882573.png" alt="" width="418" height="204" /></p>
<p>双击选中的行，将jnz改写为jz，然后单击&ldquo;汇编&rdquo;按钮即可。</p>
<p><img src="https://img2018.cnblogs.com/blog/1326234/201908/1326234-20190831165540696-1326063196.png" alt="" /></p>
<p>&nbsp;</p>
<p>在修改的行右键，选择&ldquo;复制到可执行文件&rdquo;-&gt;&ldquo;所有修改&rdquo;，在跳出的对话框中选择&ldquo;全部复制&rdquo;。</p>
<p><img src="https://img2018.cnblogs.com/blog/1326234/201908/1326234-20190831165712728-1837241485.png" alt="" width="508" height="297" /></p>
<p>&nbsp;</p>
<p>&nbsp;在跳出的新窗口中右键选择&ldquo;保存文件&rdquo;即可保存修改之后的程序。</p>
<p><img src="https://img2018.cnblogs.com/blog/1326234/201908/1326234-20190831165934333-1074708623.png" alt="" width="483" height="230" /></p>
<p>&nbsp;</p>
<p>&nbsp;然后运行修改之后的程序，显示的就是"No Access"啦！</p>
<p><img src="https://img2018.cnblogs.com/blog/1326234/201908/1326234-20190831170047006-585786307.png" alt="" /></p>]]></description></item><item><title>编码简述</title><link>http://www.cnblogs.com/ryzz/archive/2019/03/15/8460000.html</link><dc:creator>RYZZ</dc:creator><author>RYZZ</author><pubDate>Fri, 15 Mar 2019 06:04:00 GMT</pubDate><guid>http://www.cnblogs.com/ryzz/archive/2019/03/15/8460000.html</guid><description><![CDATA[<p>常见编码有UCS-2, UCS-4, UTF-8, UTF-16, UTF-32, ASCII, ANSI等等。</p>
<p>我们都知道ASCII，这是最早也是最简单的一种编码，美国人用1个字节（准确的来说是后7位，即0x00到0x7F）来编码英文字母、标点、数字等等，后来西方国家（法国、德国等）把最高位也利用上，来编码自己的语言字符（前128个字符与美国的一样，后面128个根据每个国家语言的不同而不同，比如法国的第200位是'&eacute;'，而德国的第200位是'&auml;'），这样ASCII字符集就被扩展了。</p>
<p>可是，到了亚洲，编码一下子就复杂了？单单一门汉语，字符个数就是万级别的（常用的汉字大约3000个），更不用说还有韩文、日文等。我们国家也有自己的几套编码方案，如GB2312，GBK，GB18030等，同样的，日本有Shift-JIS等，韩国有 EUC-KR等。</p>
<p>ISO（国际标准化组织）决定要制订一个包含地球所有语种在内的通用字符集，这项项目叫做Unicode（Universal Multiple-Octet Coded Character Set，简称UCS），它从序号 0 开始对全球所有语种的字符进行编号，为了保证兼容，前128个字符就是最早的ASCII编码。其中UCS-2, UCS-4, UTF-8, UTF-16, UTF-32, GBK, BIG5, EUC-KR等等都是对Unicode的一种实现方式，前5种是全球通用的实现方式，后面3种是具体地区对Unicode的实现方式。</p>
<p>UCS-2：对每个字符都采用2个字节的编码方式，比如字母'a'的编码就是0x0061，可以表示2^16个字符，但是对纯英文文档，使用这种编码的文件是使用ASCII编码大小的2倍。（有些文本编辑器中的Unicode编码就是指此编码，一般而言，广义的Unicode表示上述提到的ISO制定的项目，侠义的Unicode表示以2个字节来编码字符的一种编码方式，等同于UCS-2）</p>
<p>UCS-4：和UCS-2一样，始终用4个字节表示一个字符，其实真正使用时只用了31位，最高位规定为0，而2^31=0x80000000，所以UCS-4的范围是[0x00000000, 0x7FFFFFFF]，现在的Unicode编号只编到了0x10FFFF，这个范围已经包含了目前地球已知的所有语种字符，我们把每65536个字符称作一个平面，其中[0,65535]称为基本多文种平面(Basic Multilingual Plane,简称BMP)，[65536,0x10FFFF]还有16个平面，所以[0,0x10FFFF]一共有17个平面。（平面是如何划分的？以及每个平面包含哪些内容？见附1）</p>
<p>UTF-8：全球最通用的编码方式，具体编码规则见附2。（Unicode转UTF-8的规则可以参阅百度百科：<a title="UTF-8编码 - 百度百科" href="https://baike.baidu.com/item/UTF-8" target="_blank">UTF-8</a>）</p>
<p>UTF-16：是对UCS-2的扩展，位于基本平面的字符和UCS-2编码相同，后面的从第65536开始一直到0x10FFFF编号的字符是UTF-16新增的字符集，用4个字节编码。在一个UTF-16编码的文件，当遇到2个字节时，如何判断是代表1个字符还是和后面的2个字节组合在一起用4个字节表示的一个字符呢？所以UTF-16中引出了代理对的概念，在UTF-16中为了要表示剩下的16个平面的字符时（UTF-16范围是 0 到 0x10FFFF 为止的，共17个平面），在基本平面的0xD800~0xDFFF这些码点设为代理，一共可以代理1024的平方个字符（0xD800~0xDBFF共1024个，0xDC00~0xDFFF共1024个），正好是剩下的16个平面的范围，可以自行验算。</p>
<p>UTF-32：同UCS-4，始终用4字节编码一个字符。</p>
<p>GBK：前128个字符同ASCII，后面汉字编号的具体规则可以参阅相关的资料。</p>
<p>ANSI：该编码表示，当前的编码是基于ASCII扩展过来的（若一种编码的第0~127位与ANSII一样，就称此编码为ANSI），在Windows简体中文版中，默认的ANSI就是GBK，在Windows繁体中文版就是BIG5。</p>
<p>附1：</p>
<table border="1">
<tbody>
<tr>
<td>平面：</td>
<td>编码范围：</td>
<td>英文名：</td>
<td>中文名：</td>
</tr>
<tr>
<td>0号平面</td>
<td>U+0000~FFFF</td>
<td>Basic Multilingual Plane</td>
<td>基本多文种平面，简称BMP</td>
</tr>
<tr>
<td>1号平面</td>
<td>U+10000~1FFFF</td>
<td>Supplementary Multilingual Plane</td>
<td>多文种补充平面，简称SMP</td>
</tr>
<tr>
<td>2号平面</td>
<td>U+20000~2FFFF</td>
<td>Supplementary Idographic Plane</td>
<td>表意文字补充平面，简称SIP</td>
</tr>
<tr>
<td>3号平面</td>
<td>U+30000~3FFFF</td>
<td>Tertiary Ideographic Plane</td>
<td>表意文字第三平面，简称TIP</td>
</tr>
<tr>
<td>4~13号平面</td>
<td>U+40000~DFFFF</td>
<td>None</td>
<td>保留，尚未使用</td>
</tr>
<tr>
<td>14号平面</td>
<td>U+E0000~EFFFF</td>
<td>Supplementary Special-purpose Plane</td>
<td>特殊用途补充平面，简称SSP</td>
</tr>
<tr>
<td>15号平面</td>
<td>U+F0000~FFFFF</td>
<td>Private Use Area A</td>
<td>私人使用平面A，简称PUA-A</td>
</tr>
<tr>
<td>16号平面</td>
<td>U+100000~10FFFF</td>
<td>Private Use Area B</td>
<td>私人使用平面B，简称PUA-B</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>附2：</p>
<table border="1">
<tbody>
<tr>
<td>Unicode范围：（十六进制）</td>
<td>UTF-8表示格式：</td>
<td>字节数：</td>
<td>说明：</td>
</tr>
<tr>
<td>0000~007F</td>
<td>0XXX XXXX</td>
<td>1</td>
<td>标准ASCII范围</td>
</tr>
<tr>
<td>0080~07FF</td>
<td>110X XXXX 10XX XXXX{1}</td>
<td>2</td>
<td>除东亚的基本世界字符（东亚字符占世界全部字符的70%）</td>
</tr>
<tr>
<td>0800~FFFF</td>
<td>1110 XXXX 10XX XXXX{2}</td>
<td>3</td>
<td>基本平面</td>
</tr>
<tr>
<td>1 0000~1F FFFF</td>
<td>1111 XXXX 10XX XXXX{3}</td>
<td>4</td>
<td>Unicode6.1定义的范围是[0,10FFFF]</td>
</tr>
<tr>
<td>20 0000~3FF FFFF</td>
<td>1111 10XX 10XX XXXX{4}</td>
<td>5</td>
<td>无</td>
</tr>
<tr>
<td>400 0000~7FFF FFFF</td>
<td>1111 110X 10XX XXXX{5}</td>
<td>6</td>
<td>通用字符集的极限</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>附3：（常见的以数字标识的编码）</p>
<table border="0">
<tbody>
<tr>
<td>数字代码：</td>
<td>编码名称：</td>
<td>说明：</td>
</tr>
<tr>
<td>37</td>
<td>IBM037</td>
<td>IBM EBCDIC （美国 - 加拿大）</td>
</tr>
<tr>
<td>437</td>
<td>IBM437</td>
<td>OEM 美国</td>
</tr>
<tr>
<td>500</td>
<td>IBM500</td>
<td>IBM EBCDIC （国际）</td>
</tr>
<tr>
<td>850</td>
<td>IBM850</td>
<td>西欧字符</td>
</tr>
<tr>
<td>852</td>
<td>IBM852</td>
<td>中欧字符</td>
</tr>
<tr>
<td>932</td>
<td>Shift-JIS</td>
<td>日语</td>
</tr>
<tr>
<td>936</td>
<td>GBK</td>
<td>简体中文</td>
</tr>
<tr>
<td>949</td>
<td>KS_C_5601-1987</td>
<td>朝鲜语</td>
</tr>
<tr>
<td>950</td>
<td>BIG5</td>
<td>繁体中文</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>字符串"a我易"在不同编码下的实现：</p>
<p>UTF-8：（61）（ E6 88 91）（ E6 98 93）</p>
<p>UTF-8 BOM：（EF BB BF）（ 61）（ E6 88 91）（ E6 98 93）</p>
<p>GBK：（61）（ CE D2）（ D2 D7）</p>
<p>UCS-2：（FF FE）（ 61 00）（ 11 62）（ 13 66）</p>
<p>UCS-2 BE：（FE FF）（ 00 61）（ 62 11）（ 66 13）</p>
<p>UTF-16：（FF FE）（ 61 00）（ 11 62）（ 13 66）</p>
<p>UTF-16 BE：（FE FF）（ 00 61）（ 62 11）（ 66 13）</p>
<p>UTF-32：（FF FE 00 00）（ 61 00 00 00 ）（11 62 00 00 ）（13 66 00 00）</p>
<p>UTF-32 BE：（00 00 FE FF）（ 00 00 00 61 ）（00 00 62 11）（ 00 00 66 13）</p>
<p>字符串"a我\u{1D306}"在不同编码下的实现，其中\u{1D306}是一个非基本平面的字符，该字符为：𝌆（有些浏览器可能不支持显示该字符，正常显示的话，该字符类似汉字&ldquo;三&rdquo;多一横）</p>
<p>UTF-8：（61）（ E6 88 91）（ F0 9D 8C 86）</p>
<p>UTF-16：（FF FE ）（61 00 ）（11 62 ）（34 D8 06 DF）</p>
<p>UTF-32：（FF FE 00 00）（ 61 00 00 00）（ 11 62 00 00）（ 06 D3 01 00）</p>
<p>&nbsp;</p>
<p>文献参考：</p>
<p>1.百度百科</p>
<p>2.博客（CSDN、博客园、简书等），由于参考较多，也过于细碎，无法一一列举</p>
<p>3.千千秀字网站的一些资料(www.qqxiuzi.cn)</p>]]></description></item><item><title>计算机操作系统发展历史简述</title><link>http://www.cnblogs.com/ryzz/archive/2018/08/13/9470282.html</link><dc:creator>RYZZ</dc:creator><author>RYZZ</author><pubDate>Mon, 13 Aug 2018 11:07:00 GMT</pubDate><guid>http://www.cnblogs.com/ryzz/archive/2018/08/13/9470282.html</guid><description><![CDATA[<p>1947，发明了晶体管，使得计算机不再是机械设备，而是电子设备，为操作系统奠定了基础。</p>
<p>1960，很多计算机制造商做出了各自的可以进行批处理操作的系统，但是只能限定于限定的硬件环境。</p>
<p>1964，IBM推出了IBM System/360系统，能够在一系列的硬件环境中运行。</p>
<p>1965，AT&amp;T贝尔实验室、麻省理工和其他一些团队打算搞一个多用户多任务的复杂操作系统，取名为Multics（Multiplexed Information and Computing System），但是1969年，该项目发展过于缓慢，导致破产。</p>
<p>1969，参与项目的Ken Thompson（汤姆森）和Dennis Ritchie（瑞奇）因为项目的破产回到贝尔实验室，利用PDP-7机器写了一个简易的系统（1970年完成），但是因为调侃这个系统无法和Multics媲美（其实是调侃Multics），就取名为Unics（Uniplexed Information and Computing System）,汤姆森把名字稍微改了一下变成了Unix，所以1970便是Unix的元年。<br />其他：早期的Unix是完全使用汇编写的，在开发Unix时候汤姆森在BCPL（由CPL（Combined Programming Language）改进而来，两者都由剑桥大学发明）基础上发明了B语言，然后对Unix使用B语言进行了部分改进，1973年，瑞奇与汤姆森一起改进了B语言从而发明了C语言，1974年，Unix用C语言完全重写并且向外界发布。</p>
<p>1974，贝尔实验室把Unix的源代码拷贝给了各个实验室、学校、公司，其中加州大学伯里克分校对Unix源代码进行了深度研究不断改进Unix，极大地推进了Unix的发展，其中著名的TCP/IP协议就是他们在Unix实现的，然后他们把他们搞的这一套Unix称作BSD（Berkeley Software Distribution）。</p>
<p>1980，西雅图一名程序员研发出86-DOS系统，被微软比尔盖茨买下版权。</p>
<p>1981，MS-DOS上市，与IBM合作，在IBM机器上捆绑销售MS-DOS。</p>
<p>1983，AT&amp;T被反垄断法拆成了几个子公司，这时，AT&amp;T看到Unix分光无限好决定对其进行商业用途，不再对外开放源代码，然而伯里克分校的BSD团队并不需要钱，所以他们把受Unix商业版影响的代码部分全部自己改写。最后BSD项目团队最后研究出了完全自己的Unix，因为版权问题只能叫做类Unix系统（Unix-like）（例如Free-BSD, MAC OS前身等等）。</p>
<p>1983，Richard Stallman发起革奴计划（GNU，GNU is Not Unix，意指是一个免费的，开源的，自由的，和Unix一样强大的，但不是Unix的系统），目标是创建一个完全自由开放的操作系统。</p>
<p>1984，苹果公司发布基于BSD项目的操作系统System 1.0（MAC OS 8之前都是以System x.x命名的），并搭载在麦金塔电脑上，含有桌面、窗口?、图标、光标、菜单和卷动栏等项目。<br />其他：这是第一款真正的图形界面桌面系统，微软的Windows当时还只是嵌入在MSDOS下的一个程序而已。</p>
<p>1990，此时，GNU计划已经完成了Unix中大部分工具的编写工作，就是GNU操作系统内核（当时称为HURD）迟迟没能完成。</p>
<p>1991，System 7发布，这时的MAC OS已经具备了256色的简易图形界面，当时的微软还停留在DOS时代。</p>
<p>1991，芬兰赫尔辛基大学的Linus Torvalds学生，在校期间自己搞了一个操作系统玩玩，当时在自己的系统中使用了GNU的GCC, Bash等软件，受到GNU计划的影响，他把自己的系统内核源代码发布到了网上，内核取名Linux（Linus's Unix）。</p>
<p>1992，当时不太成熟的Linux内核和GNU工具结合产生了一个完整的自由的操作系统，称为GNU/Linux。<br />其他：在GNU/Linux诞生的年代，已经有很多优秀的开源项目，他们和GNU计划无关，都是个人或是组织开发，例如Vim, Apache, Perl, Python等等。也正是GNU/Linux的开源影响，世界掀起了一股开源热，兴起了开源文化的运动，大量开源项目出现，例如PHP, MYSQL, Ruby, NodeJS, KDE等等。<br />其他：GNU/Linux现在都被简称为Linux，其实是不规范的，也是对GNU不尊敬的表现。</p>
<p>1993，MS-DOS 6.X ~ MS-DOS 7.X（1996年），其中添加了一款名叫Windows的GUI程序。（Windows 1.x/2.x/3.x一直到Windows 9X/ME都是MS-DOS下的一个GUI（图形用户界面）程序！）</p>
<p>1993，微软发布Windows10 NT 3.1系统，这时Windows NT的第一代产品，包括Workstation和Server两个版本。</p>
<p>1994，当时1991年Linux发布到网上，世界各地广大程序员对其产生兴趣，对其研究改进，94年3月Linux 1.0发布，Linux成为了一个基本可用的系统内核，从此Linux开始了迅猛的发展。（至于为什么Linux图标是个企鹅，因为Linus小时候被企鹅攻击过，其实也没什么逻辑关系，就像你问鲁迅窗帘为什么是蓝色的，他会回答你就是我当时随便选了一个颜色而已）<br />其他：当时的BSD衍生的系统还在和AT&amp;T的Unix系统打官司，也促使了Linux的发展，并且Linus本人承认当时他不知道还有FreeBSD这样的系统存在，如果知道的话，可能就不会有Linux了。</p>
<p>1995，GNU/Linux系统越做越成熟，各个发行版推进了GNU/Linux在全世界的推广。</p>
<p>1996，KDE团队创建了K桌面环境项目（K Desktop Environment），为GNU/Linux系统设计图形化桌面环境，桌面要有浏览器，所以他们就分了一个组来设计浏览器内核，这便是大名鼎鼎的KHTML和KJavaScript，便有了之后的Webkit和Blink。</p>
<p>1996，微软发布Windows NT 4.0操作系统，是NT系列的一个里程碑，为接下来2000年之后Windows迅猛发展打下了基础。</p>
<p>1997，MAC OS 8问世，这时历史上第一款32位色彩，用户界面相当友好的桌面系统，甚至被称为艺术作品，以至于在Windows 2000之后的系统中模拟出惟妙惟肖的Mac OS X操作环境为荣。</p>
<p>1997，GNU发起GNOME(The GNU Network Object Model Environment)计划，意指为UNIX-like系统提供统一的桌面环境，1999年第一个版本发布。</p>
<p>2000，MS-DOS 8.0发布，这时最后一个MSDOS版本，因为微软看到了Windows的曙光，于是放弃了DOS，发布Windows NT操作系统。<br />其他：Windows NT在2000之前并不流行，直到Windows2000（NT5.0），XP（NT5.1），Vista（NT6.0），Win7（NT6.1）的诞生，Windows才真正的开始迎来自己的巅峰。另外：Windows 10预览版内核NT6.4，正式版内核NT10.0。</p>
<p>2002，南非商人Mark shuttleworth推出了Ubuntu发行版。</p>]]></description></item><item><title>C语言中以文本方式读写文件时换行符转换的注意事项</title><link>http://www.cnblogs.com/ryzz/archive/2018/07/24/9358337.html</link><dc:creator>RYZZ</dc:creator><author>RYZZ</author><pubDate>Tue, 24 Jul 2018 01:46:00 GMT</pubDate><guid>http://www.cnblogs.com/ryzz/archive/2018/07/24/9358337.html</guid><description><![CDATA[<p>我们知道在UNIX下是没有回车符（\r）的，只有换行符（\n），而C语言诞生于UNIX（Linux即面向开源的UNIX，Mac OS也是UNIX发展而来的，而Windows是从MS-DOS发展而来，与前两者不同），所以C语言的源代码文件中也是以 \n 表示换行。</p>
<p>所以总结一下：</p>
<p>Windows下换行采用 <strong>\r\n</strong> 表示，全称回车换行符。</p>
<p>UNIX（Linux）下换行采用 <strong>\n</strong> 表示，即换行符。</p>
<p>Mac OS下换行采用 <strong>\r</strong> 表示，即回车符。</p>
<p>&nbsp;</p>
<p>所以，当C语言在Windows下以文本方式读取文件就会出现一个转换，看如下代码：</p>
<div class="cnblogs_code">
<pre>FILE *<span style="color: #000000;"> f1;
f1 </span>= fopen(<span style="color: #800000;">"</span><span style="color: #800000;">utf8.txt</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">r</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008000;">/*</span><span style="color: #008000;">
    "utf8.txt"文件的十六进制结构如下：
    41 42 43 0D 0A 44 44 4B
</span><span style="color: #008000;">*/</span><span style="color: #000000;">
fseek(f1, </span><span style="color: #800080;">3</span><span style="color: #000000;">, SEEK_SET);
printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%x\n</span><span style="color: #800000;">"</span><span style="color: #000000;">, getc(f1));
printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%x\n</span><span style="color: #800000;">"</span><span style="color: #000000;">, getc(f1));
fclose(f1);</span></pre>
</div>
<p>输出结果：</p>
<p>a<br />44<br />Press any key to continue</p>
<p>解释：当我们把文件指针通过fseek函数移到位置 3 时，文件指针指向了回车符（0x0D），然后我们用getc函数读取当前文件指针所指的字节时，C语言会把<em>Windows下表示换行的0x0D和0x0A两个字节</em>看成<em>UNIX下表示换行的0x0A一个字节</em>，所以，此时getc函数返回的是0x0A这个值。故，这次的getc函数读完后文件指针向后偏移两个字节，导致了下一个的getc返回的是0x44。</p>
<p>同理，当C语言在Windows下工作时，用putc向文件输入 \n 时会被自动转成 \r\n，如下代码：</p>
<div class="cnblogs_code">
<pre>FILE *<span style="color: #000000;"> f1;
f1 </span>= fopen(<span style="color: #800000;">"</span><span style="color: #800000;">new.txt</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">w</span><span style="color: #800000;">"</span><span style="color: #000000;">);
putc(</span><span style="color: #800000;">'</span><span style="color: #800000;">\n</span><span style="color: #800000;">'</span><span style="color: #000000;">, f1);
fclose(f1);</span></pre>
</div>
<p>"new.txt"文件的十六进制结构：</p>
<p>0D 0A</p>
<p>解释：上述代码会在当前目录创建一个新文件"new.txt"，并以文本方式只写模式打开文件流，然后通过putc向该文件输入字符 \n，这时C语言会自动把 \n 转为 \r\n，原理同上。</p>
<p><span style="text-decoration: underline; color: #ff0000;"><strong>注意的是：C语言是否自动转换 \n 与 \r\n 取决于编译C语言程序时所在的系统，也同理在Mac OS下，C语言会自动发生 \n 与 \r的转换。</strong></span></p>
<p>当然，这种情况是不会发生转换的：</p>
<div class="cnblogs_code">
<pre>FILE *<span style="color: #000000;"> f1;
f1 </span>= fopen(<span style="color: #800000;">"</span><span style="color: #800000;">utf8.txt</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">r</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008000;">/*</span><span style="color: #008000;">
    该文件的十六进制结构如下：
    31 32 33 0A 0D
</span><span style="color: #008000;">*/</span><span style="color: #000000;">
fseek(f1, </span><span style="color: #800080;">3</span><span style="color: #000000;">, SEEK_SET);
printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%x\n</span><span style="color: #800000;">"</span><span style="color: #000000;">, getc(f1));
printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%x\n</span><span style="color: #800000;">"</span><span style="color: #000000;">, getc(f1));
fclose(f1);</span></pre>
</div>
<p>输出结果：</p>
<p>a<br />d<br />Press any key to continue</p>
<p>解释：因为只有在Windows下编译的C程序，并且以文本方式打开一个文件，并且读取的0x0D后面紧跟着0x0A才会发生转换，也就是说0x0D 0x0A两个字节必须作为一个整体出现，显然，上述代码例子颠倒了 \r\n 的顺序。</p>
<p>另外，在Mac OS下编译的C程序，以文本方式读取一个以 \n 表示换行的文件时，也是不会发生 \r 与 \n的转换的，只有该文件以 \r 表示换行时才会发生&nbsp;\r 与 \n的转换。</p>]]></description></item><item><title>关于C语言中EOF的一点认识</title><link>http://www.cnblogs.com/ryzz/archive/2018/07/23/9354396.html</link><dc:creator>RYZZ</dc:creator><author>RYZZ</author><pubDate>Mon, 23 Jul 2018 06:13:00 GMT</pubDate><guid>http://www.cnblogs.com/ryzz/archive/2018/07/23/9354396.html</guid><description><![CDATA[<p>总结来说：EOF（即End Of File）是一个文件结束的标记，当文件被读取到EOF位置时，参与读取的函数会返回整型值 -1，这时要注意的是：这个值被赋值给有符号char类型时是0xff，被赋值给有符号short时是0x00ff，有符号int即0x000000ff。</p>
<p>有以下代码：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> #include &lt;stdio.h&gt;
<span style="color: #008080;"> 2</span> <span style="color: #0000ff;">struct</span><span style="color: #000000;"> student{
</span><span style="color: #008080;"> 3</span>     <span style="color: #0000ff;">char</span> name[<span style="color: #800080;">5</span><span style="color: #000000;">];
</span><span style="color: #008080;"> 4</span>     <span style="color: #0000ff;">char</span><span style="color: #000000;"> sex;
</span><span style="color: #008080;"> 5</span>     <span style="color: #0000ff;">short</span><span style="color: #000000;"> age;
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">};
</span><span style="color: #008080;"> 7</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
</span><span style="color: #008080;"> 8</span>     FILE * f1, *<span style="color: #000000;"> f2;
</span><span style="color: #008080;"> 9</span>     unsigned <span style="color: #0000ff;">int</span><span style="color: #000000;"> count;
</span><span style="color: #008080;">10</span>     <span style="color: #0000ff;">short</span><span style="color: #000000;"> ch;
</span><span style="color: #008080;">11</span> 
<span style="color: #008080;">12</span>     count = <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">13</span> 
<span style="color: #008080;">14</span>     f1 = fopen(<span style="color: #800000;">"</span><span style="color: #800000;">ascii.txt</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">rb</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">15</span>     ch=<span style="color: #000000;">fgetc(f1);
</span><span style="color: #008080;">16</span>     <span style="color: #0000ff;">while</span> (ch!=<span style="color: #000000;">EOF){
</span><span style="color: #008080;">17</span>         count++<span style="color: #000000;">;
</span><span style="color: #008080;">18</span>         ch =<span style="color: #000000;"> fgetc(f1);
</span><span style="color: #008080;">19</span>         <span style="color: #008000;">//</span><span style="color: #008000;">可以看到被测试文件的第二个字符是FF，它以有符号char类型保存时值是-1，与EOF值相符，如果变量ch类型是有符号char就会出现结束循环，导致错误的计数
</span><span style="color: #008080;">20</span>         <span style="color: #008000;">//</span><span style="color: #008000;">然而这里的ch类型是有符号short，当FF赋值给有符号short类型时是0x00FF，它的值是255，所以不与EOF（-1）相符，可以正常计数</span>
<span style="color: #008080;">21</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">22</span>     fseek(f1, <span style="color: #800080;">2</span><span style="color: #000000;">, SEEK_SET);
</span><span style="color: #008080;">23</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">, ftell(f1));
</span><span style="color: #008080;">24</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">code is:%x\n</span><span style="color: #800000;">"</span>, getc(f1)==<span style="color: #000000;">EOF);
</span><span style="color: #008080;">25</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">code is:%x\n</span><span style="color: #800000;">"</span>, getc(f1)==<span style="color: #000000;">EOF);
</span><span style="color: #008080;">26</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">code is:%x\n</span><span style="color: #800000;">"</span><span style="color: #000000;">, getc(f1));
</span><span style="color: #008080;">27</span>     <span style="color: #008000;">//</span><span style="color: #008000;">最后一个getc(f1)输出为八个f，原因很简单，因为这时候已经取到了EOF，而EOF的值是-1，所以这时getc返回-1，C语言中整型直接常量的类型是有符号int，所以就得到了有符号int类型的0xffffffff（它的值就是-1）</span>
<span style="color: #008080;">28</span> 
<span style="color: #008080;">29</span> <span style="color: #000000;">    fclose(f1);
</span><span style="color: #008080;">30</span> 
<span style="color: #008080;">31</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">total btyes:%ld\n</span><span style="color: #800000;">"</span><span style="color: #000000;">, count);
</span><span style="color: #008080;">32</span> 
<span style="color: #008080;">33</span>     <span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
</span><span style="color: #008080;">34</span> }</pre>
</div>
<p>输出结果：</p>
<p>2<br />code is:0<br />code is:1<br />code is:ffffffff<br />total btyes:3<br />Press any key to continue</p>
<p>被测试文件（ascii.txt）的十六进制结构为：</p>
<p>33 FF 55</p>
<p>另外，任何尝试读取非法的文件指针所指向的字符（字节）时都会返回 -1，如下代码所示：</p>
<div class="cnblogs_code">
<pre>fseek(f1, <span style="color: #800080;">14</span><span style="color: #000000;">, SEEK_SET);
printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">, ftell(f1));
printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">code is:%x\n</span><span style="color: #800000;">"</span>, getc(f1));</pre>
</div>
<p>输出：</p>
<p>14<br />code is:ffffffff<br />Press any key to continue</p>
<p>解释：还是以"ascii.txt"为例，fseek移到了非法的位置 14 时（因为一共就0， 1， 2三个位置），getc函数返回-1。</p>
<p>最后：fseek函数需要注意的是（SEEK_SET, CUR, END结果都相同，SEEK_END指向的是文件的EOF位置），它不会把文件指针移到位置 0 之前（如下代码所示），但是能移到EOF位置之后（如上代码所示）：</p>
<div class="cnblogs_code">
<pre>fseek(f1, -<span style="color: #800080;">2</span><span style="color: #000000;">, SEEK_SET);
printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">, ftell(f1));
printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">code is:%x\n</span><span style="color: #800000;">"</span>, getc(f1));</pre>
</div>
<p>输出：</p>
<p>0<br />code is:33<br />Press any key to continue</p>
<p>解释：第二个参数是 -2，应该从SEEK_SET位置向前移动两个字符，即ftell函数应该返回 -2，但是实际上并没有移动。</p>]]></description></item><item><title>关于C语言变量声明在其他语句后的一些细节</title><link>http://www.cnblogs.com/ryzz/archive/2018/07/09/9283751.html</link><dc:creator>RYZZ</dc:creator><author>RYZZ</author><pubDate>Mon, 09 Jul 2018 06:46:00 GMT</pubDate><guid>http://www.cnblogs.com/ryzz/archive/2018/07/09/9283751.html</guid><description><![CDATA[<p>今天一个同学来找我，说他的代码老是编译不通过，我看了半天，好像都很符合逻辑，但一直显示一个变量未定义，我就纳闷了，代码类似如下：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
</span><span style="color: #008080;">2</span> <span style="color: #000000;">    login();
</span><span style="color: #008080;">3</span>     <span style="color: #0000ff;">int</span><span style="color: #000000;"> id;
</span><span style="color: #008080;">4</span>     scanf(<span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>, &amp;<span style="color: #000000;">id);
</span><span style="color: #008080;">5</span> <span style="color: #000000;">    ....
</span><span style="color: #008080;">6</span> }</pre>
</div>
<p>他用的是VC6，编译器一直提示变量"id"未定义，做了一些猜测性调试，仍是错误，我就凭着感觉把login;和int id;互换了个行，发现成功编译，然后他就走了，留下我一个人回想着原来错误的代码在电脑前凌乱，于是就有了下面的发现。</p>
<p>&nbsp;</p>
<p>给出如下C代码：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
</span><span style="color: #008080;">2</span>     <span style="color: #0000ff;">int</span><span style="color: #000000;"> a;
</span><span style="color: #008080;">3</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">, a);
</span><span style="color: #008080;">4</span>     <span style="color: #0000ff;">int</span><span style="color: #000000;"> b;
</span><span style="color: #008080;">5</span>     printf(<span style="color: #800000;">"</span><span style="color: #800000;">%d,%d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">, a ,b);
</span><span style="color: #008080;">6</span> 
<span style="color: #008080;">7</span>     <span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
</span><span style="color: #008080;">8</span> }</pre>
</div>
<p>在VC6模式下，第 5 行会报错：error C2065: 'b' : undeclared identifier。</p>
<p>结论：这是一个早期的C语言规定，在VC6（即C90标准）下，每个块级作用域中的所有变量的声明必须放在最前面，一旦执行任何其他非声明语句之后，后续的任何声明都将错误。C99之后，此标准被改变，允许在任何需要变量的时候进行声明。</p>]]></description></item><item><title>C语言“%”运算符</title><link>http://www.cnblogs.com/ryzz/archive/2018/07/07/9277372.html</link><dc:creator>RYZZ</dc:creator><author>RYZZ</author><pubDate>Sat, 07 Jul 2018 07:22:00 GMT</pubDate><guid>http://www.cnblogs.com/ryzz/archive/2018/07/07/9277372.html</guid><description><![CDATA[<p>C语言中运算符&ldquo;%&rdquo;是取余运算符，而非取模运算符。（运算符&ldquo;%&rdquo;在C/C++, JAVA中，为取余运算，而在Python中为取模运算）</p>
<p>对于一个C语言取余表达式a % b，设其值为result，有如下公式：</p>
<p>　　1. k = (int)a / b （(int)强制类型转换，会把值向 0 方向舍入）</p>
<p>　　2.&nbsp;result = a - k * b</p>
<p>取模和取余的区别：计算 k 的值时舍入的方向不同，取模运算符会把 a / b 的结果向负无穷取舍，而取余运算符会把 a / b 的结果向 0 取舍。（例如，-4 / 3 的取模时 k 的值为 -2 ，而取余时 k 的值为 -1）</p>
<p>例子：</p>
<p>　　求13 % 4的值。</p>
<p>　　1. k = (int)13 / 4 = 3</p>
<p>　　2.&nbsp;result = 13 - 3 * 4 = 1</p>
<p>　　所以，其值为1。</p>
<p>注意事项：取余运算符的两个操作数必须都是整数，且第二个操作数不能为零。</p>
<p>特殊情况：</p>
<p>　　当|a| &lt; |b|时，值永远是 a。</p>
<p>　　当|a| = |b|时，值永远是 0。</p>
<p>　　当&nbsp; a = 0 时，值永远是 0。</p>
<p>&nbsp;</p>]]></description></item></channel></rss>
